### Array

| Topic          | Concept Summary                                                               | Key Formulas                              | Code Example                                                                                           | Time Complexity | Space Complexity |
| -------------- | ----------------------------------------------------------------------------- | ----------------------------------------- | ------------------------------------------------------------------------------------------------------ | --------------- | ---------------- |
| Prefix Sum     | Precomputes cumulative sum to answer range sum queries in O(1)                | `prefix[i] = prefix[i - 1] + arr[i]`      | `int prefix[n]; prefix[0] = arr[0]; for(int i=1; i<n; i++) prefix[i] = prefix[i-1] + arr[i];`          | O(n)            | O(n)             |
| Carry Forward  | Carry some state (like count or max) forward to avoid recalculation           | `count++` or `max = max(max, current)`    | `int count = 0; for (int i = 0; i < n; i++) if (arr[i]==1) count++;`                                   | O(n)            | O(1)             |
| Sliding Window | Use a fixed-size or dynamic-size window to calculate something over subarrays | `sum += arr[i] - arr[i-k]` for fixed-size | `int sum=0; for(int i=0; i<k; i++) sum += arr[i]; for(int i=k; i<n; i++){ sum += arr[i] - arr[i-k]; }` | O(n)            | O(1)             |
| Contribution   | Calculate how many times each element appears in all subarrays                | `arr[i] * (i+1) * (n-i)`                  | `long long sum = 0; for(int i=0; i<n; i++) sum += arr[i] * (i+1) * (n-i);`                             | O(n)            | O(1)             |

### 2D Matrix

| Topic                  | Concept Summary                                           | Key Formulas                                                      | Code Example                                                                | Time Complexity | Space Complexity |
| ---------------------- | --------------------------------------------------------- | ----------------------------------------------------------------- | --------------------------------------------------------------------------- | --------------- | ---------------- |
| 2D Array Basics        | Matrix representation using nested arrays                 | `matrix[i][j]`                                                    | `for(int i=0;i<n;i++) for(int j=0;j<m;j++) cout << matrix[i][j];`           | O(n\*m)         | O(n\*m)          |
| Row-wise Prefix Sum    | Precomputes row-wise cumulative sums for each row         | `rowSum[i][j] = rowSum[i][j-1] + matrix[i][j]`                    | `for(int i=0;i<n;i++) for(int j=1;j<m;j++) rowSum[i][j] += rowSum[i][j-1];` | O(n\*m)         | O(n\*m)          |
| Column-wise Prefix Sum | Precomputes cumulative column sums                        | `colSum[i][j] = colSum[i-1][j] + matrix[i][j]`                    | `for(int j=0;j<m;j++) for(int i=1;i<n;i++) colSum[i][j] += colSum[i-1][j];` | O(n\*m)         | O(n\*m)          |
| 2D Prefix Sum (DP)     | Helps calculate submatrix sum in O(1) after preprocessing | `sum[i][j] = A[i][j] + sum[i-1][j] + sum[i][j-1] - sum[i-1][j-1]` | `Build prefixSum matrix; use it to get sum of any submatrix in O(1)`        | O(n\*m)         | O(n\*m)          |
| Transpose of Matrix    | Flip matrix over its diagonal                             | `B[j][i] = A[i][j]`                                               | `for(int i=0;i<n;i++) for(int j=0;j<m;j++) B[j][i] = A[i][j];`              | O(n\*m)         | O(n\*m)          |
| Rotate 90° Clockwise   | Reverse rows + transpose or custom logic                  | `rotate(matrix)` = reverse + transpose                            | `Transpose + reverse each row`                                              | O(n²)           | O(1) (in-place)  |
| Spiral Order Traversal | Visit elements in spiral order from outer to inner layer  | Traverse layer by layer                                           | `while(top <= bottom && left <= right)...`                                  | O(n\*m)         | O(1)             |

### Two Pointer

| **Topic**                               | **Concept Summary**                                         | **Key Formulas**                                                | **Code Example (Pseudocode)**                                                                                                                                                                                                                                                                                                                                                                 | **Time Complexity** | **Space Complexity** |
| --------------------------------------- | ----------------------------------------------------------- | --------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------- | -------------------- |
| **Two Pointer Technique**               | Use two indices to traverse array efficiently               | Use `left` and `right` with `while left < right` condition      | `left = 0, right = n - 1`<br>`while left < right:`<br>    `if condition:`<br>        `left++`<br>    `else:`<br>        `right--`                                                                                                                                                                                                                                                             | O(n)                | O(1)                 |
| **Sorted Array Two Sum**                | Find two elements that sum to a target in a sorted array    | If `arr[left] + arr[right] < target` ⇒ `left++`, else `right--` | `left = 0, right = n - 1`<br>`while left < right:`<br>    `sum = arr[left] + arr[right]`<br>    `if sum == target: return [left, right]`<br>    `elif sum < target: left++`<br>    `else: right--`                                                                                                                                                                                            | O(n)                | O(1)                 |
| **Move Zeros to End**                   | Move all 0s to the end while maintaining order of non-zeros | Use slow pointer to track insert position                       | `slow = 0`<br>`for fast in 0 to n-1:`<br>    `if arr[fast] != 0:`<br>        `swap(arr[slow], arr[fast])`<br>        `slow++`                                                                                                                                                                                                                                                                 | O(n)                | O(1)                 |
| **Reverse Array/String**                | Reverse elements by swapping from both ends                 | Use `left++`, `right--` until `left < right`                    | `left = 0, right = n - 1`<br>`while left < right:`<br>    `swap(arr[left], arr[right])`<br>    `left++, right--`                                                                                                                                                                                                                                                                              | O(n)                | O(1)                 |
| **Palindrome Check**                    | Check if string/array reads same forward and backward       | Compare `s[left] == s[right]`                                   | `left = 0, right = len(s) - 1`<br>`while left < right:`<br>    `if s[left] != s[right]: return False`<br>    `left++, right--`<br>`return True`                                                                                                                                                                                                                                               | O(n)                | O(1)                 |
| **Container With Most Water**           | Max area between lines on x-axis                            | `area = min(height[left], height[right]) * (right - left)`      | `left = 0, right = n - 1, maxArea = 0`<br>`while left < right:`<br>    `area = min(height[left], height[right]) * (right - left)`<br>    `maxArea = max(maxArea, area)`<br>    `if height[left] < height[right]: left++ else: right--`                                                                                                                                                        | O(n)                | O(1)                 |
| **Remove Duplicates from Sorted Array** | Eliminate duplicates in-place in sorted array               | Use fast to explore, slow to update unique values               | `if n == 0: return 0`<br>`slow = 0`<br>`for fast in 1 to n-1:`<br>    `if arr[fast] != arr[slow]:`<br>        `slow += 1`<br>        `arr[slow] = arr[fast]`<br>`return slow + 1`                                                                                                                                                                                                             | O(n)                | O(1)                 |
| **Trapping Rain Water**                 | Calculate trapped water between bars of different heights   | `water += min(leftMax, rightMax) - height[i]`                   | `left = 0, right = n - 1, leftMax = 0, rightMax = 0, water = 0`<br>`while left < right:`<br>    `if height[left] < height[right]:`<br>        `leftMax = max(leftMax, height[left])`<br>        `water += leftMax - height[left]`<br>        `left++`<br>    `else:`<br>        `rightMax = max(rightMax, height[right])`<br>        `water += rightMax - height[right]`<br>        `right--` | O(n)                | O(1)                 |

### Bit Manipulation

| Topic            | Concept Summary                                 | Key Formulas / Tricks              | Code Example                                   | Time Complexity | Space Complexity |
| ---------------- | ----------------------------------------------- | ---------------------------------- | ---------------------------------------------- | --------------- | ---------------- | ---- |
| Check Even/Odd   | Use last bit to check parity                    | `n & 1` → `0` if even, `1` if odd  | `if (n & 1) → Odd else Even`                   | O(1)            | O(1)             |
| Get ith Bit      | Check if ith bit is set (0-indexed)             | `(n >> i) & 1`                     | `(n >> i) & 1`                                 | O(1)            | O(1)             |
| Set ith Bit      | Set ith bit to 1                                | `n OR (1 << i)`                    | `n = n                                         | (1 << i)`       | O(1)             | O(1) |
| Clear ith Bit    | Set ith bit to 0                                | `n & ~(1 << i)`                    | `n = n & ~(1 << i)`                            | O(1)            | O(1)             |
| Toggle ith Bit   | Flip the ith bit                                | `n ^ (1 << i)`                     | `n = n ^ (1 << i)`                             | O(1)            | O(1)             |
| Count Set Bits   | Count number of 1s in binary representation     | Use Brian Kernighan’s Algo         | `while(n){ count++; n = n & (n-1); }`          | O(log n)        | O(1)             |
| Check Power of 2 | Only one bit is set in power of 2               | `n & (n - 1) == 0` if n > 0        | `if (n > 0 && (n & (n - 1)) == 0)`             | O(1)            | O(1)             |
| Swap Two Numbers | Swap using XOR                                  | `a = a ^ b; b = a ^ b; a = a ^ b;` | `a ^= b; b ^= a; a ^= b;`                      | O(1)            | O(1)             |
| XOR All Numbers  | XORing all elements where duplicates cancel out | `res ^= nums[i]`                   | `int res = 0; for(int num : nums) res ^= num;` | O(n)            | O(1)             |

### Strings

| **Topic**                         | **Concept Summary**                    | **Key Idea**                         | **Code Example (Pseudocode)**                                                                                                                                                                                  | **Time Complexity** | **Space Complexity** |
| --------------------------------- | -------------------------------------- | ------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------- | -------------------- |
| **Reverse a String**              | Reverse characters in-place            | Use two-pointer swap                 | `left = 0, right = n-1`<br>`while left < right:`<br>  `swap(s[left], s[right])`<br>  `left++, right--`                                                                                                         | O(n)                | O(1)                 |
| **Palindrome Check**              | Same forwards and backwards            | Compare characters from both ends    | `left = 0, right = n-1`<br>`while left < right:`<br>  `if s[left] != s[right]: return False`<br>  `left++, right--`                                                                                            | O(n)                | O(1)                 |
| **Anagram Check**                 | Same character count                   | Use hash map or sorting              | `if (s1.length() != s2.length()) <br>    return false;<br>    <br>// Sort both strings<br>sort(s1.begin(), s1.end());<br>sort(s2.begin(), s2.end());<br>// Compare sorted strings<br>return (s1 == s2);`       | O(n)                | O(1)                 |
| **String Compression**            | Replace repeated characters with count | Traverse and count consecutive chars | `res = ""`<br>`count = 1`<br>`for i in range(1, len(s)):`<br>  `if s[i] == s[i-1]: count += 1`<br>  `else: res += s[i-1] + str(count); count = 1`<br>`res += s[-1] + str(count)`                               | O(n)                | O(n)                 |
| **Longest Common Prefix**         | Common start in array of strings       | Compare first string with all        | `prefix = strs[0]`<br>`for s in strs[1:]:`<br>  `while not s.startswith(prefix): prefix = prefix[:-1]`<br>`return prefix`                                                                                      | O(n \* m)           | O(1)                 |
| **String to Integer (Atoi)**      | Convert string to int                  | Handle whitespaces, signs, overflow  | `i = 0, sign = 1, res = 0`<br>`skip spaces`<br>`check '+'/'-'`<br>`while i < n and s[i].isdigit():`<br>  `res = res*10 + int(s[i])`<br>`return clamp(sign * res)`                                              | O(n)                | O(1)                 |
| **Longest Palindromic Substring** | Expand around center                   | For each index, expand outwards      | `for i in range(n):`<br>  `expand(i, i)`<br>  `expand(i, i+1)`<br>`# expand: while l>=0 and r<n and s[l]==s[r]`                                                                                                | O(n²)               | O(1)                 |
| **Rabin-Karp / KMP**              | Pattern matching in strings            | Use hashing or prefix table          | **Rabin-Karp:** Use rolling hash<br>**KMP:** Build LPS (prefix) array<br>`while i < n:`<br>  `if pattern[j] == text[i]: i++, j++`<br>  `if j == m: match`<br>  `else if j != 0: j = lps[j-1]`<br>  `else: i++` | O(n + m)            | O(n) / O(m)          |

### Mathematics

| **Topic**                     | **Concept Summary**                     | **Key Formula / Idea**                     | **Code / Notes**                                            | **Time Complexity** | **Space** |
| ----------------------------- | --------------------------------------- | ------------------------------------------ | ----------------------------------------------------------- | ------------------- | --------- |
| **Prime Check**               | Check if number is prime                | Only check till √n                         | `for i in 2 to sqrt(n): if n % i == 0: not prime`           | O(√n)               | O(1)      |
| **Sieve of Eratosthenes**     | Find all primes up to n                 | Mark multiples of each prime               | `sieve[n] = false` if composite                             | O(n log log n)      | O(n)      |
| **GCD / HCF**                 | Greatest common divisor                 | `gcd(a, b) = gcd(b, a % b)`                | Euclidean algorithm                                         | O(log min(a,b))     | O(1)      |
| **LCM**                       | Least common multiple                   | `lcm(a, b) = (a * b) / gcd(a, b)`          | Use `gcd()` to compute                                      | O(log min(a,b))     | O(1)      |
| **Fast Exponentiation**       | Compute a^b % m efficiently             | Divide power in halves                     | `res = 1; while b > 0: if b&1: res*=a; a*=a; b>>=1`         | O(log b)            | O(1)      |
| **Modular Arithmetic**        | Important for large number computations | (a + b) % m, (a \* b) % m, (a - b + m) % m | Used in CP for constraints like 10⁹+7                       | O(1)                | O(1)      |
| **Modular Inverse**           | To divide under modulo                  | If m is prime: `a^(m-2) % m`               | Use Fermat’s Little Theorem                                 | O(log m)            | O(1)      |
| **Combinatorics (nCr % mod)** | Count combinations modulo               | Precompute factorial and inverse           | `fact[i] = i! % mod`<br>`inv[i] = pow(fact[i], mod-2, mod)` | O(n) precompute     | O(n)      |
| **Digit Sum / Reverse**       | Basic number operations                 | Repeated % and // by 10                    | `while n: sum += n % 10; n //= 10`                          | O(log n)            | O(1)      |
| **Palindrome Number**         | Reverse and compare                     | Compare number with its reverse            | `is_palindrome = (n == reverse(n))`                         | O(log n)            | O(1)      |
| **Trailing Zeros in n!**      | Count number of 5s in factors           | Count how many times 5 divides n!          | `zeros = 0`<br>`while n:`<br>  `n //= 5`<br>  `zeros += n`  | O(log n)            | O(1)      |
| **Base Conversion**           | Convert between decimal, binary, etc.   | Use division and modulo or built-in APIs   | `binary = bin(n)`<br>`decimal = int("101", 2)`              | O(log n)            | O(1)      |
| **Check Power of 2**          | Check if exactly one set bit            | n > 0 and `n & (n - 1) == 0`               | `is_power_of_2 = n > 0 and (n & (n - 1)) == 0`              | O(1)                | O(1)      |

### Hash Map

| **Topic**                        | **Concept Summary**                        | **Key Formulas / Notes**           | **Code Example (C++)**                                                                                                                                                                                                  | **Time Complexity** | **Space Complexity** |
| -------------------------------- | ------------------------------------------ | ---------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------- | -------------------- |
| **Frequency Count**              | Count how many times each element appears  | `hash[arr[i]]++`                   | `unordered_map<int, int> freq;\nfor (int x : arr) freq[x]++;`                                                                                                                                                           | O(n)                | O(n)                 |
| **Check for Duplicates**         | Detect if any value appears more than once | Use hash set while traversing      | `unordered_set<int> s;\nfor (int x : arr) {\n  if (s.count(x)) return true;\n  s.insert(x);\n}`                                                                                                                         | O(n)                | O(n)                 |
| **First Non-Repeating Element**  | Track order & frequency                    | Frequency + Queue                  | `unordered_map<char, int> freq;\nfor (char c : s) freq[c]++;\nfor (char c : s)\n  if (freq[c] == 1) return c;`                                                                                                          | O(n)                | O(n)                 |
| **Two Sum Problem**              | Find pair of numbers that sum to target    | `target - arr[i]` in hash          | `unordered_map<int, int> m;\nfor (int i = 0; i < n; i++) {\n  if (m.count(target - arr[i])) return true;\n  m[arr[i]] = i;\n}`                                                                                          | O(n)                | O(n)                 |
| **Longest Subarray with Sum K**  | Store prefix sums and their indices        | `map[prefixSum] = index`           | `unordered_map<int, int> m;\nm[0] = -1;\nint sum = 0, maxLen = 0;\nfor (int i = 0; i < n; i++) {\n  sum += arr[i];\n  if (m.count(sum - k)) maxLen = max(maxLen, i - m[sum - k]);\n  if (!m.count(sum)) m[sum] = i;\n}` | O(n)                | O(n)                 |
| **Group Anagrams**               | Group words with same character frequency  | Key: sorted string or count vector | `map<string, vector<string>> groups;\nfor (string& word : words) {\n  string key = word;\n  sort(key.begin(), key.end());\n  groups[key].push_back(word);\n}`                                                           | O(n × k log k)      | O(n × k)             |
| **Subarrays with Equal 0s & 1s** | Convert 0s to -1s → find sum = 0 subarrays | Prefix sum + count hash map        | `unordered_map<int, int> m;\nm[0] = 1;\nint sum = 0, count = 0;\nfor (int x : arr) {\n  sum += (x == 0 ? -1 : 1);\n  count += m[sum];\n  m[sum]++;\n}`                                                                  | O(n)                | O(n)                 |
| **Count Distinct Elements**      | Track unique elements                      | Use `unordered_set`                | `unordered_set<int> s(arr.begin(), arr.end());\nint distinct = s.size();`                                                                                                                                               | O(n)                | O(n)                 |

### Sorting

| **Topic**          | **Concept Summary**                                               | **Key Formulas / Steps**                            | **Code Example (Pseudocode)**                                                                                                                                        | **Time Complexity**                         | **Space Complexity**       |
| ------------------ | ----------------------------------------------------------------- | --------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------- | -------------------------- |
| **Bubble Sort**    | Repeatedly swap adjacent elements if they are in the wrong order  | Loop n times, swap if `arr[j] > arr[j+1]`           | `for i = 0 to n-1:`<br>  `for j = 0 to n-i-2:`<br>    `if arr[j] > arr[j+1]: swap`                                                                                   | Worst: O(n²)<br>Best: O(n) (already sorted) | O(1)                       |
| **Selection Sort** | Select the smallest element and swap it to the beginning          | Find minimum index and swap                         | `for i = 0 to n-1:`<br>  `min_idx = i`<br>  `for j = i+1 to n-1:`<br>    `if arr[j] < arr[min_idx]: min_idx = j`<br>  `swap(arr[i], arr[min_idx])`                   | O(n²)                                       | O(1)                       |
| **Insertion Sort** | Build sorted array by inserting elements into correct position    | Shift larger elements right, insert current element | `for i = 1 to n-1:`<br>  `key = arr[i]`<br>  `j = i-1`<br>  `while j >= 0 and arr[j] > key:`<br>    `arr[j+1] = arr[j]; j--`<br>  `arr[j+1] = key`                   | Worst: O(n²)<br>Best: O(n) (nearly sorted)  | O(1)                       |
| **Merge Sort**     | Divide and conquer: recursively divide and merge sorted halves    | Split array, then merge two sorted halves           | `mergeSort(arr, l, r):`<br>  `if l < r:`<br>    `mid = (l + r) / 2`<br>    `mergeSort(arr, l, mid)`<br>    `mergeSort(arr, mid+1, r)`<br>    `merge(arr, l, mid, r)` | O(n log n)                                  | O(n) (for temp array)      |
| **Quick Sort**     | Pick pivot, partition array, and recursively sort left and right  | Place pivot correctly, recurse left and right       | `quickSort(arr, low, high):`<br>  `if low < high:`<br>    `pi = partition(arr, low, high)`<br>    `quickSort(arr, low, pi-1)`<br>    `quickSort(arr, pi+1, high)`    | Avg: O(n log n)<br>Worst: O(n²) (bad pivot) | O(log n) (recursive stack) |
| **Counting Sort**  | Count frequency of elements and use prefix sum to place correctly | Use count array to compute positions                | `count[arr[i]]++`<br>`accumulate count`<br>`place into output[]`                                                                                                     | O(n + k) (k = range of values)              | O(k + n) (count + output)  |
| **Heap Sort**      | Build a max heap, swap root with end, heapify rest                | Use binary heap (heapify + extract max)             | `buildMaxHeap(arr)`<br>`for i = n-1 to 1:`<br>  `swap(arr[0], arr[i])`<br>  `heapify(arr, 0, i)`                                                                     | O(n log n)                                  | O(1) (in-place)            |

### Binary Search

| **Topic**                    | **Concept Summary**                                           | **Key Formulas / Conditions**                      | **Code Example (Pseudocode)**                                                                                                                                                                                                                                                                                       | **Time Complexity** | **Space Complexity** |
| ---------------------------- | ------------------------------------------------------------- | -------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------- | -------------------- |
| **Basic Binary Search**      | Find target in sorted array using divide and conquer          | `mid = (low + high) / 2`, compare with `arr[mid]`  | `while (low ≤ high):`<br>  `mid = (low + high) / 2`<br>  `if arr[mid] == target: return mid`<br>  `if arr[mid] < target: low = mid + 1`<br>  `else: high = mid - 1`                                                                                                                                                 | O(log n)            | O(1)                 |
| **Lower Bound**              | First index where value ≥ target                              | If `arr[mid] ≥ target`, move left                  | `low = 0, high = n`<br>`while (low < high):`<br>  `mid = (low + high) / 2`<br>  `if arr[mid] ≥ x: high = mid`<br>  `else: low = mid + 1`                                                                                                                                                                            | O(log n)            | O(1)                 |
| **Upper Bound**              | First index where value > target                              | If `arr[mid] > target`, move left                  | `low = 0, high = n`<br>`while (low < high):`<br>  `mid = (low + high) / 2`<br>  `if arr[mid] > x: high = mid`<br>  `else: low = mid + 1`                                                                                                                                                                            | O(log n)            | O(1)                 |
| **Search in Rotated Array**  | Search for element in rotated sorted array                    | Compare `arr[mid]` with `arr[low]` and `arr[high]` | `while (low ≤ high):`<br>  `mid = (low + high)/2`<br>  `if arr[mid] == target: return mid`<br>  `if arr[low] ≤ arr[mid]:`<br>    `if arr[low] ≤ target < arr[mid]: high = mid - 1`<br>    `else: low = mid + 1`<br>  `else:`<br>    `if arr[mid] < target ≤ arr[high]: low = mid + 1`<br>    `else: high = mid - 1` | O(log n)            | O(1)                 |
| **First/Last Occurrence**    | Find first or last position of target (with duplicates)       | If match, update answer and move left/right        | `res = -1`<br>`while (low ≤ high):`<br>  `mid = (low + high)/2`<br>  `if arr[mid] == target:`<br>    `res = mid`<br>    `if searching first: high = mid - 1`<br>    `else: low = mid + 1`<br>  `elif arr[mid] < target: low = mid + 1`<br>  `else: high = mid - 1`                                                  | O(log n)            | O(1)                 |
| **Binary Search on Answer**  | Search in range of possible answers (not in array)            | Apply binary on values, not indices                | `while (low ≤ high):`<br>  `mid = (low + high) / 2`<br>  `if isValid(mid): ans = mid; high = mid - 1`<br>  `else: low = mid + 1`                                                                                                                                                                                    | O(log(range))       | O(1)                 |
| **Peak Element**             | Find index `i` where `arr[i] > arr[i-1] && arr[i] > arr[i+1]` | If `arr[mid] < arr[mid+1]`, go right               | `while (low < high):`<br>  `mid = (low + high)/2`<br>  `if arr[mid] < arr[mid+1]: low = mid + 1`<br>  `else: high = mid`<br>`return low`                                                                                                                                                                            | O(log n)            | O(1)                 |
| **Minimum in Rotated Array** | Find min in rotated sorted array (no duplicates)              | If `arr[mid] > arr[high]`, go right                | `while (low < high):`<br>  `mid = (low + high)/2`<br>  `if arr[mid] > arr[high]: low = mid + 1`<br>  `else: high = mid`<br>`return arr[low]`                                                                                                                                                                        | O(log n)            | O(1)                 |

### Linked List

| **Topic**                         | **Concept Summary**                             | **Key Formulas / Approaches**               | **Code Example**                                                                                            | **Time Complexity** | **Space Complexity** |
| --------------------------------- | ----------------------------------------------- | ------------------------------------------- | ----------------------------------------------------------------------------------------------------------- | ------------------- | -------------------- |
| **Linked List Basics**            | Linear structure using pointers                 | Node has `data` and `next`                  | `struct Node { int data; Node* next; };`                                                                    | -                   | -                    |
| **Insert at Beginning**           | Add new node before head                        | `newNode->next = head; head = newNode;`     | `Node* newNode = new Node(val); newNode->next = head; head = newNode;`                                      | O(1)                | O(1)                 |
| **Insert at End**                 | Traverse to last node, append new node          | `last->next = newNode;`                     | `Node* temp = head; while(temp->next) temp = temp->next; temp->next = newNode;`                             | O(n)                | O(1)                 |
| **Insert at Index**               | Traverse to index-1, update pointers            | -                                           | `for (int i = 0; i < pos - 1; i++) temp = temp->next; newNode->next = temp->next; temp->next = newNode;`    | O(n)                | O(1)                 |
| **Delete Node**                   | Skip node by changing links                     | `prev->next = toDelete->next;`              | `if (pos == 0) head = head->next; else traverse to pos-1 and adjust next pointers`                          | O(1)/O(n)           | O(1)                 |
| **Reverse Linked List**           | Reverse links iteratively                       | `prev = NULL; curr = head;` loop            | `while(curr) { Node* next = curr->next; curr->next = prev; prev = curr; curr = next; } head = prev;`        | O(n)                | O(1)                 |
| **Middle of Linked List**         | Slow and fast pointer approach                  | `slow = head; fast = head;`                 | `while(fast && fast->next) { slow = slow->next; fast = fast->next->next; }`                                 | O(n)                | O(1)                 |
| **Detect Cycle**                  | Floyd’s Tortoise & Hare                         | `if slow == fast` then cycle                | `while(fast && fast->next) { slow = slow->next; fast = fast->next->next; if (slow == fast) return true; }`  | O(n)                | O(1)                 |
| **Length of Loop**                | Count steps from meeting point                  | Loop again till slow meets fast             | `count = 1; temp = slow->next; while(temp != slow) { count++; temp = temp->next; }`                         | O(n)                | O(1)                 |
| **Remove Loop**                   | Reset one pointer to head, move both one step   | When slow == fast, set fast->next = NULL    | `slow = head; while(slow->next != fast->next) { slow = slow->next; fast = fast->next; } fast->next = NULL;` | O(n)                | O(1)                 |
| **Merge Two Sorted Lists**        | Merge by comparing node values                  | Recursively or iteratively                  | `if (!l1) return l2; if (!l2) return l1;` → then link smaller node recursively                              | O(n + m)            | O(n + m) rec / O(1)  |
| **Intersection Point of 2 Lists** | Equalize length, compare nodes                  | Or use set                                  | Advance longer list, then `while(p1 != p2) { p1 = p1->next; p2 = p2->next; } return p1;`                    | O(n + m)            | O(1) / O(n)          |
| **Detect Palindrome Linked List** | Reverse 2nd half, compare                       | Optional: Restore list                      | Find middle, reverse, compare both halves, optional restore                                                 | O(n)                | O(1)                 |
| **Add Two Numbers**               | Add digits like elementary math                 | Reverse → add → reverse                     | Loop till both lists end and carry is 0; create result node with `sum % 10`                                 | O(n)                | O(n) (output)        |
| **Copy List with Random Pointer** | 3-pass approach: clone, assign random, separate | Without hashmap: interleaving               | Interleave cloned nodes with original, assign randoms, then separate lists                                  | O(n)                | O(1) (w/o map)       |
| **Sort Linked List**              | Use merge sort                                  | Divide into halves, sort recursively        | `mergeSort(Node* head)`, use `getMid()` and `merge()`                                                       | O(n log n)          | O(log n)             |
| **Rotate Linked List**            | Convert to circular list, then break            | Count length, `k = k % len`, break at len-k | Find `len`, connect tail to head, traverse to `len-k`, update head and tail                                 | O(n)                | O(1)                 |
| **Remove Nth Node from End**      | Two-pointer gap                                 | Second pointer advances `n` steps           | `first = head; for i in 0..n: first = first->next; second = head; while(first): ...`                        | O(n)                | O(1)                 |

### Stacks

| Topic                              | Concept Summary                                                         | Key Formulas / Approach                               | ✅ Code Example (Pseudocode / C++)                                                                                                                                                                              | Time Complexity    | Space Complexity |
| ---------------------------------- | ----------------------------------------------------------------------- | ----------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------ | ---------------- |
| **Stack Basics**                   | LIFO (Last-In-First-Out) data structure                                 | Push, Pop, Top, isEmpty                               | `stack<int> st; st.push(x); st.top(); st.pop(); st.empty();`                                                                                                                                                    | O(1) for all ops   | O(n)             |
| **Valid Parentheses**              | Use stack to match opening and closing brackets                         | Push when open, pop when close and match              | \`for (char c : s) { if (isOpen(c)) st.push(c); else if (st.empty()                                                                                                                                             | O(n)               | O(n)             |
| **Next Greater Element**           | Use stack to find the next greater number to the right for each element | Traverse from right, maintain stack of candidates     | `for (int i = n-1; i >= 0; i--) { while (!st.empty() && st.top() <= arr[i]) st.pop(); result[i] = st.empty() ? -1 : st.top(); st.push(arr[i]); }`                                                               | O(n)               | O(n)             |
| **Stock Span Problem**             | Find previous greater element using stack                               | Maintain decreasing stack                             | `for (int i = 0; i < n; i++) { while (!st.empty() && price[st.top()] <= price[i]) st.pop(); span[i] = st.empty() ? i+1 : i - st.top(); st.push(i); }`                                                           | O(n)               | O(n)             |
| **Largest Rectangle in Histogram** | Use stack to find max area with each bar as smallest height             | Push index, pop when decreasing, calculate area       | \`for (int i = 0; i <= n; i++) { while (!st.empty() && (i == n                                                                                                                                                  | O(n)               | O(n)             |
| **Asteroid Collision**             | Simulate collisions using stack                                         | Pop if asteroid is smaller or equal and opposite sign | `for (int a : asteroids) { while (!st.empty() && a < 0 && st.top() > 0) { if (st.top() < -a) st.pop(); else if (st.top() == -a) { st.pop(); a = 0; break; } else { a = 0; break; } } if (a != 0) st.push(a); }` | O(n)               | O(n)             |
| **Remove K Digits**                | Remove k digits to form smallest number                                 | Monotonic increasing stack                            | `for (char digit : num) { while (k > 0 && !st.empty() && st.top() > digit) { st.pop(); k--; } st.push(digit); }`<br>`// remove remaining if k > 0`<br>`while (k--) st.pop();`<br>`// build result`              | O(n)               | O(n)             |
| **Decode String**                  | Decode nested pattern strings like `3[a2[c]]` using stack               | Use stack for count and string                        | `for (char c : s) { if (isdigit(c)) parse number; else if (c == '[') push currStr and count; else if (c == ']') pop and repeat; else append to currStr; }`                                                      | O(n)               | O(n)             |
| **Design Min Stack**               | Support push, pop, top, and getMin in O(1)                              | Use `stack<pair<int, minSoFar>>`                      | `stack<pair<int, int>> st;`<br>`void push(int x) { int minSoFar = st.empty() ? x : min(x, st.top().second); st.push({x, minSoFar}); }`<br>`int getMin() { return st.top().second; }`                            | O(1) per operation | O(n)             |

### Queue

| **Topic**                | **Concept Summary**               | **Key Idea**                      | **Code Example (C++)**                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            | **Time Complexity**         | **Space Complexity** |
| ------------------------ | --------------------------------- | --------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------- | -------------------- |
| **Queue Basics**         | FIFO (First In First Out)         | Enqueue (push), Dequeue (pop)     | `cpp<br>#include \<queue\><br>queue\<int\> q;<br>q.push(x);     // enqueue<br>q.pop();      // dequeue<br>q.front();   // get front`                                                                                                                                                                                                                                                                                                                                                                                                                                              | O(1)                        | O(n)                 |
| **Circular Queue**       | Fixed-size queue with wrap-around | Use modulo for indices            | `cpp<br>int front = 0, rear = 0;<br>rear = (rear + 1) % size;   // enqueue<br>front = (front + 1) % size; // dequeue<br>`                                                                                                                                                                                                                                                                                                                                                                                                                                                         | O(1)                        | O(n)                 |
| **Deque (Double Ended)** | Add/remove from both ends         | Use std::deque                    | `cpp<br>#include \<deque\><br>deque\<int\> dq;<br>dq.push_back(x);<br>dq.push_front(x);<br>dq.pop_back();<br>dq.pop_front();`                                                                                                                                                                                                                                                                                                                                                                                                                                                     | O(1)                        | O(n)                 |
| **Queue Using Stack**    | Implement queue using two stacks  | One for input, one for output     | `cpp<br>stack\<int\> s1, s2;<br>// enqueue<br>s1.push(x);<br>// dequeue<br>if (s2.empty()) { while (!s1.empty()) { s2.push(s1.top()); s1.pop(); } }<br>int val = s2.top(); s2.pop();`                                                                                                                                                                                                                                                                                                                                                                                             | O(1) amortized / O(n) worst | O(n)                 |
| **Sliding Window Max**   | Max in window using deque         | Store indices in decreasing order | `cpp<br>deque\<int\> dq;<br>for (int i = 0; i < n; i++) {<br>  while (!dq.empty() && nums[dq.back()] < nums[i]) dq.pop_back();<br>  dq.push_back(i);<br>  if (i >= k - 1) result.push_back(nums[dq.front()]);<br>  if (dq.front() <= i - k) dq.pop_front();<br>}`                                                                                                                                                                                                                                                                                                                 | O(n)                        | O(k)                 |
| **Level Order in Tree**  | BFS traversal using queue         | Push children nodes in queue      | `cpp<br>queue\<TreeNode*\> q;<br>q.push(root);<br>while (!q.empty()) {<br>  TreeNode* node = q.front(); q.pop();<br>  if (node->left) q.push(node->left);<br>  if (node->right) q.push(node->right);<br>}`                                                                                                                                                                                                                                                                                                                                                                        | O(n)                        | O(n)                 |
| **Rotten Oranges**       | Multi-source BFS                  | Push all 2s initially to queue    | `cpp<br>queue\<tuple\<int, int, int\>\> q;<br>for (all cells) if (grid[i][j] == 2) q.push({i, j, 0});<br>while (!q.empty()) {<br>  auto [i, j, t] = q.front(); q.pop();<br>  for (each neighbor) if (grid[ni][nj] == 1) { grid[ni][nj] = 2; q.push({ni, nj, t + 1}); }<br>}`                                                                                                                                                                                                                                                                                                      | O(n\*m)                     | O(n\*m)              |
| **LRU Cache**            | Remove least recently used        | Use hashmap + list                | `cpp<br>class LRUCache {<br>int cap;<br>list\<pair\<int,int\>\> dq;<br>unordered_map\<int, list\<pair\<int,int\>\>::iterator\> mp;<br>public:<br>LRUCache(int capacity): cap(capacity) {}<br>int get(int key) {<br>  if (mp.find(key) == mp.end()) return -1;<br>  dq.splice(dq.begin(), dq, mp[key]);<br>  return mp[key]->second;<br>}<br>void put(int key, int value) {<br>  if (mp.find(key) != mp.end()) dq.erase(mp[key]);<br>  dq.push_front({key, value});<br>  mp[key] = dq.begin();<br>  if (dq.size() > cap) { mp.erase(dq.back().first); dq.pop_back(); }<br>}<br>};` | O(1)                        | O(capacity)          |

### Trees

| **Topic**                        | **Concept Summary**                      | **Key Formulas / Approaches**                             | **Code Example (C++)**                                                                                                                                                               | **Time Complexity** | **Space Complexity**   |
| -------------------------------- | ---------------------------------------- | --------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------- | ---------------------- |
| **Tree Basics**                  | A hierarchical data structure with nodes | Root, Child, Leaf, Depth, Height                          | `struct Node { int val; Node* left; Node* right; };`                                                                                                                                 | -                   | -                      |
| **DFS Traversals**               | Visit nodes Inorder, Preorder, Postorder | Inorder: LNR<br>Preorder: NLR<br>Postorder: LRN           | `void inorder(Node* r) { if (!r) return; inorder(r->left); cout << r->val; inorder(r->right); }`                                                                                     | O(n)                | O(h) (recursion stack) |
| **Level Order Traversal (BFS)**  | Visit nodes level by level               | Use `queue<Node*>`                                        | `queue<Node*> q; q.push(root); while (!q.empty()) { Node* n = q.front(); q.pop(); if(n->left) q.push(n->left); if(n->right) q.push(n->right); }`                                     | O(n)                | O(w) (width)           |
| **Height of Tree**               | Max depth from root to leaf              | `1 + max(height(left), height(right))`                    | `int height(Node* r) { if (!r) return 0; return 1 + max(height(r->left), height(r->right)); }`                                                                                       | O(n)                | O(h)                   |
| **Count Nodes, Leaf Nodes**      | Use recursion                            | Count: `1 + count(l) + count(r)`<br>Leaf: `if (!l && !r)` | `int count(Node* r) { if (!r) return 0; return 1 + count(r->left) + count(r->right); }`                                                                                              | O(n)                | O(h)                   |
| **Diameter of Binary Tree**      | Longest path between any two nodes       | `max(lHeight + rHeight)`                                  | `int diameter(Node* r, int& d) { if (!r) return 0; int l = diameter(r->left,d), r = diameter(r->right,d); d = max(d, l + r); return 1 + max(l, r); }`                                | O(n)                | O(h)                   |
| **Symmetric Tree**               | Left and right subtrees are mirror       | `isMirror(left, right)`                                   | \`bool isMirror(Node\* l, Node\* r) { if (!l                                                                                                                                         | O(n)                | O(h)                   |
| **Balanced Tree**                | Height difference ≤ 1 at each node       | Return height or -1 if unbalanced                         | \`int check(Node\* r) { if (!r) return 0; int l=check(r->left), rt=check(r->right); if (abs(l-rt)>1                                                                                  | O(n)                | O(h)                   |
| **Sorted Array to BST**          | Create height-balanced BST               | Mid is root, recurse on left and right halves             | `Node* build(vector<int>& a, int l, int r) { if (l > r) return nullptr; int m = (l+r)/2; Node* r = new Node(a[m]); r->left = build(a,l,m-1); r->right = build(a,m+1,r); return r; }` | O(n)                | O(log n)               |
| **Tree to Linked List**          | Flatten binary tree in-place to list     | Use postorder (right → left → root)                       | `void flatten(Node* r) { if (!r) return; flatten(r->right); flatten(r->left); r->right = prev; r->left = nullptr; prev = r; }` (with global `Node* prev = nullptr;`)                 | O(n)                | O(h)                   |
| **Lowest Common Ancestor (LCA)** | Common ancestor of two nodes             | If one node in left and other in right → return root      | `void flatten(Node* r) { <br>    if (!r) return; <br>    flatten(r->right); <br>    flatten(r->left); <br>    r->right = prev; <br>    r->left = nullptr; <br>    prev = r; <br>}`   | O(n)                | O(h)                   |

### Heaps

| **Topic**            | **Concept Summary**                                                                                                                                                                                             | **Key Formulas**                                                                        | **Code Example (Pseudocode)**                                                                                                                                                                                                                 | **Time Complexity**                                                | **Space Complexity**  |
| -------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------ | --------------------- |
| **Heap (Min/Max)**   | A **Heap** is a complete binary tree where parent nodes follow a specific order. <br> - **Min Heap**: Parent ≤ Children <br> - **Max Heap**: Parent ≥ Children <br> Useful in priority queues, scheduling, etc. | - Parent of i: `(i - 1) / 2` <br> - Left Child: `2*i + 1` <br> - Right Child: `2*i + 2` | **Insert in Min Heap**: <br>\`\`initialize minHeap\[] <br>insert(x): <br> append x to heap <br> bubble up to maintain min-heap property` <br><br>**Build Heap from Array**: <br>`buildHeap(arr): <br> for i = n/2 to 0: <br> heapify(i)\`\`\` | - Insert: O(log n) <br> - Delete: O(log n) <br> - Build Heap: O(n) | O(n) for storing heap |
| **Heap Sort**        | Sorts elements by inserting them in a heap and then extracting min/max repeatedly.                                                                                                                              | —                                                                                       | `heapSort(arr): <br>   buildHeap(arr) <br>   for i = n-1 to 1: <br>      swap(arr[0], arr[i]) <br>      heapify(0, i)`                                                                                                                        | O(n log n)                                                         | O(1) (in-place)       |
| **Priority Queue**   | Abstract data type similar to a queue, but each element has a priority.                                                                                                                                         | —                                                                                       | In C++: `priority_queue<int>` <br>Min Heap: `priority_queue<int, vector<int>, greater<int>>`                                                                                                                                                  | Insertion/Deletion: O(log n)                                       | O(n)                  |
| **Top K Elements**   | Use min heap to keep track of top K elements efficiently.                                                                                                                                                       | —                                                                                       | `for each x in arr: <br>   insert x in minHeap <br>   if heap.size() > k: <br>      remove smallest`                                                                                                                                          | O(n log k)                                                         | O(k)                  |
| **Median of Stream** | Use 2 Heaps: MaxHeap (left) and MinHeap (right) to maintain balance and get median in O(1).                                                                                                                     | —                                                                                       | `maxHeap` for left half <br> `minHeap` for right half <br> Balance both so that size difference ≤ 1                                                                                                                                           | Insertion: O(log n) <br> Median: O(1)                              | O(n)                  |

### Greedy

| **Topic**                                | **Concept Summary**                                                                                                                                                                                                          | **Key Idea**                                                                          | **Code Example (Pseudocode)**                                                                                                                                                                                                                                                                                                                                                    | **Time Complexity** | **Space Complexity** |
| ---------------------------------------- | ---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------- | -------------------- |
| **Greedy Algorithm**                     | Solves optimization problems by making the **locally optimal** choice at each step with the hope of reaching a **global optimum**. <br> Works only when **greedy choice property** and **optimal substructure** are present. | Choose the best **local option** at each step.                                        | —                                                                                                                                                                                                                                                                                                                                                                                | Depends on problem  | Depends on problem   |
| **Activity Selection**                   | Select maximum number of non-overlapping activities.                                                                                                                                                                         | Sort by end time, choose earliest finishing activity first.                           | `sort(activities by end time) <br> last_end = -1 <br> for activity in activities: <br> &nbsp;&nbsp; if activity.start ≥ last_end: <br> &nbsp;&nbsp;&nbsp;&nbsp; select <br> &nbsp;&nbsp;&nbsp;&nbsp; last_end = activity.end`                                                                                                                                                    | O(n log n)          | O(1)                 |
| **Fractional Knapsack**                  | Maximize total value when fractions of items can be taken.                                                                                                                                                                   | Take item with highest `value/weight` first.                                          | `sort(items by value/weight descending) <br> for item in items: <br> &nbsp;&nbsp; if capacity ≥ item.weight: <br> &nbsp;&nbsp;&nbsp;&nbsp; take full <br> &nbsp;&nbsp;&nbsp;&nbsp; capacity -= item.weight <br> &nbsp;&nbsp; else: <br> &nbsp;&nbsp;&nbsp;&nbsp; take (capacity / item.weight) * item.value <br> &nbsp;&nbsp;&nbsp;&nbsp; break`                                 | O(n log n)          | O(1)                 |
| **Huffman Coding**                       | Used in data compression.                                                                                                                                                                                                    | Merge two lowest freq nodes iteratively using a min-heap.                             | `create minHeap of (char, freq) <br> while heap.size > 1: <br> &nbsp;&nbsp; left = extractMin() <br> &nbsp;&nbsp; right = extractMin() <br> &nbsp;&nbsp; merged = newNode(left.freq + right.freq) <br> &nbsp;&nbsp; insert(merged)`                                                                                                                                              | O(n log n)          | O(n)                 |
| **Minimum Coins / Coin Change (Greedy)** | Find min number of coins to make a given amount.                                                                                                                                                                             | Use largest coin value first.                                                         | `sort(coins descending) <br> for coin in coins: <br> &nbsp;&nbsp; while amount ≥ coin: <br> &nbsp;&nbsp;&nbsp;&nbsp; take coin <br> &nbsp;&nbsp;&nbsp;&nbsp; amount -= coin`                                                                                                                                                                                                     | O(n)                | O(1)                 |
| **Job Sequencing**                       | Schedule jobs to maximize profit, where each job has a deadline.                                                                                                                                                             | Sort jobs by profit descending, assign to latest possible free slot.                  | `sort(jobs by profit descending) <br> slots = array of size maxDeadline, filled false <br> for job in jobs: <br> &nbsp;&nbsp; for j = job.deadline downto 1: <br> &nbsp;&nbsp;&nbsp;&nbsp; if slots[j] is false: <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; assign job <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; slots[j] = true <br> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break` | O(n log n)          | O(n)                 |
| **Gas Station / Jump Game**              | Check if it's possible to reach the end of array with energy or jumps.                                                                                                                                                       | Greedily jump to the farthest reachable point.                                        | `maxReach = 0 <br> for i in 0 to n-1: <br> &nbsp;&nbsp; if i > maxReach: return false <br> &nbsp;&nbsp; maxReach = max(maxReach, i + nums[i]) <br> return true`                                                                                                                                                                                                                  | O(n)                | O(1)                 |
| **Greedy vs DP**                         | Greedy is faster but may not always give optimal solution (DP is safer).                                                                                                                                                     | Only use greedy when both **Greedy Choice Property** & **Optimal Substructure** hold. | —                                                                                                                                                                                                                                                                                                                                                                                | —                   | —                    |

### Recursion

| **Topic**                       | **Concept Summary**                                                    | **Key Idea**                   | **Code Example (Pseudocode)**                                                                                                                                                                      | **Time Complexity**    | **Space Complexity**                   |
| ------------------------------- | ---------------------------------------------------------------------- | ------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------- | -------------------------------------- |
| **Recursion**                   | Function calls itself to break down problems into smaller subproblems. | Base case + Recursive case     | `function f(n):<br>  if n == 0:<br>  return 1<br>  return n * f(n - 1)`                                                                                                                            | Depends on the problem | Depends on call stack (O(n) typically) |
| **Factorial**                   | Multiply n \* (n-1)! recursively                                       | Base case: n = 0 or 1          | `function fact(n):<br> if n ≤ 1:<br>  return 1<br> return n * fact(n - 1)`                                                                                                                         | O(n)                   | O(n)                                   |
| **Fibonacci (simple)**          | f(n) = f(n-1) + f(n-2)                                                 | Very redundant (use DP)        | `function fib(n):<br> if n ≤ 1:<br>  return n<br> return fib(n - 1) + fib(n - 2)`                                                                                                                  | O(2^n)                 | O(n)                                   |
| **Binary Search**               | Recursive divide and conquer                                           | Search left or right half      | `function bs(arr, l, r, x):<br> if l > r: return -1<br> mid = (l + r) / 2<br> if arr[mid] == x: return mid<br> if x < arr[mid]: return bs(arr, l, mid-1, x)<br> else: return bs(arr, mid+1, r, x)` | O(log n)               | O(log n)                               |
| **Power (a^b)**                 | Divide exponent by 2 each step                                         | fastPow(a, b)                  | `function power(a, b):<br> if b == 0: return 1<br> half = power(a, b//2)<br> if b % 2 == 0: return half * half<br> else: return a * half * half`                                                   | O(log b)               | O(log b)                               |
| **Permutations / Combinations** | Build choices recursively                                              | Fix an element, recur for rest | `function permute(str, l, r):<br> if l == r: print(str)<br> else:<br>  for i from l to r:<br>   swap(str[l], str[i])<br>   permute(str, l+1, r)<br>   swap(str[l], str[i])`                        | O(n!)                  | O(n)                                   |
| **Subset Generation**           | Include/exclude current element                                        | Power set logic                | `function subset(i, path):<br> if i == n: print(path)<br> subset(i+1, path) // exclude<br> subset(i+1, path + arr[i]) // include`                                                                  | O(2^n)                 | O(n)                                   |

### Backtracking

| **Topic**                       | **Concept Summary**                                                               | **Key Idea**                                                               | **Code Example (Pseudocode)**                                                                                                                                                                                                                                         | **Time Complexity**                                        | **Space Complexity**               |
| ------------------------------- | --------------------------------------------------------------------------------- | -------------------------------------------------------------------------- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ---------------------------------------------------------- | ---------------------------------- |
| **Backtracking**                | Tries all possible solutions and **backs out** when a solution path doesn't work. | Build solution step-by-step, **recurse**, and undo (backtrack) if invalid. | `function solve(state):<br> if goal(state):<br>  print(state)<br>  return<br> for option in options(state):<br>  if valid(option):<br>   make(option)<br>   solve(state)<br>   undo(option)`                                                                          | Depends on branching factor and depth, usually exponential | Depends on recursion depth (stack) |
| **N-Queens**                    | Place N queens on NxN board so no two queens attack each other.                   | Place queen row-by-row, backtrack on conflict.                             | `function solve(row):<br> if row == N: print board<br> for col in 0 to N-1:<br>  if isSafe(row, col):<br>   placeQueen(row, col)<br>   solve(row + 1)<br>   removeQueen(row, col)`                                                                                    | O(N!)                                                      | O(N²) (board)                      |
| **Sudoku Solver**               | Fill 9x9 grid so each row/col/box has 1-9 without repeat.                         | Try 1-9 in empty cells, backtrack if invalid.                              | `function solve():<br> for i in 0..8:<br>  for j in 0..8:<br>   if board[i][j] == empty:<br>    for d in 1..9:<br>     if isValid(i,j,d):<br>      board[i][j] = d<br>      if solve(): return true<br>      board[i][j] = empty<br>    return false<br> return true` | O(9^m) (m = number of empty cells)                         | O(1) (in-place)                    |
| **Subset / Combination Sum**    | Generate subsets or combinations that sum to target.                              | Explore both include/exclude options.                                      | `function findSubset(i, target):<br> if target == 0: print path<br> if i == n or target < 0: return<br> // include<br> path.push(arr[i])<br> findSubset(i, target - arr[i])<br> path.pop()<br> // exclude<br> findSubset(i+1, target)`                                | O(2^n)                                                     | O(n)                               |
| **Rat in a Maze**               | Move in 4 directions to reach goal in maze.                                       | Explore all paths using backtracking.                                      | `function solve(x, y):<br> if (x, y) is destination:<br>  print path<br>  return<br> for direction in [R, D, L, U]:<br>  if isValid(x+dx, y+dy):<br>   mark visited<br>   solve(x+dx, y+dy)<br>   unmark visited`                                                     | O(4^n)                                                     | O(n)                               |
| **Word Search in Grid**         | Find word path in 2D grid of characters.                                          | DFS + backtracking, mark visited.                                          | `function search(i, j, k):<br> if k == len(word): return true<br> if outOfBounds or visited or grid[i][j] ≠ word[k]: return false<br> mark visited<br> for dir in [R, L, U, D]:<br>  if search(i+dx, j+dy, k+1): return true<br> unmark visited<br> return false`     | O(m \* n \* 4^L) (L = length of word)                      | O(L) (recursion stack)             |
| **Palindrome Partitioning**     | Partition string such that each substring is a palindrome.                        | Backtrack on each valid palindrome cut.                                    | `function partition(start):<br> if start == len(s): print currentPartition<br> for end in start to len(s):<br>  if isPalindrome(s[start:end+1]):<br>   currentPartition.push(s[start:end+1])<br>   partition(end+1)<br>   currentPartition.pop()`                     | O(2^n)                                                     | O(n)                               |
| **Permutations / Combinations** | Generate all permutations or k-combinations.                                      | Swap or build step-by-step and undo.                                       | `function permute(i):<br> if i == len(arr): print(arr)<br> for j in i to len(arr)-1:<br>  swap(arr[i], arr[j])<br>  permute(i+1)<br>  swap(arr[i], arr[j])`                                                                                                           | O(n!)                                                      | O(n)                               |

### Dynamic Programming

| **Topic**           | **Concept Summary**                                                                                                                          | **Key Formulas / Patterns**                                                                                                                | **Code Example**                                                                                                                                                                                                                                                                                                                | **Time Complexity**                   | **Space Complexity**           |
| ------------------- | -------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------- | ------------------------------ |
| Dynamic Programming | DP is a method for solving complex problems by breaking them down into simpler subproblems and storing their results to avoid recomputation. | 1. **Memoization** (Top-Down)<br>2. **Tabulation** (Bottom-Up)<br>3. Optimal Substructure + Overlapping Subproblems<br>4. State Definition | **Fibonacci (Memoization)**:<br><br>`int fib(int n, vector<int>& dp) {`<br>  `if(n <= 1) return n;`<br>  `if(dp[n] != -1) return dp[n];`<br>  `return dp[n] = fib(n-1, dp) + fib(n-2, dp);`<br>`}`<br><br>**Fibonacci (Tabulation)**:<br>`dp[0] = 0; dp[1] = 1;`<br>`for(int i=2; i<=n; i++)`<br>  `dp[i] = dp[i-1] + dp[i-2];` | Memoization: O(n)<br>Tabulation: O(n) | O(n), can be optimized to O(1) |

### Graph

| **Topic** | **Concept Summary**                                                                                            | **Key Formulas / Patterns**                                                                                                                                  | **Code Example**                                                                                                                                        | **Time Complexity**                       | **Space Complexity**                      |
| --------- | -------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------ | ------------------------------------------------------------------------------------------------------------------------------------------------------- | ----------------------------------------- | ----------------------------------------- |
| Graph     | A graph is a collection of nodes (vertices) and edges. Graphs can be directed/undirected, weighted/unweighted. | **Types:**<br>• Directed / Undirected<br>• Weighted / Unweighted<br>• Cyclic / Acyclic<br><br>**Representations:**<br>• Adjacency List<br>• Adjacency Matrix | **Adjacency List:**<br>`vector<vector<int>> adj(n);`<br>`adj[u].push_back(v);`<br><br>**Adjacency Matrix:**<br>`int graph[n][n];`<br>`graph[u][v] = 1;` | Adjacency List: O(V + E)<br>Matrix: O(V²) | Adjacency List: O(V + E)<br>Matrix: O(V²) |

| **Algorithm**         | **Concept Summary**                               | **Code Example (Adj. List)**                                                                                                                                                                                                                                                        | **Time Complexity** | **Space Complexity** |
| --------------------- | ------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------- | -------------------- |
| **BFS (Level Order)** | Traverses graph layer by layer (uses queue)       | `cpp<br>queue<int> q;<br>vector<bool> visited(n, false);<br>q.push(0); visited[0] = true;<br>while (!q.empty()) {<br>  int node = q.front(); q.pop();<br>  for (int nbr : adj[node]) {<br>    if (!visited[nbr]) {<br>      q.push(nbr); visited[nbr] = true;<br>    }<br>  }<br>}` | O(V + E)            | O(V)                 |
| **DFS**               | Traverses graph depth-wise (uses recursion/stack) | `cpp<br>void dfs(int node, vector<bool>& vis, vector<vector<int>>& adj) {<br>  vis[node] = true;<br>  for (int nbr : adj[node]) {<br>    if (!vis[nbr]) dfs(nbr, vis, adj);<br>  }<br>}`                                                                                            | O(V + E)            | O(V)                 |

| **Topic**                   | **Concept Summary**                                                               | **Key Formulas / Approaches**                           | **Code Example (Pseudocode)**                                                                                                                                                                                           | **Time Complexity** | **Space Complexity** |
| --------------------------- | --------------------------------------------------------------------------------- | ------------------------------------------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------- | -------------------- |
| Shortest Path (Unweighted)  | Use BFS to find the shortest path in unweighted graphs                            | BFS from source, store distance                         | `dist[src] = 0 <br> queue.push(src) <br> while queue: <br> u = queue.pop() <br> for v in adj[u]: <br>  if dist[v] > dist[u]+1:`<br>   `dist[v] = dist[u] + 1`<br>   `queue.push(v)`                                     | O(V + E)            | O(V)                 |
| Shortest Path (Weighted)    | Dijkstra’s algorithm finds shortest distance from a source in weighted graph      | Min-Heap + Relaxation                                   | `dist[src] = 0 <br> minHeap.push((0, src)) <br> while heap: <br> d, u = heap.pop() <br> for v, w in adj[u]: <br>  if dist[v] > d+w:`<br>   `dist[v] = d+w <br>   heap.push((dist[v], v))`                               | O((V + E) log V)    | O(V + E)             |
| All-Pairs Shortest Path     | Floyd-Warshall for all-pairs shortest distances                                   | `dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])`         | `for k in 0..n:<br> for i in 0..n:<br>  for j in 0..n:<br>   dp[i][j] = min(dp[i][j], dp[i][k] + dp[k][j])`                                                                                                             | O(V³)               | O(V²)                |
| MST (Minimum Spanning Tree) | Prim’s or Kruskal’s to find tree of min total edge weight that spans all vertices | Kruskal: sort edges + DSU <br> Prim: heap + visited set | Kruskal: `sort edges <br> for edge in edges:<br> if find(u) ≠ find(v):<br>  union(u,v) <br>  add edge`<br>Prim: `minHeap, visited`                                                                                      | O(E log V)          | O(V + E)             |
| Topological Sort            | Linear ordering of nodes in a DAG                                                 | DFS + stack or Kahn's Algo with in-degree               | DFS: `for u:<br> if not visited:<br>  dfs(u)<br> stack.push(u)`<br>Kahn’s: `queue with 0 in-degree <br> pop → reduce neighbor's in-degree`                                                                              | O(V + E)            | O(V)                 |
| Cycle Detection             | Detect if a graph has a cycle (directed or undirected)                            | DFS with recursion stack or Union-Find                  | DFS: `if visiting and visited again → cycle`<br> Union-Find: `if find(u) == find(v) → cycle`                                                                                                                            | O(V + E)            | O(V) or O(α(N))      |
| Bipartite Check             | Check if graph is 2-colorable (Bipartite)                                         | BFS/DFS with 2 colors                                   | `color[src] = 0 <br> queue.push(src) <br> while queue:<br> u = queue.pop()<br> for v in adj[u]:<br>  if color[v] == -1:<br>   color[v] = 1 - color[u]<br>   queue.push(v)<br>  elif color[v] == color[u]: return false` | O(V + E)            | O(V)                 |
