# Arrays and Vectors in C++

---

## 1. Arrays

### 1.1 Static Arrays

* Fixed size, declared at compile time.

```cpp
#include <iostream>
using namespace std;

int main() {
    int numbers[5] = {1, 2, 3, 4, 5};

    // Access elements
    cout << numbers[0]; // 1
    cout << numbers[2]; // 3

    // Replace element
    numbers[2] = 35;    // Third element changed from 3 to 35

    // Calculate length
    int length = sizeof(numbers) / sizeof(numbers[0]);

    // Iterate through array
    for(int i = 0; i < length; i++) {
        cout << numbers[i] << " "; // Output: 1 2 35 4 5
    }

    return 0;
}
```

---

### 1.2 Removing an Element from Static Array

* Arrays have **fixed size**, so "removing" an element requires **shifting elements**.

```cpp
#include <iostream>
using namespace std;

int main() {
    int numbers[5] = {10, 20, 30, 40, 50};
    int size = 5; // Logical size of array

    // Remove element at index 2 (30)
    for(int i = 2; i < size - 1; i++) {
        numbers[i] = numbers[i + 1]; // Shift elements left
    }
    size--; // Decrease logical size

    // Print array after removal
    for(int i = 0; i < size; i++) {
        cout << numbers[i] << " "; // Output: 10 20 40 50
    }

    return 0;
}
```

---

## 2. Dynamic Arrays – Vectors

* **Vectors** are dynamic arrays in C++.
* Automatically resizeable, part of STL.

### 2.1 Include Vector

```cpp
#include <vector>
```

### 2.2 Declaration and Initialization

```cpp
vector<int> numbers;               // Empty vector
vector<int> numbers = {1, 2, 3, 4, 5};  // Initialize with values
vector<long> numbers(A.size());    // Size same as A
vector<long> numbers(A.size(), 0); // Initialize with 0s
```

### 2.3 Adding Elements

```cpp
numbers[0] = 4;       // Modify first element
numbers.push_back(6);  // Add element at the end
```

### 2.4 Removing Elements

```cpp
numbers.erase(numbers.begin() + i); // Remove ith element
numbers.pop_back();                 // Remove last element
numbers.clear();                    // Remove all elements
```

### 2.5 Accessing Elements

```cpp
int first = numbers[0];
int second = numbers.at(1); // safer access
```

### 2.6 Find Length

```cpp
int N = numbers.size();
```

### 2.7 Iterating Through Vector

```cpp
// Using index
for(int i = 0; i < N; i++) {
    cout << numbers[i] << " ";
}

// Using range-based for loop
for(int num : numbers) {
    cout << num << " ";
}
```

### 2.8 Sorting a Vector

```cpp
#include <algorithm>

// Ascending order
sort(numbers.begin(), numbers.end());  

// Descending order
sort(numbers.begin(), numbers.end(), greater<int>());
```

---

# Introduction to Arrays in C++

---

## 1. Reverse an Integer Array

**Approach 1: Addition/Subtraction Method**

```cpp
while(i < j){
    A[i] = A[i] + A[j];
    A[j] = A[i] - A[j];
    A[i] = A[i] - A[j];
    i++;
    j--;
}
```

**Approach 2: Swap Method**

```cpp
while(i < j){
    int temp = A[i];
    A[i] = A[j];
    A[j] = temp;
    i++;
    j--;
}
```

---

## 2. Rotate Array

**Right Rotation using Reverse Method**

```cpp
Reverse(0, N-1);
Reverse(0, k-1);
Reverse(k, N-1);
```

---

## 3. Problem Examples

### Q1. Good Pair

**Problem:**
Given an array `A` and integer `B`, a pair `(i, j)` is "good" if `i != j` and `A[i] + A[j] == B`. Check if such a pair exists.

**Code:**

```cpp
int Solution::solve(vector<int> &A, int B) {
    int N = A.size();
    for (int i = 0; i < N; i++) {
        for (int j = 0; j < N; j++) {
            if ((A[i] + A[j] == B) && (i != j))
                return 1;
        }
    }
    return 0;
}
```

---

### Q2. Reverse in Range

**Problem:**
Reverse array elements in the inclusive range `[B, C]`.

**Code:**

```cpp
vector<int> Solution::solve(vector<int> &A, int B, int C) {
    int i = B, j = C;
    while(i < j){
        A[i] = A[i] + A[j];
        A[j] = A[i] - A[j];
        A[i] = A[i] - A[j];
        i++; j--;
    }
    return A;
}
```

---

### Q3. Array Rotation

**Problem:**
Rotate array `A` to the right by `B` positions.

**Code:**

```cpp
vector<int> reverse(vector<int> A, int i, int j){
    while(i < j){
        int temp = A[i];
        A[i] = A[j];
        A[j] = temp;
        i++; j--;
    }
    return A;
}

vector<int> Solution::solve(vector<int> &A, int B) {
    int N = A.size();
    B = B % N;
    A = reverse(A, 0, N-1);
    A = reverse(A, 0, B-1);
    A = reverse(A, B, N-1);
    return A;
}
```

---

### Q4. Max and Min Sum

**Problem:**
Return sum of maximum and minimum elements of array `A`.

**Code:**

```cpp
int Solution::solve(vector<int> &A) {
    int minVal = INT_MAX;
    int maxVal = INT_MIN;
    for(int i = 0; i < A.size(); i++){
        if(A[i] < minVal) minVal = A[i];
        if(A[i] > maxVal) maxVal = A[i];
    }
    return minVal + maxVal;
}
```

---

### Q5. Linear Search - Multiple Occurrences

**Problem:**
Count occurrences of integer `B` in array `A`.

**Code:**

```cpp
int Solution::solve(vector<int> &A, int B) {
    int count = 0;
    for(int i = 0; i < A.size(); i++){
        if(A[i] == B) count++;
    }
    return count;
}
```

---

### Q6. Time to Equality

**Problem:**
Find minimum seconds to make all array elements equal by increasing any element by 1 in 1 second.

**Code:**

```cpp
int Solution::solve(vector<int> &A) {
    int maxVal = INT_MIN, ans = 0;
    for(int i = 0; i < A.size(); i++)
        if(A[i] > maxVal) maxVal = A[i];

    for(int i = 0; i < A.size(); i++)
        ans += maxVal - A[i];

    return ans;
}
```

---

### Q7. Count of Elements Less Than Max

**Problem:**
Count elements that have at least 1 element greater than themselves.

**Code:**

```cpp
int Solution::solve(vector<int> &A) {
    int maxVal = INT_MIN, count = 0;
    for(int i = 0; i < A.size(); i++)
        if(A[i] > maxVal) maxVal = A[i];

    for(int i = 0; i < A.size(); i++)
        if(A[i] < maxVal) count++;

    return count;
}
```

---

### Q8. Second Largest Element

**Problem:**
Find the second largest element in array `A` or return -1 if not exists.

**Code:**

```cpp
int Solution::solve(vector<int> &A) {
    int maxVal = INT_MIN, secondMax = INT_MIN;
    for(int i = 0; i < A.size(); i++)
        if(A[i] > maxVal) maxVal = A[i];

    for(int i = 0; i < A.size(); i++)
        if(A[i] < maxVal && A[i] > secondMax) secondMax = A[i];

    return (secondMax == INT_MIN) ? -1 : secondMax;
}
```

---

# Prefix Sum in Arrays

---

## 1. How to Create Prefix Sum of an Array

```cpp
vector<int> P(A.size(), 0);
P[0] = A[0];
for (int i = 1; i < A.size(); ++i) {
    P[i] = P[i-1] + A[i];
}
```

* `P[i]` stores the sum of elements from index `0` to `i`.

---

## 2. Range Sum Query using Prefix Sum

```cpp
for (int i = 0; i < B.size(); i++) {
    int L = B[i][0];
    int R = B[i][1];
    if(L == 0){
        sum_array[i] = prefixSum[R];
    } else {
        sum_array[i] = prefixSum[R] - prefixSum[L-1];
    }
}
```

* Efficiently answers sum queries in **O(1)** per query.

---

## 3. Even/Odd Indexed Prefix Sum

```cpp
// Even index sum
even_P[0] = A[0];
for(int i = 1; i < N; i++){
    if(i % 2 == 0) even_P[i] = even_P[i-1] + A[i];
    else even_P[i] = even_P[i-1];
}

// Odd index sum
odd_P[0] = 0;
for(int i = 1; i < N; i++){
    if(i % 2 == 1) odd_P[i] = odd_P[i-1] + A[i];
    else odd_P[i] = odd_P[i-1];
}
```

---

## 4. Special Index Problem

* Remove element `i`, then sum of even and odd indices becomes equal.

```cpp
if(i == 0) {
    even_sum = odd_P[N-1] - odd_P[i];
    odd_sum = even_P[N-1] - even_P[i];
} else {
    even_sum = even_P[i-1] + (odd_P[N-1] - odd_P[i]);
    odd_sum = odd_P[i-1] + (even_P[N-1] - even_P[i]);
}
if(even_sum == odd_sum)
    return i;
```

---

## 5. Problems and Solutions

### Q1. Range Sum Query

**Problem:**
Given array `A` and queries `[L, R]`, return sum of elements from L to R.

```cpp
vector<long long> Solution::rangeSum(vector<int> &A, vector<vector<int>> &B) {
    vector<long> prefixSum(A.size());
    prefixSum[0] = A[0];
    for (long i = 1; i < A.size(); i++)
        prefixSum[i] = prefixSum[i-1] + A[i];

    vector<long long> sum_array(B.size());
    for (int i = 0; i < B.size(); i++) {
        int L = B[i][0], R = B[i][1];
        sum_array[i] = (L == 0) ? prefixSum[R] : prefixSum[R] - prefixSum[L-1];
    }
    return sum_array;
}
```

---

### Q2. Special Index

**Problem:**
Count indices such that removing the element makes even-indexed sum = odd-indexed sum.

```cpp
vector<int> evenPrefixArray(const vector<int> &A);
vector<int> oddPrefixArray(const vector<int> &A);

int Solution::solve(vector<int> &A) {
    vector<int> evenSum = evenPrefixArray(A);
    vector<int> oddSum = oddPrefixArray(A);
    int count = 0;
    int n = A.size();

    for (int i = 0; i < n; ++i) {
        int se, so;
        if (i == 0) {
            se = oddSum[n-1];
            so = evenSum[n-1];
        } else {
            se = evenSum[i-1] + (oddSum[n-1] - oddSum[i]);
            so = oddSum[i-1] + (evenSum[n-1] - evenSum[i]);
        }
        if(se == so) count++;
    }
    return count;
}
```

---

### Q3. In-Place Prefix Sum

**Problem:**
Construct prefix sum in the same array `A`.

```cpp
vector<int> Solution::solve(vector<int> &A) {
    for(int i = 1; i < A.size(); i++)
        A[i] = A[i-1] + A[i];
    return A;
}
```

* **Input:** `[1, 2, 3, 4, 5]`
* **Output:** `[1, 3, 6, 10, 15]`

---

### Q4. Equilibrium Index

**Problem:**
Find index `i` such that sum of elements before `i` = sum after `i`.

**Code (Two approaches)**

**Approach 1: Using Prefix Sum**

```cpp
int Solution::solve(vector<int> &A) {
    int n = A.size();
    vector<int> prefixSum(n);
    prefixSum[0] = A[0];
    for(int i = 1; i < n; i++)
        prefixSum[i] = prefixSum[i-1] + A[i];

    for(int i = 0; i < n; i++){
        int leftSum = (i == 0) ? 0 : prefixSum[i-1];
        int rightSum = prefixSum[n-1] - prefixSum[i];
        if(leftSum == rightSum) return i;
    }
    return -1;
}
```

**Approach 2: Using Two Variables**

```cpp
int Solution::solve(vector<int> &A) {
    int total_sum = 0, left_sum = 0;
    for(int x : A) total_sum += x;

    for(int i = 0; i < A.size(); i++){
        total_sum -= A[i];
        if(left_sum == total_sum) return i;
        left_sum += A[i];
    }
    return -1;
}
```

---


# **Carry Forward & Subarrays in C++**

---

## **1. Carry Forward Technique**

The **Carry Forward** technique is often used to count patterns or subsequences in a string or array. The idea is to **traverse in reverse** and "carry forward" certain counts.

### **Example: Count "AG" subsequences**

```cpp
int cnt = 0; // Count of 'G' seen so far
int ans = 0;

for (int i = A.size() - 1; i >= 0; i--) {
    if (A[i] == 'G') cnt++;    // Carry forward G's
    if (A[i] == 'A') ans += cnt; // Add number of G's seen after A
}
```

* **Time Complexity:** O(N)
* **Space Complexity:** O(1)
* **Explanation:**
  For each 'A', the number of 'G's after it contributes to the number of "AG" subsequences.

---

## **2. Subarrays**

A **subarray** is a contiguous portion of an array.

### **2.1 Print a Subarray**

```cpp
for(int i = si; i <= ei; i++){
    cout << A[i] << " ";
}
```

### **2.2 Print All Subarrays**

```cpp
for(int L = 0; L < N; L++){
    for(int R = L; R < N; R++){
        for(int k = L; k <= R; k++){
            cout << A[k] << " ";
        }
        cout << endl;
    }
}
```

### **2.3 Min & Max Subarray**

* Find smallest subarray containing **min** and **max**:

```cpp
int minVal = *min_element(A.begin(), A.end());
int maxVal = *max_element(A.begin(), A.end());

int l_min = -1, l_max = -1;
int ans = A.size();

for (int i = 0; i < A.size(); i++){
    if (A[i] == minVal){
        l_min = i;
        if(l_max != -1) ans = min(ans, i-l_max+1);
    }
    if (A[i] == maxVal){
        l_max = i;
        if(l_min != -1) ans = min(ans, i-l_min+1);
    }
}
```

---

## **3. Problem Solving Patterns**

### **Q1. Closest MinMax Subarray**

* Find **smallest subarray** containing both **min** and **max**.
* Use the last seen positions of min and max while traversing.

---

### **Q2. Subarray in Given Range**

```cpp
vector<int> getSubarray(const vector<int> &A, int B, int C){
    vector<int> ans;
    for(int i = B; i <= C; i++){
        ans.push_back(A[i]);
    }
    return ans;
}
```

* Simple O(C-B+1) solution
* Useful for extracting portions of an array.

---

### **Q3. Generate All Subarrays**

* Nested loops to generate every contiguous subarray:

```cpp
vector<vector<int>> allSubarrays(const vector<int> &A){
    vector<vector<int>> result;
    for(int st=0; st<A.size(); st++){
        for(int end=st; end<A.size(); end++){
            vector<int> subarray;
            for(int i=st; i<=end; i++){
                subarray.push_back(A[i]);
            }
            result.push_back(subarray);
        }
    }
    return result;
}
```

* **Time Complexity:** O(N^3)
* **Space Complexity:** O(N^2)

---

### **Q4. Special Subsequences "AG"**

* Count all subsequences **"AG"** using carry forward:

```cpp
int cnt = 0, ans = 0;
const int MOD = 1e9 + 7;
for(int i = A.size() - 1; i >= 0; i--){
    if(A[i] == 'G') cnt++;
    if(A[i] == 'A') ans = (ans + cnt) % MOD;
}
```

* Handles **large numbers** with modulo 10^9 + 7.

---

### **Q5. Pick from Both Sides (Maximum Sum)**

* Take **B elements** from either end to maximize sum:

```cpp
int sum = 0, maxSum = 0;
for(int i=0;i<B;i++) sum += A[i];
maxSum = sum;

for(int i=1;i<=B;i++){
    sum -= A[B-i];
    sum += A[n-i];
    maxSum = max(maxSum, sum);
}
```

* Sliding window on **ends** technique.
* Time Complexity: O(B)

---

### **Q6. Leaders in Array**

* An element is a leader if **greater than all elements to its right**.

**Carry Forward Technique:**

```cpp
int maxFromRight = A[n-1];
vector<int> leaders = {maxFromRight};

for(int i=n-2;i>=0;i--){
    if(A[i] > maxFromRight){
        maxFromRight = A[i];
        leaders.push_back(A[i]);
    }
}
reverse(leaders.begin(), leaders.end());
```

**Suffix Maximum Technique:**

```cpp
vector<int> suffix_max(n);
suffix_max[n-1] = A[n-1];
for(int i=n-2;i>=0;i--){
    suffix_max[i] = max(A[i], suffix_max[i+1]);
}
```

* Compare each element with **suffix_max** to find leaders.

---

### **Q7. Count Unique Subarrays**

* Use **sliding window** and **hash map/set**:

```cpp
int left=0, right=0;
unordered_map<int,int> freq;
long long ans = 0;
while(right<n){
    while(freq[A[right]]) freq[A[left]]--, left++;
    freq[A[right]]++;
    ans += (right-left+1);
    right++;
}
ans %= 1e9+7;
```

* Efficient **O(N)** solution for large arrays.

---

### **Q8. Best Time to Buy & Sell Stocks I**

* Maximum profit with **one transaction**:

```cpp
int min_price = A[0], max_profit = 0;
for(int i=1;i<A.size();i++){
    min_price = min(min_price, A[i]);
    max_profit = max(max_profit, A[i]-min_price);
}
```

* Time Complexity: O(N)
* Space Complexity: O(1)

---

## **4. Key Takeaways**

1. **Carry Forward** is efficient for counting subsequences.
2. **Sliding window** is powerful for subarray sum or uniqueness problems.
3. **Suffix arrays / prefix arrays** simplify maximum/minimum and sum queries.
4. **Nested loops** for generating all subarrays are only feasible for small arrays.
5. **Modulo arithmetic** is essential for large counts.
6. **Two pointer approach** avoids O(N^2) solutions in many problems.

---

# **Sliding Window & Contribution Technique – Advanced Guide**

---

## **1. Total Sum of All Subarrays**

### **Brute Force**

```cpp
for (int L = 0; L < N; ++L)
    for (int R = L; R < N; ++R)
        for (int k = L; k <= R; ++k)
            totalSum += A[k];
```

* **Time Complexity:** O(N³) → Too slow for large arrays.
* **Idea:** Generate all possible subarrays and sum them individually.

### **Prefix Sum**

```cpp
prefixSum[0] = A[0];
for (int i = 1; i < N; i++) prefixSum[i] = prefixSum[i-1] + A[i];

for (int L = 0; L < N; ++L)
    for (int R = L; R < N; ++R)
        totalSum += prefixSum[R] - (L > 0 ? prefixSum[L-1] : 0);
```

* **Time Complexity:** O(N²)
* **Better than brute force** because summing subarrays is O(1) instead of O(N).

### **Contribution Technique (Optimized)**

```cpp
long long totalSum = 0;
for (int i = 0; i < N; i++) {
    totalSum += A[i] * (i + 1) * (N - i);
}
```

* **Time Complexity:** O(N)
* **Idea:** Each element A[i] appears in `(i+1) * (N-i)` subarrays.
* **Highly efficient** for large N.

---

## **2. Sliding Window Technique**

### **Fixed Window Size K**

* **Problem:** Find the maximum sum of subarray of size K.

```cpp
int sum = 0;
for (int i = 0; i < K; i++) sum += A[i];
int ans = sum;

for (int R = K; R < N; R++) {
    int L = R - K;
    sum += A[R] - A[L];
    ans = max(ans, sum);
}
```

* **Time Complexity:** O(N)
* **Idea:** Add next element, remove first element in the window.

### **Shrinking Sliding Window**

* **Problem:** Max subarray sum ≤ B

```cpp
int max_sum = 0, current_sum = 0, L = 0;
for (int R = 0; R < N; R++) {
    current_sum += A[R];
    while (current_sum > B && L <= R) current_sum -= A[L++];
    max_sum = max(max_sum, current_sum);
}
```

* **Time Complexity:** O(N)
* **Idea:** Expand window to right, shrink from left if sum exceeds limit.

---

## **3. Good Applications**

### **Q1: Maximum Subarray ≤ B**

* Brute Force: O(N²) – check all subarrays.
* Sliding Window: O(N) – dynamically maintain window sum ≤ B.

### **Q2: Sum of All Subarrays**

* Use **Contribution Technique**:

```cpp
long sum = 0;
for (int i = 0; i < N; i++)
    sum += A[i] * (i + 1) * (N - i);
```

### **Q3: Subarray of Fixed Length with Given Sum**

```cpp
int sum = 0, li = 0;
for(int i=0;i<B;i++) sum += A[i];
if(sum == C) return 1;

for(int r=B; r<N; r++){
    li = r-B;
    sum += A[r] - A[li];
    if(sum == C) return 1;
}
return 0;
```

* **Time Complexity:** O(N)
* **Idea:** Sliding window of size B.

### **Q4: Counting Subarrays with Conditions (Good Subarrays)**

* Nested loops acceptable for smaller N (≤ 5000)
* For each subarray, check length and sum conditions.

---

## **4. Minimum Swaps to Bring Numbers Together**

```cpp
int count = number of elements ≤ B;
int bad = count of elements > B in first window of size count;
min_swaps = bad;

for r = count; r<N; r++:
    if A[r] > B: bad++
    if A[r-count] > B: bad--
    min_swaps = min(min_swaps, bad)
```

* **Idea:** Sliding window counts “bad” elements in a window of size equal to count of “good” elements.
* **Time Complexity:** O(N)

---

## **5. Subarray with Minimum Average**

* Sliding window of size B

```cpp
sum = sum of first B elements
min_avg = sum / B
index = 0

for r = B to N-1:
    sum += A[r] - A[r-B]
    avg = sum / B
    if avg < min_avg: min_avg = avg, index = r-B+1
```

* **Time Complexity:** O(N)
* **Idea:** Maintain window sum, compute average on the fly.

---

## **6. Key Takeaways**

1. **Brute Force:** Good for understanding, slow for large inputs.
2. **Prefix Sum:** Speeds up repeated sum queries.
3. **Contribution Technique:** Calculates total sum efficiently in O(N).
4. **Sliding Window:** Best for contiguous subarray problems, both fixed size and variable size.
5. **Shrinking Window:** Useful for constraints like sum ≤ B.
6. Always **consider data type** (`long` or `long long`) to avoid overflow.

---

# **2D Matrices – Complete Guide**

---

## **1. Basic Traversals**

### **Row-wise Traversal**

```cpp
for (int i = 0; i < N; i++) {
    int sum = 0;
    for (int j = 0; j < M; j++)
        sum += A[i][j];
    cout << "Sum of row " << i << ": " << sum << endl;
}
```

### **Column-wise Traversal**

```cpp
for (int j = 0; j < M; j++) {
    int sum = 0;
    for (int i = 0; i < N; i++)
        sum += A[i][j];
    cout << "Sum of column " << j << ": " << sum << endl;
}
```

### **Principal Diagonal**

```cpp
for (int i = 0; i < N; i++)
    cout << A[i][i] << " ";
```

### **Anti-Diagonal**

```cpp
for (int i = 0; i < N; i++)
    cout << A[i][N-1-i] << " ";
```

---

## **2. Advanced Traversals**

### **Print All Anti-Diagonals**

```cpp
void printAntiDiagonals(vector<vector<int>>& matrix) {
    int n = matrix.size(), m = matrix[0].size();
    // From first row
    for (int C = 0; C < m; ++C) {
        int i = 0, j = C;
        while(i < n && j >= 0) { cout << matrix[i][j] << " "; i++; j--; }
        cout << endl;
    }
    // From last column
    for (int R = 1; R < n; ++R) {
        int i = R, j = m - 1;
        while(i < n && j >= 0) { cout << matrix[i][j] << " "; i++; j--; }
        cout << endl;
    }
}
```

### **Upper Triangular Elements**

```cpp
for (int i = 0; i < N; ++i)
    for (int j = i; j < N; ++j)
        cout << matrix[i][j] << " ";
```

---

## **3. Matrix Operations**

### **Transpose (In-Place for Square Matrix)**

```cpp
for (int i = 0; i < N; i++)
    for (int j = i + 1; j < N; j++)
        swap(matrix[i][j], matrix[j][i]);
```

### **Rotate 90° Clockwise**

```cpp
transposeMatrix(A);
for (int i = 0; i < N; i++)
    reverse(A[i].begin(), A[i].end());
```

### **Scalar Multiplication**

```cpp
for(int i=0;i<A.size();i++)
    for(int j=0;j<A[i].size();j++)
        A[i][j] *= B;
```

### **Matrix Addition**

```cpp
for(int i=0;i<A.size();i++)
    for(int j=0;j<A[i].size();j++)
        A[i][j] += B[i][j];
```

---

## **4. Common Problems**

### **Q1: Column Sum**

```cpp
vector<int> columnSum(vector<vector<int>>& A) {
    int rows = A.size(), cols = A[0].size();
    vector<int> colSums(cols, 0);
    for(int c=0;c<cols;c++)
        for(int r=0;r<rows;r++)
            colSums[c] += A[r][c];
    return colSums;
}
```

### **Q2: Main Diagonal Sum**

```cpp
int mainDiagonalSum(const vector<vector<int>>& A) {
    int sum = 0;
    for(int i=0;i<A.size();i++)
        sum += A[i][i];
    return sum;
}
```

### **Q3: Minor Diagonal Sum**

```cpp
int minorDiagonalSum(const vector<vector<int>>& A) {
    int N = A.size(), sum = 0;
    for(int i=0;i<N;i++)
        sum += A[i][N-i-1];
    return sum;
}
```

### **Q4: Row Sum**

```cpp
vector<int> rowSum(vector<vector<int>>& A) {
    vector<int> rowSums(A.size(),0);
    for(int i=0;i<A.size();i++)
        for(int j=0;j<A[i].size();j++)
            rowSums[i] += A[i][j];
    return rowSums;
}
```

### **Q5: Anti-Diagonals (Return 2D Matrix)**

```cpp
vector<vector<int>> antiDiagonals(vector<vector<int>>& A) {
    int N = A.size();
    vector<vector<int>> ans(2*N-1, vector<int>(N,0));
    int di = 0;
    // Upper half (including main diagonal)
    for(int c=0;c<N;c++){
        int i=0,j=c,dj=0;
        while(i<N && j>=0){ ans[di][dj++] = A[i++][j--]; }
        di++;
    }
    // Lower half
    for(int r=1;r<N;r++){
        int i=r,j=N-1,dj=0;
        while(i<N && j>=0){ ans[di][dj++] = A[i++][j--]; }
        di++;
    }
    return ans;
}
```

### **Q6: Matrix Transpose (Generic)**

```cpp
vector<vector<int>> transpose(vector<vector<int>>& A){
    int rows = A.size(), cols = A[0].size();
    vector<vector<int>> trans(cols, vector<int>(rows));
    for(int i=0;i<rows;i++)
        for(int j=0;j<cols;j++)
            trans[j][i] = A[i][j];
    return trans;
}
```

### **Q7: Rotate Matrix In-Place**

```cpp
void rotateMatrix(vector<vector<int>>& A){
    int N = A.size();
    // transpose
    for(int i=0;i<N-1;i++)
        for(int j=i+1;j<N;j++)
            swap(A[i][j], A[j][i]);
    // reverse each row
    for(int i=0;i<N;i++)
        reverse(A[i].begin(), A[i].end());
}
```

---

✅ **Tips & Tricks**

1. Use `i+j == N-1` for **minor diagonal**.
2. For anti-diagonals, think of **start points**: first row + last column.
3. For **in-place rotation**, always transpose first, then reverse rows.
4. Initialize `vector` with 0 to avoid garbage values.
5. Always check if matrix is empty to prevent runtime errors.

---

# **One-Dimensional Arrays – Complete Guide**

---

## **1. Maximum Subarray Problems**

### **Q1: Maximum Sum Contiguous Subarray (Kadane’s Algorithm)**

```cpp
int maxSubArray(const vector<int> &A) {
    int maxSum = INT_MIN, sum = 0;
    for(int i = 0; i < A.size(); i++) {
        sum += A[i];
        maxSum = max(maxSum, sum);
        if(sum < 0) sum = 0;
    }
    return maxSum;
}
```

**Pattern:** Keep a running sum, reset if negative, track maximum.

---

### **Q2: Continuous Sum Query (Beggars Problem / Difference Array)**

```cpp
vector<int> solve(int A, vector<vector<int>> &B) {
    vector<int> ans(A, 0);

    for(auto &donation : B) {
        int l = donation[0] - 1;
        int r = donation[1] - 1;
        int x = donation[2];

        ans[l] += x;
        if(r != A-1) ans[r+1] -= x;
    }

    for(int i = 1; i < A; i++) ans[i] += ans[i-1];

    return ans;
}
```

**Pattern:** Use **difference array** for range updates in O(1), then prefix sum.

---

### **Q3: Trapping Rain Water**

```cpp
int trap(const vector<int> &A) {
    int n = A.size();
    vector<int> lmax(n), rmax(n);
    lmax[0] = A[0];
    for(int i = 1; i < n; i++) lmax[i] = max(lmax[i-1], A[i]);
    rmax[n-1] = A[n-1];
    for(int i = n-2; i >= 0; i--) rmax[i] = max(rmax[i+1], A[i]);

    int ans = 0;
    for(int i = 0; i < n; i++)
        ans += min(lmax[i], rmax[i]) - A[i];
    return ans;
}
```

**Pattern:** Precompute **left max** and **right max** for each bar. Water trapped = min(leftMax, rightMax) - height.

---

## **2. Array Manipulation**

### **Q1: Add One to Number**

```cpp
vector<int> plusOne(vector<int> &A) {
    int n = A.size();
    int index = 0;
    while(index < n && A[index] == 0) index++;

    vector<int> result(A.begin() + index, A.end());
    n = result.size();

    for(int i = n-1; i >= 0; i--) {
        if(result[i] == 9) result[i] = 0;
        else { result[i]++; return result; }
    }

    result.insert(result.begin(), 1);
    return result;
}
```

**Pattern:** Handle carry from least significant digit to most significant, remove leading zeros.

---

### **Q2: Flip Binary String to Maximize 1s**

```cpp
vector<int> flip(string A) {
    int n = A.size();
    vector<int> transformed(n);

    for(int i = 0; i < n; i++)
        transformed[i] = (A[i] == '0') ? 1 : -1;

    int maxSum = 0, currentSum = 0, start = 0, tempStart = 0, end = -1;
    for(int i = 0; i < n; i++) {
        currentSum += transformed[i];
        if(currentSum > maxSum) {
            maxSum = currentSum;
            start = tempStart; end = i;
        }
        if(currentSum < 0) {
            currentSum = 0;
            tempStart = i+1;
        }
    }

    if(end == -1) return {};
    return {start+1, end+1};
}
```

**Pattern:** Transform 0→1 and 1→-1, then use **Kadane’s Algorithm** to find max subarray.

---

## **3. Patterns & Techniques**

1. **Kadane’s Algorithm:** Maximum contiguous subarray sum → linear scan with running sum.
2. **Difference Array:** Efficient range update → increment start, decrement end+1, then prefix sum.
3. **Prefix/Max Arrays:** Used in trapping rain water, sliding windows.
4. **Carry Handling:** In digit arrays → handle from least to most significant.
5. **Transform + Kadane:** For binary flip / maximizing 1s.

---

✅ **Tips & Tricks**

* Always check for **empty array** or all zeros in digit problems.
* Use **O(n)** approaches for large constraints (10^5 - 10^6 elements).
* In range update problems, **difference array** reduces complexity from O(n*m) to O(n + m).
* For binary/string problems, transform to numbers for numeric algorithms.

---

# **Two-Dimensional Arrays & Related Problems**

---

## **1. Spiral Order Matrix II**

**Problem:** Generate an N × N matrix filled with 1 to N² in spiral order.

```cpp
vector<vector<int>> generateMatrix(int A) {
    vector<vector<int>> matrix(A, vector<int>(A, 0));
    int r = 0, c = 0, count = 1, N = A;

    while (N > 1) {
        for (int i = 1; i < N; i++) matrix[r][c++] = count++;
        for (int i = 1; i < N; i++) matrix[r++][c] = count++;
        for (int i = 1; i < N; i++) matrix[r][c--] = count++;
        for (int i = 1; i < N; i++) matrix[r--][c] = count++;
        r++; c++; N -= 2;
    }
    if (N == 1) matrix[r][c] = count;
    return matrix;
}
```

**Pattern:** Simulate **layers of a spiral**, moving right → down → left → up.

---

## **2. Search in Row-wise & Column-wise Sorted Matrix**

**Problem:** Find element `B` in sorted matrix and return position `(i * 1009 + j)`.

```cpp
int solve(vector<vector<int>>& A, int B) {
    int n = A.size(), m = A[0].size(), r = 0, c = m-1, result = INT_MAX;

    while(r < n && c >= 0) {
        if(A[r][c] == B) {
            result = min(result, (r+1)*1009 + (c+1));
            c--;
        } else if(A[r][c] < B) r++;
        else c--;
    }

    return (result == INT_MAX) ? -1 : result;
}
```

**Pattern:** Start from **top-right corner**, move left if bigger, down if smaller → O(N + M).

---

## **3. Sum of All Submatrices**

**Problem:** Find sum of all submatrices of N×N matrix.

```cpp
int solve(vector<vector<int>> &A) {
    int ans = 0, N = A.size();
    for(int i = 0; i < N; i++) {
        for(int j = 0; j < N; j++) {
            ans += A[i][j] * (i+1)*(j+1)*(N-i)*(N-j);
        }
    }
    return ans;
}
```

**Pattern:** Each element contributes to `(i+1)*(j+1)*(N-i)*(N-j)` submatrices → multiply and sum.

---

## **4. Row with Maximum Number of Ones**

**Problem:** Find row index with maximum 1s in **binary sorted matrix**.

```cpp
int solve(vector<vector<int>> &A) {
    int ans = 0, r = 0, n = A.size(), c = A[0].size() - 1;

    while(r < n && c >= 0) {
        while(c >= 0 && A[r][c] == 1) { c--; ans = r; }
        r++;
    }

    return ans;
}
```

**Pattern:** Start from **top-right corner**, move left on 1s → O(N + M).

---

## **5. Minimum Swaps to Group Elements ≤ B**

**Problem:** Minimum swaps to bring all numbers ≤ B together.

```cpp
int solve(vector<int> &A, int B) {
    int n = A.size(), count = 0;
    for(int x : A) if(x <= B) count++;
    if(count == 0) return 0;

    int bad = 0;
    for(int i = 0; i < count; i++) if(A[i] > B) bad++;
    int min_swaps = bad;

    for(int i = 0, j = count; j < n; i++, j++) {
        if(A[i] > B) bad--;
        if(A[j] > B) bad++;
        min_swaps = min(min_swaps, bad);
    }
    return min_swaps;
}
```

**Pattern:** Use **sliding window** of size = count of elements ≤ B. Track "bad" elements (> B) in window.

---

## **Tips & Techniques for 2D & Related Array Problems**

1. **Layer-wise Traversal:** Spiral matrices → simulate layer by layer.
2. **Top-right / Bottom-left start:** Row-wise & column-wise sorted searches.
3. **Contribution Method:** Each element in submatrices problem → multiply counts of occurrences.
4. **Sliding Window:** For grouping problems or subarray-related swaps.
5. **O(N+M) instead of O(N*M):** In row/column sorted or binary matrices.

---

# **Interview Problems – Arrays & Numbers**

---

## **1. Length of Longest Consecutive Ones (1 Swap Allowed)**

**Problem:** Max consecutive 1s after at most one 0↔1 swap.

**Approach:** Count total 1s. For every 0, sum left/right consecutive 1s, capped at total 1s.

```cpp
int solve(string A) {
    int one = count(A.begin(), A.end(), '1');
    int ans = 0, n = A.size();
    if(one == n) return one;

    for(int i = 0; i < n; i++){
        if(A[i] == '0'){
            int l = 0, r = 0;
            for(int j=i-1;j>=0 && A[j]=='1';j--) l++;
            for(int j=i+1;j<n && A[j]=='1';j++) r++;
            ans = max(ans, min(l+r+1, one));
        }
    }
    return ans;
}
```

---

## **2. Majority Element (Boyer-Moore Voting)**

**Problem:** Element appearing > n/2 times.

**Approach:** Find candidate, verify frequency.

```cpp
int majorityElement(const vector<int> &A) {
    int m = -1, f = 0;
    for(int x:A){
        if(f==0) { m=x; f=1; }
        else if(x==m) f++; else f--;
    }
    f = count(A.begin(), A.end(), m);
    return (f > A.size()/2) ? m : -1;
}
```

---

## **3. Count Increasing Triplets**

**Problem:** Count i<j<k with A[i]<A[j]<A[k].

**Approach:** Precompute `left_smaller` and `right_larger`.

```cpp
int solve(vector<int> &A){
    int n = A.size(), triplets=0;
    vector<int> left_sm(n,0), right_lg(n,0);
    for(int j=1;j<n;j++)
        for(int i=0;i<j;i++) if(A[i]<A[j]) left_sm[j]++;
    for(int j=0;j<n-1;j++)
        for(int k=j+1;k<n;k++) if(A[j]<A[k]) right_lg[j]++;
    for(int j=0;j<n;j++) triplets+=left_sm[j]*right_lg[j];
    return triplets;
}
```

---

## **4. N/3 Repeat Number (Extended Boyer-Moore)**

**Problem:** Element appearing > n/3 times.

**Approach:** Track 2 candidates → verify.

```cpp
int repeatedNumber(const vector<int> &A){
    int c1=0,c2=0,v1=0,v2=0;
    for(int x:A){
        if(x==v1) c1++;
        else if(x==v2) c2++;
        else if(c1==0) {v1=x;c1=1;}
        else if(c2==0) {v2=x;c2=1;}
        else {c1--;c2--;}
    }
    c1=c2=0;
    for(int x:A){ if(x==v1)c1++; else if(x==v2)c2++; }
    if(c1>A.size()/3) return v1;
    if(c2>A.size()/3) return v2;
    return -1;
}
```

---

## **5. Check Anagrams**

**Problem:** Check if two strings are anagrams.

**Approach:** Count frequency of letters.

```cpp
int solve(string A, string B){
    if(A.size()!=B.size()) return 0;
    vector<int> freqA(26,0), freqB(26,0);
    for(int i=0;i<A.size();i++){ freqA[A[i]-'a']++; freqB[B[i]-'a']++; }
    return freqA==freqB?1:0;
}
```

---

## **6. Colorful Number**

**Problem:** All products of consecutive digit subsequences are unique.

**Approach:** Use a set to track products.

```cpp
int colorful(int A){
    string num=to_string(A);
    unordered_set<long long> s;
    for(int i=0;i<num.size();i++){
        long long prod=1;
        for(int j=i;j<num.size();j++){
            prod*=(num[j]-'0');
            if(s.count(prod)) return 0;
            s.insert(prod);
        }
    }
    return 1;
}
```

---

## **7. First Missing Positive Integer (Cyclic Sort)**

**Problem:** Find smallest missing positive integer.

```cpp
int firstMissingPositive(vector<int> &A){
    int N=A.size();
    for(int i=0;i<N;i++)
        while(A[i]>0 && A[i]<=N && A[i]!=A[A[i]-1])
            swap(A[i], A[A[i]-1]);
    for(int i=0;i<N;i++) if(A[i]!=i+1) return i+1;
    return N+1;
}
```

---

## **8. Merge Sorted Overlapping Intervals**

```cpp
vector<vector<int>> solve(vector<vector<int>> &A){
    vector<vector<int>> res;
    if(A.empty()) return res;
    vector<int> cur=A[0];
    for(int i=1;i<A.size();i++){
        if(A[i][0]<=cur[1]) cur[1]=max(cur[1], A[i][1]);
        else { res.push_back(cur); cur=A[i]; }
    }
    res.push_back(cur);
    return res;
}
```

---

## **9. Insert & Merge Interval**

```cpp
vector<vector<int>> insert(vector<vector<int>> &A, vector<int> &B){
    vector<vector<int>> res; bool inserted=false;
    for(auto &cur:A){
        if(cur[1]<B[0]) res.push_back(cur);
        else if(cur[0]>B[1]){
            if(!inserted) { res.push_back(B); inserted=true; }
            res.push_back(cur);
        } else { B[0]=min(B[0],cur[0]); B[1]=max(B[1],cur[1]); }
    }
    if(!inserted) res.push_back(B);
    return res;
}
```

---

## **10. Next Permutation**

**Problem:** Find lexicographically next permutation.

```cpp
vector<int> nextPermutation(vector<int> &A){
    int n=A.size(), i=n-2;
    while(i>=0 && A[i]>=A[i+1]) i--;
    if(i>=0){ int j=n-1; while(A[j]<=A[i]) j--; swap(A[i], A[j]); }
    reverse(A.begin()+i+1, A.end());
    return A;
}
```

---

## **11. Number of Digit One**

**Problem:** Count number of digit 1 in [0…A].

```cpp
int solve(int A){
    int count=0; long long factor=1;
    while(factor<=A){
        long long lower=A%factor, curr=(A/factor)%10, higher=A/(factor*10);
        if(curr<1) count+=higher*factor;
        else if(curr==1) count+=higher*factor+lower+1;
        else count+=(higher+1)*factor;
        factor*=10;
    }
    return count;
}
```

---

# **1. Pascal’s Triangle | Efficient nCr Calculation**

```cpp
// Function to calculate nCr using Pascal's Triangle (Iterative)
int nCr(int n, int r) {
    vector<int> C(r+1, 0);
    C[0] = 1; // nC0 is 1

    for(int i = 1; i <= n; i++) {
        for(int j = min(i,r); j > 0; j--) {
            C[j] = C[j] + C[j-1];
        }
    }
    return C[r];
}

// Example usage:
int main() {
    int n = 5, r = 2;
    cout << nCr(n, r); // Output: 10
}
```

**Time Complexity:** O(n*r)
**Space Complexity:** O(r)

---

# **2. Majority Element II (Elements > n/3 times)**

```cpp
vector<int> majorityElementII(vector<int>& nums) {
    int n = nums.size();
    int candidate1 = INT_MAX, candidate2 = INT_MAX;
    int count1 = 0, count2 = 0;

    // Step 1: Find potential candidates
    for(int num : nums) {
        if(num == candidate1) count1++;
        else if(num == candidate2) count2++;
        else if(count1 == 0) { candidate1 = num; count1 = 1; }
        else if(count2 == 0) { candidate2 = num; count2 = 1; }
        else { count1--; count2--; }
    }

    // Step 2: Verify candidates
    count1 = count2 = 0;
    for(int num : nums) {
        if(num == candidate1) count1++;
        else if(num == candidate2) count2++;
    }

    vector<int> result;
    if(count1 > n/3) result.push_back(candidate1);
    if(count2 > n/3) result.push_back(candidate2);
    return result;
}
```

**Time Complexity:** O(n)
**Space Complexity:** O(1)

---

# **3. 3 Sum Problem**

```cpp
vector<vector<int>> threeSum(vector<int>& nums) {
    sort(nums.begin(), nums.end());
    vector<vector<int>> result;

    for(int i = 0; i < nums.size(); i++) {
        if(i > 0 && nums[i] == nums[i-1]) continue; // skip duplicates
        int L = i+1, R = nums.size()-1;
        while(L < R) {
            int sum = nums[i] + nums[L] + nums[R];
            if(sum == 0) {
                result.push_back({nums[i], nums[L], nums[R]});
                while(L < R && nums[L] == nums[L+1]) L++;
                while(L < R && nums[R] == nums[R-1]) R--;
                L++; R--;
            }
            else if(sum < 0) L++;
            else R--;
        }
    }
    return result;
}
```

**Time Complexity:** O(n²)
**Space Complexity:** O(1) (ignoring output)

---

# **4. 4 Sum Problem**

```cpp
vector<vector<int>> fourSum(vector<int>& nums, int target) {
    sort(nums.begin(), nums.end());
    vector<vector<int>> result;
    int n = nums.size();

    for(int i = 0; i < n; i++) {
        if(i > 0 && nums[i] == nums[i-1]) continue;
        for(int j = i+1; j < n; j++) {
            if(j > i+1 && nums[j] == nums[j-1]) continue;
            int L = j+1, R = n-1;
            while(L < R) {
                long sum = (long)nums[i] + nums[j] + nums[L] + nums[R];
                if(sum == target) {
                    result.push_back({nums[i], nums[j], nums[L], nums[R]});
                    while(L < R && nums[L] == nums[L+1]) L++;
                    while(L < R && nums[R] == nums[R-1]) R--;
                    L++; R--;
                }
                else if(sum < target) L++;
                else R--;
            }
        }
    }
    return result;
}
```

**Time Complexity:** O(n³)
**Space Complexity:** O(1)

---

# **5. Number of Subarrays with XOR K**

```cpp
int subarraysXorK(vector<int>& nums, int K) {
    unordered_map<int,int> freq;
    int count = 0, xorSum = 0;

    for(int num : nums) {
        xorSum ^= num;
        if(xorSum == K) count++;
        if(freq.find(xorSum ^ K) != freq.end()) {
            count += freq[xorSum ^ K];
        }
        freq[xorSum]++;
    }
    return count;
}
```

**Time Complexity:** O(n)
**Space Complexity:** O(n)

---

# **6. Merge Overlapping Intervals**

```cpp
vector<vector<int>> mergeIntervals(vector<vector<int>>& intervals) {
    if(intervals.empty()) return {};
    sort(intervals.begin(), intervals.end());
    vector<vector<int>> merged;
    merged.push_back(intervals[0]);

    for(int i = 1; i < intervals.size(); i++) {
        if(intervals[i][0] <= merged.back()[1]) {
            merged.back()[1] = max(merged.back()[1], intervals[i][1]);
        } else {
            merged.push_back(intervals[i]);
        }
    }
    return merged;
}
```

**Time Complexity:** O(n log n)
**Space Complexity:** O(n)

---

# **7. Merge Sorted Arrays without Extra Space**

```cpp
// Gap method
void mergeSortedArrays(vector<int>& A, vector<int>& B) {
    int n = A.size(), m = B.size();
    int gap = (n + m + 1) / 2;

    auto nextGap = [](int gap) { return gap <= 1 ? 0 : (gap + 1) / 2; };

    for(; gap > 0; gap = nextGap(gap)) {
        int i = 0, j = gap;
        while(j < n + m) {
            int val1 = i < n ? A[i] : B[i-n];
            int val2 = j < n ? A[j] : B[j-n];
            if(val1 > val2) {
                if(i < n && j < n) swap(A[i], A[j]);
                else if(i < n && j >= n) swap(A[i], B[j-n]);
                else swap(B[i-n], B[j-n]);
            }
            i++; j++;
        }
    }
}
```

**Time Complexity:** O((n+m) log(n+m))
**Space Complexity:** O(1)

---

# **8. Find Missing and Repeating Number**

```cpp
pair<int,int> findMissingRepeating(vector<int>& arr) {
    int n = arr.size();
    long long sum = 0, sumSq = 0;
    for(int num : arr) {
        sum += num;
        sumSq += (long long)num*num;
    }

    long long expectedSum = n*(n+1)/2;
    long long expectedSq = n*(n+1)*(2*n+1)/6;

    long long diff = expectedSum - sum;      // missing - repeating
    long long diffSq = expectedSq - sumSq;   // missing^2 - repeating^2

    int missing = (diff + diffSq/diff)/2;
    int repeating = missing - diff;

    return {missing, repeating};
}
```

**Time Complexity:** O(n)
**Space Complexity:** O(1)

---

# **9. Count Inversions in an Array**

```cpp
int mergeAndCount(vector<int>& arr, int l, int m, int r) {
    int n1 = m - l + 1, n2 = r - m;
    vector<int> L(arr.begin()+l, arr.begin()+m+1);
    vector<int> R(arr.begin()+m+1, arr.begin()+r+1);

    int i=0, j=0, k=l, invCount=0;
    while(i<n1 && j<n2) {
        if(L[i] <= R[j]) arr[k++] = L[i++];
        else {
            arr[k++] = R[j++];
            invCount += (n1 - i);
        }
    }
    while(i<n1) arr[k++] = L[i++];
    while(j<n2) arr[k++] = R[j++];
    return invCount;
}

int countInversions(vector<int>& arr, int l, int r) {
    int invCount = 0;
    if(l < r) {
        int m = l + (r-l)/2;
        invCount += countInversions(arr, l, m);
        invCount += countInversions(arr, m+1, r);
        invCount += mergeAndCount(arr, l, m, r);
    }
    return invCount;
}
```

**Time Complexity:** O(n log n)
**Space Complexity:** O(n)

---

# **10. Reverse Pairs (nums[i] > 2*nums[j])**

```cpp
int mergeAndCountReverse(vector<int>& arr, int l, int m, int r) {
    int cnt = 0;
    int j = m+1;
    for(int i=l; i<=m; i++) {
        while(j<=r && arr[i] > 2LL * arr[j]) j++;
        cnt += (j - (m+1));
    }
    vector<int> temp;
    int i=l; j=m+1;
    while(i<=m && j<=r) temp.push_back(arr[i]<=arr[j]?arr[i++]:arr[j++]);
    while(i<=m) temp.push_back(arr[i++]);
    while(j<=r) temp.push_back(arr[j++]);
    for(int k=l; k<=r; k++) arr[k] = temp[k-l];
    return cnt;
}

int countReversePairs(vector<int>& arr, int l, int r) {
    if(l>=r) return 0;
    int m = l + (r-l)/2;
    int cnt = countReversePairs(arr, l, m) + countReversePairs(arr, m+1, r);
    cnt += mergeAndCountReverse(arr, l, m, r);
    return cnt;
}
```

**Time Complexity:** O(n log n)
**Space Complexity:** O(n)

---

# **11. Maximum Product Subarray**

```cpp
int maxProductSubarray(vector<int>& nums) {
    int maxProd = nums[0], minProd = nums[0], result = nums[0];
    for(int i = 1; i < nums.size(); i++) {
        if(nums[i] < 0) swap(maxProd, minProd);
        maxProd = max(nums[i], maxProd * nums[i]);
        minProd = min(nums[i], minProd * nums[i]);
        result = max(result, maxProd);
    }
    return result;
}
```

**Time Complexity:** O(n)
**Space Complexity:** O(1)

---
