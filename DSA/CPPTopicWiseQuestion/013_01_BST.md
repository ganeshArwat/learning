## ğŸŒ³ 1ï¸âƒ£ What is a BST?

A **Binary Search Tree (BST)** is a **special kind of binary tree** where:

* Every node follows the **BST property**:

  ```
  Left subtree values < Node value < Right subtree values
  ```
* Left and right subtrees are also BSTs.

ğŸ“˜ Example:

```
        8
       / \
      3   10
     / \    \
    1   6    14
       / \   /
      4   7 13
```

âœ… Every node follows the rule:

* Left < Node < Right

---

## ğŸ§± 2ï¸âƒ£ Structure of a BST Node

Weâ€™ll use the same structure as before:

```cpp
struct TreeNode {
    int val;
    TreeNode* left;
    TreeNode* right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

---

## ğŸŒ± 3ï¸âƒ£ Insert into BST

### ğŸ§  Concept

To insert a value:

* If itâ€™s **smaller** than the current node â†’ go **left**
* If itâ€™s **larger** â†’ go **right**
* If position is null â†’ create a new node there.

### ğŸ’» Code

```cpp
TreeNode* insert(TreeNode* root, int val) {
    if (!root) return new TreeNode(val);

    if (val < root->val)
        root->left = insert(root->left, val);
    else if (val > root->val)
        root->right = insert(root->right, val);

    return root;
}
```

### ğŸ” Example

Insert 5, 3, 7, 2, 4 â†’

```
        5
       / \
      3   7
     / \
    2   4
```

---

## ğŸ” 4ï¸âƒ£ Search in BST

### ğŸ§  Concept

Use the BST property to search faster â€” O(log N) in average case.

### ğŸ’» Code

```cpp
bool search(TreeNode* root, int key) {
    if (!root) return false;
    if (root->val == key) return true;
    if (key < root->val)
        return search(root->left, key);
    else
        return search(root->right, key);
}
```

---

## âŒ 5ï¸âƒ£ Delete a Node in BST

### ğŸ§  Concept

Three cases:

1. Node has **no child** â†’ just delete.
2. Node has **one child** â†’ replace with child.
3. Node has **two children** â†’ find **inorder successor** (smallest in right subtree), copy its value, then delete it.

### ğŸ’» Code

```cpp
TreeNode* findMin(TreeNode* node) {
    while (node && node->left)
        node = node->left;
    return node;
}

TreeNode* deleteNode(TreeNode* root, int key) {
    if (!root) return nullptr;

    if (key < root->val)
        root->left = deleteNode(root->left, key);
    else if (key > root->val)
        root->right = deleteNode(root->right, key);
    else {
        // Node found
        if (!root->left && !root->right)
            return nullptr; // No child
        else if (!root->left)
            return root->right; // Only right child
        else if (!root->right)
            return root->left; // Only left child
        else {
            // Two children
            TreeNode* successor = findMin(root->right);
            root->val = successor->val;
            root->right = deleteNode(root->right, successor->val);
        }
    }
    return root;
}
```

---

## ğŸ”¢ 6ï¸âƒ£ Inorder Traversal of BST (Sorted Order)

### ğŸ§  Concept

Inorder traversal of a BST always gives **sorted order**.

### ğŸ’» Code

```cpp
void inorder(TreeNode* root) {
    if (!root) return;
    inorder(root->left);
    cout << root->val << " ";
    inorder(root->right);
}
```

---

## âš–ï¸ 7ï¸âƒ£ Validate BST

### ğŸ§  Concept

Check that for every node, all values in the left are smaller and all in the right are larger.
We use **minâ€“max range** for validation.

### ğŸ’» Code

```cpp
bool isValidBST(TreeNode* root, long minVal = LONG_MIN, long maxVal = LONG_MAX) {
    if (!root) return true;

    if (root->val <= minVal || root->val >= maxVal)
        return false;

    return isValidBST(root->left, minVal, root->val) &&
           isValidBST(root->right, root->val, maxVal);
}
```

---

## ğŸ¯ 8ï¸âƒ£ Find Min & Max in BST

### ğŸ’» Code

```cpp
int findMinValue(TreeNode* root) {
    while (root->left) root = root->left;
    return root->val;
}

int findMaxValue(TreeNode* root) {
    while (root->right) root = root->right;
    return root->val;
}
```

---

## ğŸ“ˆ 9ï¸âƒ£ Find Kth Smallest Element

Since inorder traversal is sorted, just count nodes.

### ğŸ’» Code

```cpp
int kthSmallest(TreeNode* root, int& k) {
    if (!root) return -1;

    int left = kthSmallest(root->left, k);
    if (k == 0) return left;

    k--;
    if (k == 0) return root->val;

    return kthSmallest(root->right, k);
}
```

Usage:

```cpp
int k = 3;
cout << kthSmallest(root, k);
```

---

## ğŸ§ª Example Main Function

```cpp
int main() {
    TreeNode* root = nullptr;
    root = insert(root, 5);
    root = insert(root, 3);
    root = insert(root, 7);
    root = insert(root, 2);
    root = insert(root, 4);
    root = insert(root, 6);
    root = insert(root, 8);

    cout << "Inorder (Sorted): ";
    inorder(root);
    cout << endl;

    cout << "Search 4: " << (search(root, 4) ? "Found" : "Not Found") << endl;

    root = deleteNode(root, 3);
    cout << "After deleting 3: ";
    inorder(root);
    cout << endl;

    cout << "Is BST valid? " << (isValidBST(root) ? "Yes" : "No") << endl;
}
```

---

## ğŸ§­ Summary Table

| Operation | Time | Explanation              |
| --------- | ---- | ------------------------ |
| Insert    | O(h) | h = height of tree       |
| Search    | O(h) | Binary property          |
| Delete    | O(h) | Find and fix node        |
| Inorder   | O(N) | Sorted traversal         |
| Validate  | O(N) | Recursively check bounds |

---

# ğŸŒ² SELF-BALANCING BINARY SEARCH TREES

## Why do we need them?

ğŸ‘‰ Normal **BSTs** can become **unbalanced**, meaning one side is much deeper than the other.
That turns operations like `insert`, `search`, and `delete` from **O(log N)** â†’ **O(N)** ğŸ˜¬

Example of an *unbalanced* BST (like a linked list):

```
    1
     \
      2
       \
        3
         \
          4
```

To fix that, we use **self-balancing trees**, which automatically **rotate nodes** to maintain balance.

---

# âš–ï¸ 1ï¸âƒ£ AVL Tree (Adelson-Velsky and Landis Tree)

## ğŸŒ³ What is an AVL Tree?

An **AVL Tree** is a **height-balanced BST**.
For every node:

```
Balance Factor (BF) = height(left subtree) - height(right subtree)
```

âœ… For a valid AVL tree:

```
Balance Factor âˆˆ { -1, 0, +1 }
```

If balance factor goes beyond Â±1 â†’ **rotation is required**.

---

## ğŸ”„ Types of Rotations in AVL

| Case             | Example                                                   | Fix using                 |
| ---------------- | --------------------------------------------------------- | ------------------------- |
| Left Left (LL)   | New node inserted in **left subtree** of **left child**   | **Right Rotation**        |
| Right Right (RR) | New node inserted in **right subtree** of **right child** | **Left Rotation**         |
| Left Right (LR)  | New node in **right subtree** of **left child**           | **Left + Right Rotation** |
| Right Left (RL)  | New node in **left subtree** of **right child**           | **Right + Left Rotation** |

---

## ğŸ§  AVL Rotation Logic (Visual)

### Right Rotation (LL case)

```
     y                               x
    / \     Right Rotation          / \
   x   T3   â€“ â€“ â€“ â€“ â€“ â€“ â€“ >        T1  y
  / \                                   / \
 T1  T2                                T2  T3
```

### Left Rotation (RR case)

```
   x                                y
  / \     Left Rotation            / \
 T1  y   â€“ â€“ â€“ â€“ â€“ â€“ â€“ >          x  T3
    / \                           / \
   T2  T3                        T1  T2
```

---

## ğŸ’» AVL Implementation (Simplified)

```cpp
struct Node {
    int val;
    Node* left;
    Node* right;
    int height;
    Node(int v): val(v), left(nullptr), right(nullptr), height(1) {}
};

int height(Node* n) {
    return n ? n->height : 0;
}

int getBalance(Node* n) {
    return n ? height(n->left) - height(n->right) : 0;
}

// Right Rotate
Node* rightRotate(Node* y) {
    Node* x = y->left;
    Node* T2 = x->right;

    x->right = y;
    y->left = T2;

    y->height = max(height(y->left), height(y->right)) + 1;
    x->height = max(height(x->left), height(x->right)) + 1;

    return x;
}

// Left Rotate
Node* leftRotate(Node* x) {
    Node* y = x->right;
    Node* T2 = y->left;

    y->left = x;
    x->right = T2;

    x->height = max(height(x->left), height(x->right)) + 1;
    y->height = max(height(y->left), height(y->right)) + 1;

    return y;
}

// Insert and Balance
Node* insert(Node* node, int val) {
    if (!node) return new Node(val);

    if (val < node->val)
        node->left = insert(node->left, val);
    else if (val > node->val)
        node->right = insert(node->right, val);
    else
        return node; // No duplicates

    node->height = 1 + max(height(node->left), height(node->right));

    int balance = getBalance(node);

    // Left Left
    if (balance > 1 && val < node->left->val)
        return rightRotate(node);
    // Right Right
    if (balance < -1 && val > node->right->val)
        return leftRotate(node);
    // Left Right
    if (balance > 1 && val > node->left->val) {
        node->left = leftRotate(node->left);
        return rightRotate(node);
    }
    // Right Left
    if (balance < -1 && val < node->right->val) {
        node->right = rightRotate(node->right);
        return leftRotate(node);
    }

    return node;
}
```

âœ… All operations (insert, delete, search) are **O(log N)**.

---

# ğŸŸ¥ 2ï¸âƒ£ Red-Black Tree

A **Red-Black Tree (RBT)** is another self-balancing BST used in **C++ STL (map, set)**, **Java TreeMap**, etc.

It is less strictly balanced than AVL but **faster in practice** due to fewer rotations.

---

## âš« Red-Black Properties

Each node has a **color**: either **RED** or **BLACK**.

Must satisfy these rules:

1. Every node is **RED** or **BLACK**.
2. Root is always **BLACK**.
3. All **leaves (NULL nodes)** are considered **BLACK**.
4. If a node is **RED**, both its children are **BLACK**.
5. Every path from a node to its descendant leaves has the **same number of black nodes**.

These properties keep tree height â‰¤ **2 Ã— logâ‚‚(n + 1)** â†’ ensuring O(log N) performance.

---

## ğŸ§  Red-Black Insert Logic (High Level)

When inserting a node:

1. Insert as in a normal BST.
2. Color the new node **RED**.
3. Fix violations using **rotations** and **recoloring**.

Violations occur if:

* Parent and child both are RED (breaks property #4).

---

## ğŸ§© Fixing Violations (Cases)

| Case   | Condition                                                    | Fix                                    |
| ------ | ------------------------------------------------------------ | -------------------------------------- |
| Case 1 | Uncle is RED                                                 | Recolor parent, uncle, and grandparent |
| Case 2 | Uncle is BLACK and node is inside (Left-Right / Right-Left)  | Rotate to convert to Case 3            |
| Case 3 | Uncle is BLACK and node is outside (Left-Left / Right-Right) | Rotate and recolor                     |

---

## ğŸ’» Implementation (Simplified)

The full code is quite large, but here's a **conceptual skeleton**:

```cpp
enum Color { RED, BLACK };

struct RBNode {
    int val;
    Color color;
    RBNode *left, *right, *parent;

    RBNode(int v) : val(v), color(RED), left(nullptr), right(nullptr), parent(nullptr) {}
};

// Rotate left
void rotateLeft(RBNode*& root, RBNode*& x);

// Rotate right
void rotateRight(RBNode*& root, RBNode*& y);

// Fix violations
void fixInsert(RBNode*& root, RBNode*& node);

// Insert function
void insert(RBNode*& root, int val) {
    RBNode* node = new RBNode(val);
    // 1. Insert as in BST
    // 2. Fix color violations
    fixInsert(root, node);
}
```

ğŸ“˜ Red-Black Trees are **used in STL containers** because:

* Slightly less balanced than AVL (less rotation cost)
* Guaranteed **O(log N)** for insert/search/delete

---

# ğŸ§© Comparison: AVL vs Red-Black

| Feature       | AVL Tree                 | Red-Black Tree                   |
| ------------- | ------------------------ | -------------------------------- |
| Balance       | Strict (BF âˆˆ {âˆ’1,0,1})   | Looser (color-based)             |
| Rotations     | More frequent            | Fewer                            |
| Search        | Faster (tighter balance) | Slightly slower                  |
| Insert/Delete | Slower (more rotations)  | Faster                           |
| Used in       | Databases, indexes       | STL (`map`, `set`), Linux kernel |

---

# ğŸ¯ Summary

| Tree Type | Ensures Balance | Avg. Time Complexity | Used In          |
| --------- | --------------- | -------------------- | ---------------- |
| BST       | âŒ No            | O(N) worst case      | Basic structures |
| AVL       | âœ… Height-based  | O(log N)             | Database indexes |
| Red-Black | âœ… Color-based   | O(log N)             | STL map/set      |

---

## ğŸ§© Case 1: Construct BST from **Sorted Array**

---

### ğŸ” Problem Understanding

If we directly insert sorted elements into a BST like `[1, 2, 3, 4, 5, 6, 7]`,
the tree will become **skewed** (like a linked list):

```
1
 \
  2
   \
    3
     \
      ...
```

This is **not balanced** â†’ O(N) operations ğŸ˜¬

So, the idea is to **always pick the middle element as the root**.
That keeps the tree balanced.

---

### ğŸ§  Algorithm (Divide and Conquer)

1. Find the **middle** element of the array â€” that becomes the **root**.
2. Recursively build the **left subtree** using the **left half** of the array.
3. Recursively build the **right subtree** using the **right half** of the array.
4. Stop when `start > end`.

---

### ğŸ’» Code Explanation

```cpp
TreeNode* sortedArrayToBST(int arr[], int start, int end) {
    // Base case: no elements
    if (start > end) {
        return nullptr;
    }

    // Find middle index
    int mid = start + (end - start) / 2;

    // Make middle element root
    TreeNode* node = new TreeNode(arr[mid]);

    // Build left subtree from left half
    node->left = sortedArrayToBST(arr, start, mid - 1);

    // Build right subtree from right half
    node->right = sortedArrayToBST(arr, mid + 1, end);

    return node;
}
```

### ğŸ§­ Example

Input:

```cpp
int arr[] = {1, 2, 3, 4, 5, 6, 7};
TreeNode* root = sortedArrayToBST(arr, 0, 6);
```

Output Tree:

```
        4
      /   \
     2     6
    / \   / \
   1  3  5  7
```

ğŸ‘‰ Perfectly balanced, because we always pick the mid element.

---

## ğŸ§© Case 2: Construct BST from **Unsorted Array**

---

### ğŸ” Problem Understanding

If the array is **not sorted**, like `[5, 3, 7, 1, 4, 6, 8]`,
we canâ€™t use the mid-element trick.

So, we build it **by inserting one-by-one** into the BST using the **BST property**:

* If value < root â†’ go **left**
* If value > root â†’ go **right**

---

### ğŸ’» Code Explanation

#### âœ… Step 1 â€” Insert function

```cpp
TreeNode* insert(TreeNode* root, int val) {
    if (root == nullptr) {
        return new TreeNode(val);
    }

    if (val < root->val) {
        root->left = insert(root->left, val);
    } else {
        root->right = insert(root->right, val);
    }

    return root;
}
```

#### âœ… Step 2 â€” Construct BST from array

```cpp
TreeNode* constructBST(int arr[], int n) {
    TreeNode* root = nullptr;
    for (int i = 0; i < n; i++) {
        root = insert(root, arr[i]);
    }
    return root;
}
```

---

### ğŸ§­ Example

Input:

```cpp
int arr[] = {5, 3, 7, 1, 4, 6, 8};
TreeNode* root = constructBST(arr, 7);
```

Output Tree:

```
        5
      /   \
     3     7
    / \   / \
   1  4  6  8
```

âœ… Here we inserted elements **in given order**, using BST insertion rules.

---

### ğŸ§  Comparison

| Feature         | Sorted Array â†’ BST             | Unsorted Array â†’ BST                  |
| --------------- | ------------------------------ | ------------------------------------- |
| Input           | Sorted array                   | Random/unsorted array                 |
| Approach        | Divide & Conquer               | Sequential Insertion                  |
| Time Complexity | O(N)                           | O(N log N) average (O(NÂ²) worst case) |
| Resulting Tree  | **Balanced**                   | May be **unbalanced**                 |
| Used In         | Construct balanced BST quickly | Normal BST building                   |

---

### ğŸ§© Extra Tip

If your unsorted array is big and you want a **balanced tree**,
you can first sort it, then use `sortedArrayToBST()` method.

---

### ğŸ§  Summary Diagram

```
Unsorted â†’ Insert() each â†’ May be unbalanced
Sorted â†’ Pick mid recursively â†’ Balanced BST
```

---

## ğŸŒ³ Q2: Count BST Nodes in a Given Range

---

### ğŸ” Problem Understanding

We are given a BST and two integers `B` and `C`.
We must **count how many nodes** have values in the range `[B, C]`.

Example:

```
            15
          /    \
        12      20
       / \     /  \
     10  14  16  27
    /
   8
```

Range `[12, 20]`

âœ… Nodes in range: 12, 14, 15, 16, 20 â†’ **Count = 5**

---

### ğŸ’¡ Key Observation â€” Use BST Properties

In BST:

* All nodes in **left subtree** < root
* All nodes in **right subtree** > root

So:

* If `node->val < B`, all left nodes are smaller â†’ ignore left, go right.
* If `node->val > C`, all right nodes are greater â†’ ignore right, go left.
* If `B â‰¤ node->val â‰¤ C`, count it and check both subtrees.

---

### ğŸ’» Code Explanation

```cpp
int countNodesInRange(TreeNode* node, int B, int C) {
    if (node == NULL)
        return 0;

    int count = 0;

    // If node is within range
    if (node->val >= B && node->val <= C) {
        count = 1;
    }

    // Explore left only if there can be valid values
    if (node->val > B)
        count += countNodesInRange(node->left, B, C);

    // Explore right only if there can be valid values
    if (node->val < C)
        count += countNodesInRange(node->right, B, C);

    return count;
}
```

Then you just call:

```cpp
int Solution::solve(TreeNode* A, int B, int C) {
    return countNodesInRange(A, B, C);
}
```

---

### ğŸ§  Time Complexity

* Each node visited at most once â†’ **O(N)**
* But due to pruning, often better than O(N).

---

### âœ… Intuition Recap

* Use **in-order traversal** logic.
* **Prune** unnecessary subtrees using BST rules.
* Count only nodes that satisfy the range.

---

## ğŸ’¥ Q3: Two Sum in BST

---

### ğŸ” Problem Understanding

We need to find whether **two nodes exist** such that:

```
node1->val + node2->val == B
```

For example:

```
       10
      /  \
     9   20
```

B = 19 â†’ âœ… 9 + 10 = 19 â†’ return `1`
B = 40 â†’ âŒ â†’ return `0`

---

### ğŸ’¡ Approach â€” Inorder + Two Pointer

1. Perform **inorder traversal** of BST â†’ gives **sorted array**.
   Example:

   ```
   Inorder of BST: [9, 10, 20]
   ```
2. Use **two-pointer technique** (like in Two Sum in sorted array):

   * Start with `left = 0`, `right = n - 1`
   * Compute `sum = values[left] + values[right]`
   * If sum == B â†’ found â†’ return 1
   * If sum < B â†’ move `left++`
   * If sum > B â†’ move `right--`

---

### ğŸ’» Code

```cpp
void inOrderTraversal(TreeNode* node, vector<int>& values) {
    if (node == NULL)
        return;
    inOrderTraversal(node->left, values);
    values.push_back(node->val);
    inOrderTraversal(node->right, values);
}

int Solution::t2Sum(TreeNode* A, int B) {
    vector<int> values;
    inOrderTraversal(A, values);  // Step 1: Get sorted values

    int left = 0;
    int right = values.size() - 1;

    // Step 2: Two pointer check
    while (left < right) {
        int sum = values[left] + values[right];
        if (sum == B)
            return 1;
        else if (sum < B)
            left++;
        else
            right--;
    }

    return 0;
}
```

---

### ğŸ§  Time & Space Complexity

| Operation              | Complexity |
| ---------------------- | ---------- |
| Inorder Traversal      | O(N)       |
| Two Pointer Search     | O(N)       |
| **Total Time**         | **O(N)**   |
| **Space (for values)** | **O(N)**   |

---

### ğŸ§© Optimization Option

If we donâ€™t want to use extra space (`O(N)`),
we can use **two iterators** on the BST directly:

* One doing **inorder** (smallest â†’ largest)
* Another doing **reverse inorder** (largest â†’ smallest)
  and move them inward like two pointers.

But thatâ€™s an advanced version â€” your approach is perfect for clarity & interviews âœ…

---

### âœ… Summary

| Problem              | Core Concept                | Technique           |
| -------------------- | --------------------------- | ------------------- |
| Count Nodes in Range | BST property + recursion    | Selective traversal |
| Two Sum in BST       | Sorted values + Two pointer | Inorder traversal   |

---

