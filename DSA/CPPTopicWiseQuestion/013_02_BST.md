## üå± 1. Kth Smallest Element in a BST

---

### üß† Concept:

* In a **BST**, the **inorder traversal** (Left ‚Üí Root ‚Üí Right) gives the **nodes in sorted order**.
* So the **kth smallest** element is simply the **kth node visited during inorder traversal**.

---

### üíª Code

```cpp
int count = 0;  // Counter for number of nodes visited
int result = -1;  // To store the kth smallest value

void inOrder(TreeNode* root, int k) {
    if (root == NULL) return;

    inOrder(root->left, k);  // Traverse left

    count++;
    if (count == k) {
        result = root->val;  // Found kth smallest
        return;
    }

    inOrder(root->right, k); // Traverse right
}

int kthSmallest(TreeNode* root, int k) {
    inOrder(root, k);
    return result;
}
```

---

### ‚öôÔ∏è How It Works

For BST:

```
        5
       / \
      3   7
     / \   \
    2   4   8
```

**Inorder:** [2, 3, 4, 5, 7, 8]

* `k = 3` ‚Üí 3rd smallest = **4**

---

### ‚è±Ô∏è Time & Space Complexity

| Aspect | Complexity                               |
| ------ | ---------------------------------------- |
| Time   | O(k) on average                          |
| Space  | O(h) recursion stack (h = height of BST) |

---

Now, what if you want **O(1) space traversal** (no stack/recursion)?
üëâ That‚Äôs where **Morris Traversal** comes in.

---

## ‚öôÔ∏è 2. Morris Inorder Traversal

---

### üí° Idea

Morris traversal allows us to **traverse a tree without recursion or stack**, using **threaded binary trees**.

We temporarily **create a link** (thread) from the **rightmost node of the left subtree** to the **current node**.

Then, we traverse back using that thread instead of recursion.

---

### üß© Steps

1. Start from `current = root`.
2. If `current->left` is `NULL`:
   ‚Üí Visit `current` and move to `current->right`.
3. Else:

   * Find `rightMost` node in left subtree (predecessor).
   * If `rightMost->right == NULL`:
     ‚Üí Create temporary link: `rightMost->right = current`, move `current = current->left`.
   * Else (link exists):
     ‚Üí Remove link, visit `current`, and move `current = current->right`.

---

### üíª Code

```cpp
void morrisInOrderTraversal(TreeNode* root) {
    TreeNode* current = root;

    while (current != NULL) {
        if (current->left == NULL) {
            cout << current->val << " ";
            current = current->right;
        } else {
            TreeNode* rightMost_of_curr_L = current->left;

            // Find the rightmost node of current's left subtree
            while (rightMost_of_curr_L->right != NULL &&
                   rightMost_of_curr_L->right != current) {
                rightMost_of_curr_L = rightMost_of_curr_L->right;
            }

            if (rightMost_of_curr_L->right == NULL) {
                // Make a temporary thread
                rightMost_of_curr_L->right = current;
                current = current->left;
            } else {
                // Remove the thread and visit node
                rightMost_of_curr_L->right = NULL;
                cout << current->val << " ";
                current = current->right;
            }
        }
    }
}
```

---

### üß† Visualization

For node `5`:

```
Before threading:
     5
    /
   3
    \
     4

We connect 4->right = 5 temporarily
```

---

### ‚úÖ Properties

* **No recursion**
* **No extra stack**
* **Restores tree structure** (temporary links removed)

---

### ‚è±Ô∏è Complexity

| Aspect | Complexity                       |
| ------ | -------------------------------- |
| Time   | O(N)                             |
| Space  | **O(1)** (no recursion or stack) |

---

## üå≥ 3. Morris Preorder Traversal

---

### üí° Difference from Inorder

In **Inorder Morris**, we print the node **after** visiting the left subtree.
In **Preorder Morris**, we print the node **before** visiting the left subtree.

---

### üíª Code

```cpp
void morrisPreOrderTraversal(TreeNode* root) {
    TreeNode* current = root;

    while (current != NULL) {
        if (current->left == NULL) {
            cout << current->val << " ";
            current = current->right;
        } else {
            TreeNode* rightMost_of_curr_L = current->left;

            while (rightMost_of_curr_L->right != NULL &&
                   rightMost_of_curr_L->right != current) {
                rightMost_of_curr_L = rightMost_of_curr_L->right;
            }

            if (rightMost_of_curr_L->right == NULL) {
                cout << current->val << " ";  // Visit before creating link
                rightMost_of_curr_L->right = current;
                current = current->left;
            } else {
                rightMost_of_curr_L->right = NULL;
                current = current->right;
            }
        }
    }
}
```

---

### üß© Example

For BST:

```
        5
       / \
      3   7
```

**Preorder output:** 5 3 7 ‚úÖ

---

### üß† Time & Space

| Aspect | Complexity |
| ------ | ---------- |
| Time   | O(N)       |
| Space  | O(1)       |

---

## ‚öîÔ∏è Summary Comparison

| Traversal               | Order     | When to Print           | Space | Notes                 |
| ----------------------- | --------- | ----------------------- | ----- | --------------------- |
| **Inorder (Recursive)** | L ‚Üí N ‚Üí R | After left              | O(h)  | Uses stack/recursion  |
| **Morris Inorder**      | L ‚Üí N ‚Üí R | After left              | O(1)  | Threading             |
| **Morris Preorder**     | N ‚Üí L ‚Üí R | Before left             | O(1)  | Threading             |
| **Kth Smallest**        | L ‚Üí N ‚Üí R | Check when `count == k` | O(h)  | Sorted order property |

---

## 1Ô∏è‚É£ Path from Root to a Node

Sometimes, to solve LCA or path-related problems, we first need a **path from root to a target node**.

### üí° Idea

* Traverse recursively.
* Add current node to the path.
* If target found, return `true`.
* If target not in left or right subtree, backtrack (`pop` the node).

### üíª Code

```cpp
bool getPath(TreeNode* root, vector<int>& path, int target) {
    if (root == NULL) return false;

    path.push_back(root->val); // Add current node

    if (root->val == target) return true; // Found target

    // Recur for left or right
    if (getPath(root->left, path, target) || getPath(root->right, path, target)) {
        return true;
    }

    path.pop_back(); // Backtrack if target not found
    return false;
}
```

**Example:**

Tree:

```
        5
       / \
      3   7
     / \
    2   4
```

`target = 4` ‚Üí path = `[5, 3, 4]`

---

## 2Ô∏è‚É£ Lowest Common Ancestor (General Binary Tree)

We have **two approaches**.

---

### **Solution 1: Using Paths**

1. Find path from root to `p` and root to `q`.
2. Compare paths node by node.
3. Last common node is the **LCA**.

### üíª Code

```cpp
bool findPath(TreeNode* root, TreeNode* target, vector<TreeNode*>& path) {
    if (!root) return false;
    
    path.push_back(root); // Add current node
    
    if (root == target) return true; // Found target
    
    if (findPath(root->left, target, path) || findPath(root->right, target, path)) {
        return true;
    }

    path.pop_back(); // Backtrack
    return false;
}

TreeNode* findLCA(TreeNode* root, TreeNode* p, TreeNode* q) {
    vector<TreeNode*> path1, path2;

    if (!findPath(root, p, path1) || !findPath(root, q, path2)) {
        return NULL; // If either node not present
    }

    int i;
    for (i = 0; i < path1.size() && i < path2.size(); i++) {
        if (path1[i] != path2[i]) break;
    }

    return path1[i-1]; // Last common node
}
```

---

### **Solution 2: Recursive Traversal (Optimized)**

1. Base case: `root == NULL` or `root == p` or `root == q` ‚Üí return `root`.
2. Recur for left and right subtrees.
3. If left and right are both non-NULL ‚Üí `root` is LCA.
4. Else return the non-NULL child.

### üíª Code

```cpp
TreeNode* findLCA(TreeNode* root, TreeNode* p, TreeNode* q) {
    if (!root || root == p || root == q) return root;

    TreeNode* left = findLCA(root->left, p, q);
    TreeNode* right = findLCA(root->right, p, q);

    if (left && right) return root; // Nodes found in different branches
    return left ? left : right;     // Return the non-null node
}
```

‚úÖ **Complexity:**

* Time: O(N)
* Space: O(h) recursion stack (h = tree height)

---

## 3Ô∏è‚É£ LCA in a Binary Search Tree (BST)

BST property simplifies LCA:

1. If both nodes < root ‚Üí go left.
2. If both nodes > root ‚Üí go right.
3. Else ‚Üí root is the LCA.

### üíª Code

```cpp
TreeNode* findLCA_BST(TreeNode* root, TreeNode* p, TreeNode* q) {
    while (root) {
        if (p->val < root->val && q->val < root->val) {
            root = root->left; // Both on left
        } else if (p->val > root->val && q->val > root->val) {
            root = root->right; // Both on right
        } else {
            return root; // Split point found
        }
    }
    return NULL;
}
```

---

### Example

BST:

```
        20
       /  \
     10    30
    /  \
   5   15
```

* `p=5, q=15` ‚Üí LCA = 10
* `p=5, q=30` ‚Üí LCA = 20

---

### ‚úÖ Summary

| Problem           | Method      | Time | Space |
| ----------------- | ----------- | ---- | ----- |
| LCA (Binary Tree) | Using Paths | O(N) | O(N)  |
| LCA (Binary Tree) | Recursive   | O(N) | O(h)  |
| LCA (BST)         | Iterative   | O(h) | O(1)  |

---
# Tree Questions
---
## 1Ô∏è‚É£ Maximum Depth of a Binary Tree

**Goal:** Find the longest path from root to any leaf.

**Idea:**

* Recursively find the depth of the left and right subtrees.
* Maximum depth = `1 + max(leftDepth, rightDepth)`.
* Base case: empty tree ‚Üí depth = 0.

**Code:**

```cpp
int maxDepth(TreeNode* root) {
    if (root == NULL) return 0; // Empty tree has depth 0

    int leftDepth = maxDepth(root->left);
    int rightDepth = maxDepth(root->right);

    return 1 + max(leftDepth, rightDepth);
}
```

**Example:**

```
      1
     / \
    2   3
   / 
  4
```

* maxDepth = 3 (path 1 ‚Üí 2 ‚Üí 4)

---

## 2Ô∏è‚É£ Check for Balanced Binary Tree

**Goal:** A tree is **balanced** if the heights of left and right subtrees differ by ‚â§ 1 for all nodes.

**Idea:**

* Use a helper function to check height recursively.
* If subtree is unbalanced ‚Üí return -1.
* If balanced ‚Üí return height.

**Code:**

```cpp
int checkHeight(TreeNode* root) {
    if (root == NULL) return 0;

    int leftHeight = checkHeight(root->left);
    if (leftHeight == -1) return -1; // Left subtree unbalanced

    int rightHeight = checkHeight(root->right);
    if (rightHeight == -1) return -1; // Right subtree unbalanced

    if (abs(leftHeight - rightHeight) > 1) return -1; // Current node unbalanced

    return 1 + max(leftHeight, rightHeight);
}

bool isBalanced(TreeNode* root) {
    return checkHeight(root) != -1;
}
```

**Example:**

* Balanced:

```
    1
   / \
  2   3
```

* Not balanced:

```
    1
   /
  2
 /
3
```

---

## 3Ô∏è‚É£ Diameter of Binary Tree

**Goal:** Maximum number of nodes/edges in the longest path between **any two nodes**.

**Idea:**

* Use recursion to compute height.
* At each node, diameter can be `leftHeight + rightHeight`.
* Track maximum globally.

**Code:**

```cpp
int height(TreeNode* node, int &diameter) {
    if (!node) return 0;

    int leftHeight = height(node->left, diameter);
    int rightHeight = height(node->right, diameter);

    diameter = max(diameter, leftHeight + rightHeight); // Update diameter

    return 1 + max(leftHeight, rightHeight); // Return height
}

int diameterOfBinaryTree(TreeNode* root) {
    int diameter = 0;
    height(root, diameter);
    return diameter;
}
```

**Example:**

```
      1
     / \
    2   3
   / \
  4   5
```

* Diameter = 4 (path: 4 ‚Üí 2 ‚Üí 1 ‚Üí 3)

---

## 4Ô∏è‚É£ Maximum Path Sum

**Goal:** Maximum sum of values along **any path** (path can start and end anywhere).

**Idea:**

* Recursive function returns **maximum path sum ending at current node**.
* Track **global maxSum** including paths that pass through current node.
* Ignore negative sums ‚Üí `max(0, sum)`.

**Code:**

```cpp
int maxPathDown(TreeNode* node, int &maxSum) {
    if (!node) return 0;

    int left = max(0, maxPathDown(node->left, maxSum));
    int right = max(0, maxPathDown(node->right, maxSum));

    maxSum = max(maxSum, left + right + node->val); // Update global max

    return max(left, right) + node->val; // Return max path sum for parent
}

int maxPathSum(TreeNode* root) {
    int maxSum = INT_MIN;
    maxPathDown(root, maxSum);
    return maxSum;
}
```

**Example:**

```
       1
      / \
     2   3
```

* Maximum path sum = 2 + 1 + 3 = 6

---

## 5Ô∏è‚É£ Check if Two Binary Trees are Identical

**Goal:** Two trees are **identical** if:

1. Same structure
2. Same node values

**Idea:**

* Recursively check current node value + left + right.

**Code:**

```cpp
bool isIdentical(TreeNode* root1, TreeNode* root2) {
    if (!root1 && !root2) return true;   // Both empty
    if (!root1 || !root2) return false;  // One empty

    return (root1->val == root2->val) &&
           isIdentical(root1->left, root2->left) &&
           isIdentical(root1->right, root2->right);
}
```

**Example:**
Tree1:

```
    1
   / \
  2   3
```

Tree2:

```
    1
   / \
  2   3
```

* Identical ‚Üí true

Tree3:

```
    1
   / \
  3   2
```

* Not identical ‚Üí false

---

### ‚úÖ Summary Table

| Problem         | Technique                  | Complexity |
| --------------- | -------------------------- | ---------- |
| Max Depth       | Recursion                  | O(N)       |
| Balanced Tree   | Recursion + height check   | O(N)       |
| Diameter        | Recursion + global tracker | O(N)       |
| Max Path Sum    | Recursion + global tracker | O(N)       |
| Identical Trees | Recursion                  | O(N)       |

---

## 1Ô∏è‚É£ ZigZag Level Order Traversal (Spiral Order)

**Goal:** Traverse level by level, but alternate direction for each level.

**Idea:**

* Use a `queue` for level-order traversal.
* Use a `deque` to insert values at **front or back** depending on direction.
* Toggle direction after each level.

**Code:**

```cpp
vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
    vector<vector<int>> result;
    if (!root) return result;

    queue<TreeNode*> q;
    q.push(root);
    bool leftToRight = true;

    while (!q.empty()) {
        int levelSize = q.size();
        deque<int> currentLevel;

        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = q.front();
            q.pop();

            if (leftToRight)
                currentLevel.push_back(node->val);
            else
                currentLevel.push_front(node->val);

            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }

        result.push_back(vector<int>(currentLevel.begin(), currentLevel.end()));
        leftToRight = !leftToRight; // Toggle direction
    }

    return result;
}
```

**Example:**

```
       1
     /   \
    2     3
   / \   / \
  4  5  6  7
```

* Output: `[ [1], [3,2], [4,5,6,7] ]`

---

## 2Ô∏è‚É£ Boundary Traversal of Binary Tree

**Goal:** Print all nodes on the **boundary** of the tree:

1. Left boundary (excluding leaf)
2. Leaf nodes (left ‚Üí right)
3. Right boundary (excluding leaf, reversed)

**Idea:** Separate traversal functions:

* Left boundary: always go left, fallback to right.
* Leaf nodes: recurse both subtrees.
* Right boundary: go right, fallback to left, store in temp and reverse.

**Code Skeleton:**

```cpp
vector<int> boundaryTraversal(TreeNode* root) {
    vector<int> result;
    if (!root) return result;

    result.push_back(root->val);

    if (root->left) addLeftBoundary(root, result);
    addLeafNodes(root, result);
    if (root->right) addRightBoundary(root, result);

    return result;
}
```

* Helper functions: `addLeftBoundary`, `addLeafNodes`, `addRightBoundary` (as you wrote).

---

## 3Ô∏è‚É£ Symmetric Binary Tree

**Goal:** Tree is symmetric if left subtree is a mirror of right subtree.

**Idea:**

* Recursively check:

  * `left->val == right->val`
  * `left->left` mirrors `right->right`
  * `left->right` mirrors `right->left`

**Code:**

```cpp
bool isSymmetric(TreeNode* left, TreeNode* right) {
    if (!left && !right) return true;
    if (!left || !right) return false;

    return left->val == right->val &&
           isSymmetric(left->left, right->right) &&
           isSymmetric(left->right, right->left);
}

bool isSymmetric(TreeNode* root) {
    if (!root) return true;
    return isSymmetric(root->left, root->right);
}
```

---

## 4Ô∏è‚É£ Maximum Width of Binary Tree

**Goal:** Maximum number of nodes in any level.

**Idea:**

* BFS with `queue<pair<TreeNode*, position>>`
* Track positions to calculate width: `width = last - first + 1`
* Use `unsigned long long` to avoid overflow.

**Code:**

```cpp
int widthOfBinaryTree(TreeNode* root) {
    if (!root) return 0;

    int maxWidth = 0;
    queue<pair<TreeNode*, unsigned long long>> q;
    q.push({root, 0});

    while (!q.empty()) {
        int levelSize = q.size();
        unsigned long long start = q.front().second;
        unsigned long long end = q.back().second;

        maxWidth = max(maxWidth, (int)(end - start + 1));

        for (int i = 0; i < levelSize; i++) {
            auto [node, pos] = q.front(); q.pop();
            unsigned long long newPos = pos - start;

            if (node->left) q.push({node->left, 2 * newPos + 1});
            if (node->right) q.push({node->right, 2 * newPos + 2});
        }
    }

    return maxWidth;
}
```

---

## 5Ô∏è‚É£ Children Sum Property

**Check Property:**

* Each node‚Äôs value = sum of its children (leaf nodes ignored).

```cpp
bool isChildrenSum(TreeNode* root) {
    if (!root) return true;
    if (!root->left && !root->right) return true;

    int leftVal = root->left ? root->left->val : 0;
    int rightVal = root->right ? root->right->val : 0;

    return root->val == leftVal + rightVal &&
           isChildrenSum(root->left) &&
           isChildrenSum(root->right);
}
```

**Convert Tree to Children Sum Property:**

```cpp
void changeTree(BinaryTreeNode<int>* root) {
    if (!root) return;

    int child = 0;
    if (root->left) child += root->left->data;
    if (root->right) child += root->right->data;

    if (child >= root->data)
        root->data = child;
    else {
        if (root->left) root->left->data = root->data;
        else if (root->right) root->right->data = root->data;
    }

    changeTree(root->left);
    changeTree(root->right);

    int tot = 0;
    if (root->left) tot += root->left->data;
    if (root->right) tot += root->right->data;
    if (root->left || root->right) root->data = tot;
}
```

**Idea:**

* Traverse tree top-down.
* Adjust child or parent to satisfy sum property.
* Then adjust bottom-up to finalize parent value.

---

