# Tree

---

## 🌳 1. What Is a Tree?

A **tree** is a **non-linear hierarchical data structure** made up of **nodes**, connected by **edges**.

It is used to represent data that has a **hierarchical relationship** — e.g., file systems, family trees, organizational structures, etc.

---

## 🧩 2. Basic Terms

| Term               | Meaning                                                    |
| ------------------ | ---------------------------------------------------------- |
| **Node**           | A single element (contains data and links to other nodes). |
| **Root**           | The topmost node (starting point of the tree).             |
| **Edge**           | A link between a parent and a child node.                  |
| **Parent**         | A node that has child nodes connected below it.            |
| **Child**          | Nodes that descend from another node.                      |
| **Leaf Node**      | Node with **no children**.                                 |
| **Siblings**       | Nodes having the same parent.                              |
| **Height of Tree** | Longest path from root to a leaf.                          |
| **Depth of Node**  | Distance (number of edges) from root to that node.         |
| **Subtree**        | Any node and all its descendants form a subtree.           |

---

## 🧱 3. Tree Structure in C++

In C++, a **tree node** is usually represented using a `struct` or a `class`.

### Example:

```cpp
struct TreeNode {
    int val;                // Value of the node
    TreeNode *left;         // Pointer to left child
    TreeNode *right;        // Pointer to right child

    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

This is the **foundation** — everything else (traversals, insertions, building) is built on top of this.

---

## 🌲 4. Example Tree Visualization

Let’s take an example tree:

```
        1
       / \
      2   3
     / \
    4   5
```

* Root: `1`
* Children of `1`: `2`, `3`
* Children of `2`: `4`, `5`
* Leaf nodes: `3`, `4`, `5`
* Height = 2 (0-based, longest path 1→2→4)

---

## 🧮 5. Types of Trees

1. **General Tree** → Any number of children per node.
2. **Binary Tree** → Each node has at most **2 children** (left, right).
3. **Binary Search Tree (BST)** → Left child < Root < Right child.
4. **Full Binary Tree** → Every node has 0 or 2 children.
5. **Complete Binary Tree** → All levels are filled except possibly the last, which is filled left to right.
6. **Perfect Binary Tree** → All levels completely filled.
7. **Balanced Binary Tree** → Height of left and right subtrees differ by at most 1.

---

## ⚙️ 6. Basic Operations on Trees

| Operation          | Description                                                 |
| ------------------ | ----------------------------------------------------------- |
| **Traversal**      | Visit each node (Preorder, Inorder, Postorder, Level-order) |
| **Insertion**      | Add a new node                                              |
| **Deletion**       | Remove a node                                               |
| **Search**         | Find a node with a given value                              |
| **Height / Depth** | Calculate height or depth of nodes                          |
| **Count**          | Count total nodes or leaf nodes                             |

---

## 📘 7. Simple Example in C++

Here’s a minimal code to create and print a small tree:

```cpp
#include <iostream>
using namespace std;

struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};

int main() {
    // Create nodes
    TreeNode* root = new TreeNode(1);
    root->left = new TreeNode(2);
    root->right = new TreeNode(3);
    root->left->left = new TreeNode(4);
    root->left->right = new TreeNode(5);

    // Example Output
    cout << "Root Node: " << root->val << endl;
    cout << "Left Child of Root: " << root->left->val << endl;
    cout << "Right Child of Root: " << root->right->val << endl;

    return 0;
}
```

🧠 Output:

```
Root Node: 1
Left Child of Root: 2
Right Child of Root: 3
```

---


## 1️⃣ Tree Structure

Every tree node has:

* A **value**
* A **left child**
* A **right child**

```cpp
struct TreeNode {
    int val;
    TreeNode *left;
    TreeNode *right;
    TreeNode(int x) : val(x), left(NULL), right(NULL) {}
};
```

You can visualize it like this:

```
       1
      / \
     2   3
```

Each node is connected to its children via pointers.

---

## 2️⃣ Preorder Traversal

### 🧠 Definition

Visit order →
👉 **Root → Left → Right**

---

### 🧩 Example Tree

```
       1
      / \
     2   3
    / \
   4   5
```

👉 **Preorder Output:** `1 2 4 5 3`

---

### ✅ Recursive Code

```cpp
void preorder(TreeNode* node, vector<int>& result) {
    if (node == NULL) return;

    result.push_back(node->val);        // Visit Root
    preorder(node->left, result);       // Visit Left
    preorder(node->right, result);      // Visit Right
}
```

---

### ⚙️ Iterative Code (Using Stack)

```cpp
void iterativePreorderTraversal(TreeNode* root) {
    if (root == nullptr) return;

    stack<TreeNode*> st;
    st.push(root);

    while (!st.empty()) {
        TreeNode* node = st.top();
        st.pop();

        cout << node->val << " ";  // Visit node

        // Push right first (so left is processed first)
        if (node->right) st.push(node->right);
        if (node->left) st.push(node->left);
    }
}
```

🧠 Think of stack as your recursion manually handled.

---

## 3️⃣ Inorder Traversal

### 🧠 Definition

👉 **Left → Root → Right**

---

### 🧩 Example Tree

```
       1
      / \
     2   3
    / \
   4   5
```

👉 **Inorder Output:** `4 2 5 1 3`

---

### ✅ Recursive Code

```cpp
void inorder(TreeNode* node, vector<int>& result) {
    if (node == NULL) return;

    inorder(node->left, result);
    result.push_back(node->val);
    inorder(node->right, result);
}
```

---

### ⚙️ Iterative Code (Using Stack)

```cpp
void iterativeInorderTraversal(TreeNode* root) {
    stack<TreeNode*> st;
    TreeNode* curr = root;

    while (curr != nullptr || !st.empty()) {
        while (curr != nullptr) {
            st.push(curr);
            curr = curr->left;  // Move left as far as possible
        }

        curr = st.top(); st.pop();
        cout << curr->val << " ";  // Visit node
        curr = curr->right;        // Now move right
    }
}
```

🧠 Here, stack keeps track of nodes whose right subtrees are not yet visited.

---

## 4️⃣ Postorder Traversal

### 🧠 Definition

👉 **Left → Right → Root**

---

### 🧩 Example Tree

```
       1
      / \
     2   3
    / \
   4   5
```

👉 **Postorder Output:** `4 5 2 3 1`

---

### ✅ Recursive Code

```cpp
void postorder(TreeNode* node, vector<int>& result) {
    if (node == NULL) return;

    postorder(node->left, result);
    postorder(node->right, result);
    result.push_back(node->val);
}
```

---

### ⚙️ Iterative Code (Using Two Stacks)

```cpp
void iterativePostorderTraversal(TreeNode* root) {
    if (!root) return;

    stack<TreeNode*> st1, st2;
    st1.push(root);

    while (!st1.empty()) {
        TreeNode* node = st1.top(); st1.pop();
        st2.push(node);

        if (node->left) st1.push(node->left);
        if (node->right) st1.push(node->right);
    }

    while (!st2.empty()) {
        cout << st2.top()->val << " ";
        st2.pop();
    }
}
```

🧠 Stack2 stores nodes in reverse order of “Root → Right → Left”,
so popping gives “Left → Right → Root”.

---

## 5️⃣ Build Binary Tree from Traversals

---

### 🧩 A. From **Inorder + Postorder**

**Idea:**

* Last element in **postorder** = root.
* Find root index in **inorder** → left of it = left subtree, right = right subtree.

```cpp
TreeNode* buildTreeHelper(vector<int>& inorder, vector<int>& postorder,
                          int inStart, int inEnd, int& postIndex,
                          unordered_map<int, int>& inMap) {
    if (inStart > inEnd) return NULL;

    int rootVal = postorder[postIndex--];
    TreeNode* root = new TreeNode(rootVal);

    int inIndex = inMap[rootVal];

    // Build right before left because postorder = Left Right Root
    root->right = buildTreeHelper(inorder, postorder, inIndex + 1, inEnd, postIndex, inMap);
    root->left = buildTreeHelper(inorder, postorder, inStart, inIndex - 1, postIndex, inMap);

    return root;
}

TreeNode* buildTree(vector<int> &inorder, vector<int> &postorder) {
    unordered_map<int, int> inMap;
    for (int i = 0; i < inorder.size(); i++)
        inMap[inorder[i]] = i;

    int postIndex = postorder.size() - 1;
    return buildTreeHelper(inorder, postorder, 0, inorder.size() - 1, postIndex, inMap);
}
```

---

### 🧩 B. From **Inorder + Preorder**

**Idea:**

* First element in **preorder** = root.
* Find root index in **inorder** → left part = left subtree, right = right subtree.

```cpp
TreeNode* buildTreeHelper(const vector<int>& preorder, int preStart, int preEnd,
                          const vector<int>& inorder, int inStart, int inEnd,
                          unordered_map<int, int>& inMap) {
    if (preStart > preEnd || inStart > inEnd) return nullptr;

    int rootVal = preorder[preStart];
    TreeNode* root = new TreeNode(rootVal);

    int inRoot = inMap[rootVal];
    int leftSize = inRoot - inStart;

    root->left = buildTreeHelper(preorder, preStart + 1, preStart + leftSize,
                                 inorder, inStart, inRoot - 1, inMap);

    root->right = buildTreeHelper(preorder, preStart + leftSize + 1, preEnd,
                                  inorder, inRoot + 1, inEnd, inMap);

    return root;
}

TreeNode* buildTree(const vector<int>& preorder, const vector<int>& inorder) {
    unordered_map<int, int> inMap;
    for (int i = 0; i < inorder.size(); ++i)
        inMap[inorder[i]] = i;

    return buildTreeHelper(preorder, 0, preorder.size() - 1,
                           inorder, 0, inorder.size() - 1, inMap);
}
```

---

## 🧠 Summary Table

| Traversal       | Order               | Common Use                           |
| --------------- | ------------------- | ------------------------------------ |
| **Preorder**    | Root → Left → Right | Copying tree / Serialization         |
| **Inorder**     | Left → Root → Right | BST property check / Sorted output   |
| **Postorder**   | Left → Right → Root | Deleting tree / Evaluate expressions |
| **Level Order** | Level by level      | BFS traversal                        |

---

# 🌲 Level Order, Views & Vertical Traversals — Step-by-Step

---

## 🧩 1️⃣ Level Order Traversal (Breadth-First Search)

### 🔹 Concept:

We visit nodes **level by level**, left to right.

Example:

```
        1
      /   \
     2     3
    / \     \
   4   5     6
```

Output:
`[[1], [2, 3], [4, 5, 6]]`

---

### ✅ Code

```cpp
vector<vector<int>> levelOrder(TreeNode* root) {
    vector<vector<int>> result;
    if (!root) return result;

    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        int levelSize = q.size();
        vector<int> level;

        for (int i = 0; i < levelSize; i++) {
            TreeNode* node = q.front(); q.pop();
            level.push_back(node->val);

            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
        result.push_back(level);
    }
    return result;
}
```

---

## 🧩 2️⃣ Right View of a Binary Tree

### 🔹 Concept:

When you look at the tree from the **right side**,
you only see the **rightmost node** of each level.

Example:

```
        1
      /   \
     2     3
      \     \
       5     4
```

Right View: `[1, 3, 4]`

---

### ✅ Code

```cpp
vector<int> rightView(TreeNode* root) {
    vector<int> result;
    if (!root) return result;

    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            TreeNode* node = q.front(); q.pop();

            if (i == size - 1) result.push_back(node->val); // rightmost element

            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
    }
    return result;
}
```

---

## 🧩 3️⃣ Left View of a Binary Tree

### 🔹 Concept:

When viewed from the **left side**,
we see only the **first node** of each level.

Example:

```
        1
      /   \
     2     3
    /       \
   4         6
```

Left View: `[1, 2, 4]`

---

### ✅ Code

```cpp
vector<int> leftView(TreeNode* root) {
    vector<int> result;
    if (!root) return result;

    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        int size = q.size();
        for (int i = 0; i < size; i++) {
            TreeNode* node = q.front(); q.pop();

            if (i == 0) result.push_back(node->val); // leftmost element

            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }
    }
    return result;
}
```

---

## 🧩 4️⃣ Vertical Order Traversal

### 🔹 Concept:

Imagine vertical “lines” passing through the tree.
We group nodes by **horizontal distance (HD)** from the root:

* Root = HD 0
* Left child = HD -1
* Right child = HD +1

Example:

```
        1
      /   \
     2     3
    / \   / \
   4  5  6  7
```

Vertical Order:

```
HD -2: [4]
HD -1: [2]
HD  0: [1, 5, 6]
HD +1: [3]
HD +2: [7]
```

Output:
`[[4], [2], [1,5,6], [3], [7]]`

---

### ✅ Code

```cpp
vector<vector<int>> verticalOrder(TreeNode* root) {
    vector<vector<int>> result;
    if (!root) return result;

    map<int, vector<int>> nodes;  // (HD → nodes)
    queue<pair<TreeNode*, int>> q;

    q.push({root, 0});

    while (!q.empty()) {
        auto [node, hd] = q.front(); q.pop();
        nodes[hd].push_back(node->val);

        if (node->left) q.push({node->left, hd - 1});
        if (node->right) q.push({node->right, hd + 1});
    }

    for (auto& [hd, vals] : nodes)
        result.push_back(vals);

    return result;
}
```

---

## 🧩 5️⃣ Top View

### 🔹 Concept:

When you look at the tree from the **top**,
you only see the **first node** encountered at each vertical line (HD).

```
        1
      /   \
     2     3
      \   /
       4 5
```

Top View: `[2, 1, 3]`

---

### ✅ Code

```cpp
vector<int> topView(TreeNode* root) {
    vector<int> result;
    if (!root) return result;

    map<int, int> top;
    queue<pair<TreeNode*, int>> q;
    q.push({root, 0});

    while (!q.empty()) {
        auto [node, hd] = q.front(); q.pop();

        if (top.find(hd) == top.end())  // only first time for this HD
            top[hd] = node->val;

        if (node->left) q.push({node->left, hd - 1});
        if (node->right) q.push({node->right, hd + 1});
    }

    for (auto& [hd, val] : top)
        result.push_back(val);

    return result;
}
```

---

## 🧩 6️⃣ Bottom View

### 🔹 Concept:

When you look from **below**,
you see the **last node** at each vertical line (HD).

```
        1
      /   \
     2     3
      \   /
       4 5
```

Bottom View: `[4, 2, 5, 3]`

---

### ✅ Code

```cpp
vector<int> bottomView(TreeNode* root) {
    vector<int> result;
    if (!root) return result;

    map<int, int> bottom;
    queue<pair<TreeNode*, int>> q;
    q.push({root, 0});

    while (!q.empty()) {
        auto [node, hd] = q.front(); q.pop();

        // override each time — last node at this HD will remain
        bottom[hd] = node->val;

        if (node->left) q.push({node->left, hd - 1});
        if (node->right) q.push({node->right, hd + 1});
    }

    for (auto& [hd, val] : bottom)
        result.push_back(val);

    return result;
}
```

---

## 🧠 Summary Table

| View / Traversal   | Uses BFS / DFS | Key Logic                    | Notes                   |
| ------------------ | -------------- | ---------------------------- | ----------------------- |
| **Level Order**    | BFS (Queue)    | Process each level           | Base for other views    |
| **Right View**     | BFS            | Last node at each level      | See from right side     |
| **Left View**      | BFS            | First node at each level     | See from left side      |
| **Vertical Order** | BFS            | Group by horizontal distance | `map<int, vector<int>>` |
| **Top View**       | BFS            | First node for each HD       | Use map if empty        |
| **Bottom View**    | BFS            | Last node for each HD        | Always override         |

---

## 🌲 1️⃣ Find the Height of a Perfect Binary Tree

### 🧠 Concept

* Height = the **number of nodes** on the longest path from the root to a leaf.
* For a **perfect binary tree** (all levels filled):

  * If there are `n` nodes, height = `log₂(n + 1) - 1`
  * But usually, we calculate recursively.

### 💻 Code (Recursive)

```cpp
int height(TreeNode* root) {
    if (!root) return 0;  // base case: height of empty tree is 0
    int leftHeight = height(root->left);
    int rightHeight = height(root->right);
    return 1 + max(leftHeight, rightHeight);
}
```

### 🔍 Example

For:

```
        1
       / \
      2   3
     / \
    4   5
```

➡ height = 3

---

## 🌳 2️⃣ Check if a Binary Tree is Balanced

### 🧠 Concept

A tree is **balanced** if the height difference between **left and right subtrees ≤ 1** for every node.

We use a **bottom-up approach** — if any subtree is unbalanced, return `-1` immediately (to save time).

### 💻 Code

```cpp
int checkBalance(TreeNode* node) {
    if (!node) return 0;

    int leftDepth = checkBalance(node->left);
    if (leftDepth == -1) return -1;

    int rightDepth = checkBalance(node->right);
    if (rightDepth == -1) return -1;

    if (abs(leftDepth - rightDepth) > 1) return -1;

    return 1 + max(leftDepth, rightDepth);
}

bool isBalanced(TreeNode* root) {
    return checkBalance(root) != -1;
}
```

### ✅ Example

```
        1
       / \
      2   3
     /
    4
```

➡ Balanced ✅
If you add a left child to 4 (making it too deep), it becomes unbalanced ❌

---

## 🔁 3️⃣ Zigzag Level Order Traversal

### 🧠 Concept

Similar to level order traversal, but alternate direction each level:

* Left → Right on one level
* Right → Left on the next

### 💻 Code

```cpp
vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
    vector<vector<int>> result;
    if (!root) return result;

    queue<TreeNode*> q;
    q.push(root);
    bool leftToRight = true;

    while (!q.empty()) {
        int size = q.size();
        vector<int> level(size);

        for (int i = 0; i < size; i++) {
            TreeNode* node = q.front();
            q.pop();

            int index = leftToRight ? i : size - i - 1;
            level[index] = node->val;

            if (node->left) q.push(node->left);
            if (node->right) q.push(node->right);
        }

        result.push_back(level);
        leftToRight = !leftToRight;  // toggle direction
    }

    return result;
}
```

### 🔍 Example

```
        1
       / \
      2   3
     / \   \
    4   5   6
```

➡ Output: `[[1], [3, 2], [4, 5, 6]]`

---

## 🧩 4️⃣ Serialize a Binary Tree

### 🧠 Concept

Serialization = Convert tree → string/vector form
We’ll use **level order traversal (BFS)** and mark `NULL` nodes as `"null"`.

### 💻 Code

```cpp
string serialize(TreeNode* root) {
    if (!root) return "";

    queue<TreeNode*> q;
    q.push(root);
    string result = "";

    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();

        if (node) {
            result += to_string(node->val) + ",";
            q.push(node->left);
            q.push(node->right);
        } else {
            result += "null,";
        }
    }

    return result;
}
```

### 🧠 Example

```
        1
       / \
      2   3
         / \
        4   5
```

➡ Serialized: `"1,2,3,null,null,4,5,null,null,null,null,"`

---

## 🔄 5️⃣ Deserialize a Binary Tree

### 🧠 Concept

Reverse of serialization — build the tree using BFS.

### 💻 Code

```cpp
TreeNode* deserialize(string data) {
    if (data.empty()) return nullptr;

    stringstream ss(data);
    string value;
    getline(ss, value, ',');
    TreeNode* root = new TreeNode(stoi(value));

    queue<TreeNode*> q;
    q.push(root);

    while (!q.empty()) {
        TreeNode* node = q.front();
        q.pop();

        // Left child
        if (getline(ss, value, ',')) {
            if (value != "null") {
                node->left = new TreeNode(stoi(value));
                q.push(node->left);
            }
        }

        // Right child
        if (getline(ss, value, ',')) {
            if (value != "null") {
                node->right = new TreeNode(stoi(value));
                q.push(node->right);
            }
        }
    }

    return root;
}
```

---

## ✅ Summary Table

| Task        | Approach               | Key Idea                          |
| ----------- | ---------------------- | --------------------------------- |
| Height      | Recursion              | max(left, right) + 1              |
| Balanced    | DFS + Early Exit       | Return -1 if unbalanced           |
| Zigzag      | BFS + Direction toggle | Use queue and alternate direction |
| Serialize   | BFS                    | Save “null” for missing nodes     |
| Deserialize | BFS                    | Rebuild using queue               |

---

