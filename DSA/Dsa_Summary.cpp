// Debugging
    ## Debugging ARRAY ##
    for(int i=0; i<ocupied_seats.size(); i++){ cout<< ", "<<ocupied_seats[i]<<" ";}

// Cpp 
    using namespace std;
    int min = INT_MAX;
    int max = INT_MIN;

// Pointers //
    1. Pointer Declaration: A pointer is declared by placing an asterisk * in front of the variable name.
    2. Dereferencing: Using the * operator, you can access or modify the value at the memory address that the pointer holds.
    3. Address-of Operator (&): This operator is used to get the memory address of a variable.
        int a = 10;    // Declare an integer variable
        int* p;        // Declare a pointer to an integer
        p = &a;        // Store the address of 'a' in the pointer 'p'
        cout << "Value of a: " << a << endl;         // Prints: 10
        cout << "Address of a: " << &a << endl;      // Prints the memory address of 'a'
        cout << "Pointer p holds address: " << p << endl;  // Prints the address stored in p
        cout << "Value at address held by p: " << *p << endl; // Dereferencing p, prints: 10
        // Modifying the value via the pointer
        *p = 20;
        cout << "New value of a: " << a << endl;           // Output: 20

        // In C++, the name of an array is essentially a pointer to its first element.
            int arr[3] = {10, 20, 30};
            int* p = arr;  // p points to arr[0]
            cout << *p << endl;   // Output: 10
            p++;
            cout << *p << endl;   // Output: 20

// pass arguments to a function //
    ## Pass by Value
        Use pass by value when you don''t want the function to modify the original variable.
        When you pass an argument by value, the function creates a copy of the actual arguments value. Any changes made to the parameter inside the function do not affect the original argument.
            void myFunction(int x) {
                x = x + 10;  // This changes only the local copy of x
            }
            int main() {
                int num = 5;
                myFunction(num);  // Passing by value
                cout << num;  // Output: 5 (num remains unchanged)
            }
    ## Pass by Reference
        Use pass by reference when you want the function to modify the original variable without copying.
        When you pass an argument by reference, the function receives a reference (or alias) to the actual argument. Any changes made to the parameter affect the original argument.
            void myFunction(int &x) {
                x = x + 10;  // This changes the original value of x
            }
            int main() {
                int num = 5;
                myFunction(num);  // Passing by reference
                cout << num;  // Output: 15 (num is changed)
            }
    ## Pass by Pointer
        Use pass by pointer when you need to work with memory addresses or when multiple values need to be changed.
        When you pass an argument by pointer, the function receives the memory address of the argument. Inside the function, you dereference the pointer to access or modify the actual data.
            void myFunction(int *x) {
                *x = *x + 10;  // Dereferencing the pointer to change the value at the address
            }
            int main() {
                int num = 5;
                myFunction(&num);  // Passing by pointer (passing the address of num)
                cout << num;  // Output: 15 (num is changed)
            }
// Struct (Structure) //
    In C++, a struct (short for structure) is a user-defined data type that allows you to group together variables of different types under a single name. It is similar to a class, but by default, its members (variables and methods) are public rather than private.

    // Define a struct for a point in 2D space
    struct Point {
        int x;  // x-coordinate
        int y;  // y-coordinate

        // A method to print the point's coordinates
        void printPoint() {
            cout << "(" << x << ", " << y << ")" << endl;
        }
    };

    int main() {
        // Declare a Point object
        Point p1;

        // Assign values to the members of the struct
        p1.x = 10;
        p1.y = 20;

        // Access the members and print them
        cout << "Point coordinates are: ";
        p1.printPoint();

        return 0;
    }
---------------------------------------------------------------------------------------------------------------
// Introduction to Problem Solving
// Time Complexity
---------------------------------------------------------------------------------------------------------------
//######################
//## UNIT 1 ##
//###################### 
---------------------------------------------------------------------------------------------------------------
// Arrays
## Required Syntax ##
    ## Arrays ##
        ## Static Arrays ##
            int numbers[5];
            int numbers[5] = {1, 2, 3, 4, 5};

            numbers[0]; // Output: 1 
            numbers[2]; // Output: 3

            // Replacing an existing element
            numbers[2] = 35; // Change third element from 30 to 35

            // Calculate the length of the array
            int length = sizeof(numbers) / sizeof(numbers[0]);

            // Iterating through the array using the calculated length
            for (int i = 0; i < length; i++) {
                std::cout << numbers[i] << " "; // Output: 10 20 30 40 50
            }

            // Removing the Element
            int numbers[5] = {10, 20, 30, 40, 50};
            int size = 5; // Current size of the array

            // Removing the element at index 2 (30)
            for (int i = 2; i < size - 1; i++) {
                numbers[i] = numbers[i + 1]; // Shift elements left
            }
            size--; // Decrease the logical size of the array

            // Printing the array after removal
            for (int i = 0; i < size; i++) {
                std::cout << numbers[i] << " "; // Output: 10 20 40 50
            }
            
        ## Dynamic Arrays ##
    ## Vectors ##
        // INCLUDE
        #include <vector>

        // Declaration of a vector & Initialization with values
        std::vector<int> numbers; 
        std::vector<int> numbers = {1, 2, 3, 4, 5};
        vector<long> numbers(A.size()); 
        vector<long> numbers(A.size(), 0);

        // adding elements
        numbers[0] = 4;
        numbers.push_back(6);
        
        // remove the ith element
            numbers.erase(numbers.begin() + i);
        // removing last element
            numbers.pop_back();
            
        // to Empty
        numbers.clear();
        // Accessing elements
        int first = numbers[0];
        int second = numbers.at(1);

        // find length
        int N = numbers.size();

        // Iterating through the vector
        for (int i = 0; i < N;i++) {
            std::cout << numbers[i] << " ";
        }
        for(int num : numbers) {
            std::cout << num << " ";
        }

        numbers.pop_back(); // removes the last element
        numbers.clear(); // removes all elements

        // SORTING ARRAY    
        std::sort(A.begin(), A.end(), std::greater<int>());  // sorting in descending order 54321
        std::sort(A.begin(), A.end()); // sorting in ascending order 12345


## Introduction to Arrays ##
    // Reverse the given integer array
        while(i<j){
            // addition method
                A[i] = A[i]+A[j];
                A[j] = A[i] - A[j];
                A[i] = A[i] - A[j];

            // swap method
                int temp = A[i];
                A[i] = A[j];
                A[j] = temp;
            i++;
            j--;
        }
    // Rotate array
        Reverse(0, N-1);
        Reverse(0, k-1);
        Reverse(k, N-1);
    // Q1. Good Pair
        /*
        Q.1 ->  Given an array A and an integer B. A pair(i, j) in the array is a good pair if i != j and (A[i] + A[j] == B). Check if any good pair exist or not.

        Note :
            

        Problem Constraints
            1 <= A.size() <= 104
            1 <= A[i] <= 109
            1 <= B <= 109



        Input Format
            First argument is an integer array A.
            Second argument is an integer B.

        Output Format
            Return 1 if good pair exist otherwise return 0.

        Input 1:
            A = [1,2,3,4]
            B = 7

        Output 1:
            1

        Input 2:
            A = [1,2,4]
            B = 4

        Output 2:
            0

        */

        // CODE
        int Solution::solve(vector<int> &A, int B) {
            // check A[i]+A[j] == B && i!=j 
            int N = A.size();
            for (int i = 0; i < N;i++) {
                for (int j = 0; j <N;j++) {
                    if (((A[i] + A[j]) == B) && (i!=j)){
                        return 1;
                    }
                }
            }
            return 0;
        }
    // Q2. Reverse In Range
        /*
        Q.2 -> Given an array A of N integers and also given two integers B and C. Reverse the elements of the array A within the given inclusive range [B, C].

        Note :
            

        Problem Constraints
            1 <= N <= 105
            1 <= A[i] <= 109
            0 <= B <= C <= N - 1

        Input Format
            The first argument A is an array of integer.
            The second and third arguments are integers B and C

        Output Format
            Return the array A after reversing in the given range.

        Input 1:
            A = [1, 2, 3, 4]
            B = 2
            C = 3

        Output 1:
            [1, 2, 4, 3]

        Input 2:
            A = [2, 5, 6]
            B = 0
            C = 2

        Output 2:
            [6, 5, 2]

        */

        // CODE

        vector<int> Solution::solve(vector<int> &A, int B, int C) {
            int N = A.size();
            int i = B;
            int j = C;

            // Two Pointers Approach 
            // swap the two value until 1<j and decrease size form both side

            while(i<j){
                A[i] = A[i]+A[j];
                A[j] = A[i] - A[j];
                A[i] = A[i] - A[j];
                i++;
                j--;
            }

            return A;
        }
    // Q3. Array Rotation
        /*
        Q.3 ->  Given an integer array A of size N and an integer B, you have to return the same array after rotating it B times towards the right

        Note :
            

        Problem Constraints
            1 <= N <= 105
            1 <= A[i] <=109
            1 <= B <= 109

        Input Format
            The first argument given is the integer array A.
            The second argument given is the integer B.

        Output Format
            Return the array A after rotating it B times to the right

        Input 1:
            A = [1, 2, 3, 4]
            B = 2

        Output 1:
            [3, 4, 1, 2]

        Input 2:
            A = [2, 5, 6]
            B = 1

        Output 2:
            [6, 2, 5]

        */

        // CODE

        vector<int> reverse(vector<int> A, int i, int j){
            while(i<j){
                int temp = A[i];
                A[i] = A[j];
                A[j] = temp;
                i++;
                j--;
            }

            return A;
        }
        vector<int> Solution::solve(vector<int> &A, int B) {
            int N = A.size();
            B = B % N; 

            // Rotate the Array B times
            A = reverse(A, 0, N-1);
            A = reverse(A, 0, B-1);
            A = reverse(A, B, N-1);
            
            return A;
        }
    // Q4. Max Min of an Array
        /*
        Q.4 -> Given an array A of size N. You need to find the sum of Maximum and Minimum element in the given array.

        Note :
            1 <= N <= 105
            -109 <= A[i] <= 109
            

        Problem Constraints
            1 <= N <= 105
            -109 <= A[i] <= 109
        
        Input Format
            First argument A is an integer array.    

        Output Format
            Return the sum of maximum and minimum element of the array


        Input 1:
            A = [-2, 1, -4, 5, 3]

        Output 1:
            1

        Input 2:
            A = [1, 3, 4, 1]

        Output 2:
            5

        */

        // CODE
        int Solution::solve(vector<int> &A) {
            // find the min and max of array and return the sum of that min and max
            int N = A.size();
            int min = INT_MAX;
            int max = INT_MIN;
            for (int i = 0; i < N;i++) {
            if (A[i]< min){
                min = A[i];
            }
            if (A[i] > max){
                max = A[i];
            }
            }

            return (min+max);
        }
    // Q1. Linear Search - Multiple Occurences
        /*
        Q.1 -> Given an array A and an integer B, find the number of occurrences of B in A.

        Note :
            
        Problem Constraints
            1 <= B, Ai <= 109
            1 <= length(A) <= 105   

        Input Format
            Given an integer array A and an integer B.   

        Output Format
            Return an integer, number of occurrences of B in A.

        Input 1:
            A = [1, 2, 2], B = 2 

        Output 1:
            2

        Input 2:
            A = [1, 2, 1], B = 3 


        Output 2:
            0

        */

        // CODE
        int Solution::solve(vector<int> &A, int B) {
            // search how many time the b present in array
            int N = A.size();
            int O = 0;
            for (int i = 0; i < N;i++) {
                if (A[i] == B){
                    O++;
                }
            }
            return O;
        }
    // Q2. Time to equality
        /*
        Q.2 -> Given an integer array A of size N. In one second, you can increase the value of one element by 1.
        Find the minimum time in seconds to make all elements of the array equal

        Note :
            

        Problem Constraints
            1 <= N <= 1000000
            1 <= A[i] <= 1000

        Input Format
            First argument is an integer array A.

        Output Format
            Return an integer denoting the minimum time to make all elements equal.

        Input 1:
            A = [2, 4, 1, 3, 2]

        Output 1:
            8

        */

        // CODE
        int Solution::solve(vector<int> &A) {
            // 1. calcultate the max of array
            // 2. for each element the time is diffrence between max and element and return the sum of all differences
            int max = INT_MIN;
            for (int i = 0; i < A.size();i++) {
            if (A[i] > max){
                max = A[i];
            }
            }

            int ans = 0;
            for (int i = 0; i < A.size();i++) {
            ans += max-A[i];
            }

            return ans;
        }
    // Q3. Count of elements
        /*
        Q.3 -> Given an array A of N integers. 
        Count the number of elements that have at least 1 elements greater than itself.


        Note :
            

        Problem Constraints
            1 <= N <= 105
            1 <= A[i] <= 109   

        Input Format
            First and only argument is an array of integers A. 

        Output Format
            Return the count of elements.

        Input 1:
            A = [3, 1, 2]

        Output 1:
            2

        Input 2:
            A = [5, 5, 3]

        Output 2:
            1

        */

        // CODE
        int Solution::solve(vector<int> &A) {
            // check the count of how many elements are lesser than max
            int max = INT_MIN;
            for (int i = 0; i < A.size();i++) {
            if (A[i] > max){
                max = A[i];
            }
            }

            int cnt = 0;
            for (int i = 0; i < A.size();i++) {
            if(A[i] < max){
                cnt++;
            }
            }

            return cnt;
        }
    // Q4. Second Largest
        /*
        Q.4 -> You are given an integer array A. You have to find the second largest element/value in the array or report that no such element exists.

        Note :
            

        Problem Constraints
            1 <= |A| <= 105
            0 <= A[i] <= 109

        Input Format
            The first argument is an integer array A.   

        Output Format
            Return the second largest element. If no such element exist then return -1.

        Input 1:
            A = [2, 1, 2] 

        Output 1:
            1 

        Input 2:
            A = [2]

        Output 2:
            -1 

        */

        // CODE

        int Solution::solve(vector<int> &A) {
            // return the second largest number
            int N = A.size();
            int max_element = INT_MIN;
            int max_2 = INT_MIN;
            for (int i = 0; i < N;i++) {
            if (A[i] > max_element){
                max_element = A[i];
            }
            }
            for (int i = 0; i < N;i++) {
            if ((A[i] > max_2) && (A[i] < max_element)){
                max_2 = A[i];
            }
            }

            if (max_2 == INT_MIN){
                return -1;
            }else{
                return max_2;
            }

        }
## Prefix Sum ##
    // How to create Prefix sum of array
        vector<int> P(A.size(), 0);
        P[0] = A[0];
        for (int i = 1; i < A.size(); ++i) {
            P[i] = P[i-1] + A[i];
        }

    // sum query
        for (int i = 0; i < B.size(); i++) {
            int L = B[i][0];
            int R = B[i][1];
            if(L == 0){
                sum_array[i] = prefixSum[R];
            }else{
                sum_array[i] = prefixSum[R] - prefixSum[L-1];
            }
        
        }
    // even index sum
        even_P[0] = A[0];
        for(int i=1; i<5; i++){
            if(i%2==0){
                even_P[i] = even_P[i-1] +A[i];
            }else{
                even_P[i] = even_P[i-1];
            }
        }
    // odd index sum
        odd_P[0] = A[0];
        for(int i=1; i<5; i++){
            if(i%2==1){
                odd_P[i] = odd_P[i-1] +A[i];
            }else{
                odd_P[i] = odd_P[i-1];
            }
        }
    // Special Index
        if i == 0
            even_sum = odd_P[N-1] - odd_P[i]
            odd_sum = even_P[N-1] - even_P[i]
        else 
            even_sum = even_P[i-1] + ( odd_P[N-1] - odd_P[i] )
            odd_sum = odd_P[i-1] + ( even_P[N-1] - even_P[i] )
        if(even_sum == odd_sum) 
            return i
    // Q1. Range Sum Query
        /*
        Q.1 -> You are given an integer array A of length N.
        You are also given a 2D integer array B with dimensions M x 2, where each row denotes a [L, R] query.
        For each query, you have to find the sum of all elements from L to R indices in A (0 - indexed).
        More formally, find A[L] + A[L + 1] + A[L + 2] +... + A[R - 1] + A[R] for each query.

        Note :
            

        Problem Constraints
            1 <= N, M <= 105
            1 <= A[i] <= 109
            0 <= L <= R < N 

        Input Format
            The first argument is the integer array A.
            The second argument is the 2D integer array B.    

        Output Format
            Return an integer array of length M where ith element is the answer for ith query in B.

        Input 1:
            A = [1,  , 4, 5]
            B = [[0, 3], [1, 2]]

        Output 1:
            [10, 5]

        Input 2:
            A = [2, 2, 2]
            B = [[0, 0], [1, 2]]

        Output 2:
            [2, 4]

        */

        // CODE
        vector<long long> Solution::rangeSum(vector<int> &A, vector<vector<int> > &B) {
            // calculate prefix sum and iterate query array and calculate sum for each query
            vector<long> prefixSum(A.size());

            prefixSum[0] = A[0];

            for (long i = 1; i < A.size(); i++) {
                prefixSum[i] = prefixSum[i - 1] + A[i];
            }


            vector<long long> sum_array(B.size());
            for (int i = 0; i < B.size(); i++) {
                int L = B[i][0];
                int R = B[i][1];
                if(L == 0){
                    sum_array[i] = prefixSum[R];
                }else{
                    sum_array[i] = prefixSum[R] - prefixSum[L-1];
                }
            
            }

            

            return sum_array;
        }
    // Q2. Special Index
        /*
        Q.2 -> Given an array, arr[] of size N, the task is to find the count of array indices such that removing an element from these indices makes the sum of even-indexed and odd-indexed array elements equal.

        Note :
            

        Problem Constraints
            1 <= N <= 105
            -105 <= A[i] <= 105
            Sum of all elements of A <= 109 

        Input Format
            First argument contains an array A of integers of size N       

        Output Format
            Return the count of array indices such that removing an element from these indices makes the sum of even-indexed and odd-indexed array elements equal.

        Input 1:
            A = [2, 1, 6, 4]

        Output 1:
            1

        Input 2:
            A = [1, 1, 1]

        Output 2:
            3

        */

        // CODE

        /*
            1. calculate even element prefix sum
            2. calculate odd element prefix sum
            3. after removing the i index ||| i.e. after removing the i element all element towards i
            4. after i all even element become odd and all odd element become even index element
            5. even element sum == [ (even sum before i index) + (odd sum after i index)]
            6. odd element sum == [ (odd sum before i index) + (even sum after i index)]
            7. check if even element sum == odd element sum  then return i
        */
        std::vector<int> evenPrefixArray(const std::vector<int> &A) {
            std::vector<int> prefixSum(A.size(), 0);
            for (int i = 0; i < A.size(); ++i) {
                if (i % 2 == 0) {
                    prefixSum[i] = A[i] + (i > 1 ? prefixSum[i - 2] : 0);
                } else {
                    prefixSum[i] = (i > 0 ? prefixSum[i - 1] : 0);
                }
            }
            return prefixSum;
        }

        std::vector<int> oddPrefixArray(const std::vector<int> &A) {
            std::vector<int> prefixSum(A.size(), 0);
            for (int i = 0; i < A.size(); ++i) {
                if (i % 2 == 1) {
                    prefixSum[i] = A[i] + (i > 1 ? prefixSum[i - 2] : 0);
                } else {
                    prefixSum[i] = (i > 0 ? prefixSum[i - 1] : 0);
                }
            }
            return prefixSum;
        }

        int Solution::solve(std::vector<int> &A) {
            if (A.empty()) return 0;

            std::vector<int> evenSum = evenPrefixArray(A);
            std::vector<int> oddSum = oddPrefixArray(A);

            int count = 0;
            int n = A.size();

            for (int i = 0; i < n; ++i) {
                int se, so;

                if (i == 0) {
                    se = oddSum[n - 1];
                    so = evenSum[n - 1];
                } else {
                    se = evenSum[i - 1] + (oddSum[n - 1] - oddSum[i]);
                    so = oddSum[i - 1] + (evenSum[n - 1] - evenSum[i]);
                }

                if (se == so) {
                    count++;
                }
            }

            return count;
        }
    // Q3. In-Place Prefix Sum
        /*
        Q.3 -> Given an array A of N integers. Construct prefix sum of the array in the given array itself.

        Note :
            

        Problem Constraints
            1 <= N <= 105
            1 <= A[i] <= 103
        

        Input Format
            Only argument A is an array of integers.    

        Output Format
            Return an array of integers denoting the prefix sum of the given array.

        Input 1:
            A = [1, 2, 3, 4, 5]

        Output 1:
            [1, 3, 6, 10, 15]

        Input 2:
            A = [4, 3, 2]

        Output 2:
            [4, 7, 9]

        */

        // CODE
        vector<int> Solution::solve(vector<int> &A) {
            // start loop from i=1 index and store sum in A[i]
            for (int i = 1; i < A.size(); i++) {
                A[i] = A[i - 1] + A[i];
            }
            return A;
        }
    // Q1. Equilibrium index of an array
        /*
        Q.1 -> You are given an array A of integers of size N.
        Your task is to find the equilibrium index of the given array
        The equilibrium index of an array is an index such that the sum of elements at lower indexes is equal to the sum of elements at higher indexes.
        If there are no elements that are at lower indexes or at higher indexes, then the corresponding sum of elements is considered as 0.

        Note :
            Array indexing starts from 0.
            If there is no equilibrium index then return -1.
            If there are more than one equilibrium indexes then return the minimum index.    

        Problem Constraints
            1 <= N <= 105
            -105 <= A[i] <= 105  

        Input Format
            First arugment is an array A .

        Output Format
            Return the equilibrium index of the given array. If no such index is found then return -1.

        Input 1:
            A = [-7, 1, 5, 2, -4, 3, 0]

        Output 1:
            3

        Input 2:
            A = [1, 2, 3]

        Output 2:
            -1

        */

        // CODE

        int Solution::solve(vector<int> &A) {
            /*
                in this approach calculate prefix sum of array
                and after tha iterate loop over the array
                and calculate the left sum and right sum using prefix sum array
            */
            int n = A.size();
            if (n == 0) return -1;

            std::vector<int> prefixSum(A.size(), 0);
            prefixSum[0] = A[0];
            for (int i = 1; i < A.size(); i++) {
                prefixSum[i] = prefixSum[i - 1] + A[i];
            }


            for (int i = 0; i < A.size(); i++) {
                int leftSum = (i == 0) ? 0 : prefixSum[i - 1];
                int rightSum = prefixSum[n - 1] - prefixSum[i];
                if (leftSum == rightSum) {
                    return i;
                }
            }
            return -1;

        }

        // code 2

        int Solution::solve(vector<int> &A) {
            /*
            1. for this approach take two variable right sum and left sum
            2. calculate sum off array in right sum
            3. iterate a loop on array and while iterating
            4. calculate left sum by adding A[i] in left sum
            5. calculate right sum by subracting A[i] in right sum
            6. check right sum == left sum then return i
            */
            int total_sum = 0;
            int left_sum = 0;
            for (int i = 0; i < A.size(); i++) {
                total_sum+=A[i];
            }
            for (int i = 0; i < A.size(); i++) {
                total_sum -= A[i];

                if (left_sum == total_sum) {
                        return i;
                }

                left_sum += A[i];
            }

            
            return -1;

        }
    // Q2. In-place Prefix Sum
        /*
        Q.2 -> Given an array A of N integers. Construct prefix sum of the array in the given array itself.

        Note :
            

        Problem Constraints
            1 <= N <= 105
            1 <= A[i] <= 103

        Input Format
            Only argument A is an array of integers.
            

        Output Format
            Return an array of integers denoting the prefix sum of the given array.

        Input 1:
            A = [1, 2, 3, 4, 5]

        Output 1:
            [1, 3, 6, 10, 15]

        Input 2:
            A = [4, 3, 2]

        Output 2:
            [4, 7, 9]

        */

        // CODE

        vector<int> Solution::solve(vector<int> &A) {
            // start loop from i=1 index and store sum in A[i]
            for (int i = 1; i < A.size(); i++) {
                A[i] = A[i - 1] + A[i];
            }

            return A;
        }
## Carry Forward & Subarrays ##
    // Special Subsequences "AG" (Carry forward teq)
        int cnt =0;
        int ans =0;
        for(int i=(A.size()-1); i>=0; i--){
            if(A[i] == 'G')  cnt++;
            if(A[i] == 'A') ans += cnt ;
        }
    // SUBARRAY
        // Print SubArray
            for(int i=si; si<=ei; si++){
                cout << A[si] << " ";
            }
        // Print All SubArrays
            for(int L=0; L<N; L++){
                for(int R=L; R<N; R++){
                    for(int k=L; k<=R; k++){
                        cout << A[k] << " ";
                    }
                    cout << endl;
                }
            }
        // MIN & MAX SubArray
            for (int i=1; i<=(A.size() -1); i++){
                min = std::min(min, A[i]);
                max = std::max(max, A[i]);
            }

            int l_min = -1;
            int l_max = -1;

            int ans = A.size();
            // finding checking max and min and updating repective index and calculating length using both index
            for (int i=0; i<=(A.size() - 1); i++){
                if(A[i] == min){
                    l_min = i;
                    if (l_max != -1){
                        ans = std::min(ans, (i-l_max+1));   // i-l_max+1 == length of sub_array
                    }
                    
                }
                if(A[i] == max){
                    l_max = i;
                    if (l_min != -1){
                        ans = std::min(ans, (i-l_min+1));
                    }
                }
            }
    // Q1. Closest MinMax
        /*
        Q.1 -> Given an array A, find the size of the smallest subarray such that it contains at least one occurrence of the maximum value of the array
        and at least one occurrence of the minimum value of the array.

        Note :
            

        Problem Constraints
            1 <= |A| <= 2000

        Input Format
            First and only argument is vector A   

        Output Format
            Return the length of the smallest subarray which has at least one occurrence of minimum and maximum element of the array

        Input 1:
            A = [1, 3, 2]

        Output 1:
            2

        Input 2:
            A = [2, 6, 1, 6, 9]

        Output 2:
            3

        */

        // CODE
        int Solution::solve(vector<int> &A) {

            // FIND MIN AND MAX 
            int min = A[0];
            int max = A[0];

            for (int i=1; i<=(A.size() -1); i++){
                min = std::min(min, A[i]);
                max = std::max(max, A[i]);
            }

            int l_min = -1;
            int l_max = -1;

            int ans = A.size();
            // finding checking max and min and updating repective index and calculating length using both index
            for (int i=0; i<=(A.size() - 1); i++){
            if(A[i] == min){
                l_min = i;
                if (l_max != -1){
                    ans = std::min(ans, (i-l_max+1));   // i-l_max+1 == length of sub_array
                }
                
            }
            if(A[i] == max){
                    l_max = i;
                    if (l_min != -1){
                        ans = std::min(ans, (i-l_min+1));
                    }
            }
            }

            return ans;
        }
    // Q2. Subarray in given range
        /*
        Q.2 -> Given an array A of length N, return the subarray from B to C.

        Note :
            

        Problem Constraints
        1 <= N <= 105
        1 <= A[i] <= 109
        0 <= B <= C < N   

        Input Format
            The first argument A is an array of integers
            The remaining argument B and C are integers.   

        Output Format
            Return a subarray

        Input 1:
            A = [4, 3, 2, 6]
            B = 1
            C = 3

        Output 1:
            [3, 2, 6]

        Input 2:
            A = [4, 2, 2]
            B = 0
            C = 1

        Output 2:
            [4, 2]

        */

        // CODE
        vector<int> Solution::solve(vector<int> &A, int B, int C) {
            // create the subarray form B to C using A
            vector<int> ans;

            for (int i = B; i <= C; i++) {
                ans.push_back(A[i]);
            }

            return ans;
        }
    // Q3. Generate all subarrays
        /*
        Q.3 -> You are given an array A of N integers.
        Return a 2D array consisting of all the subarrays of the array

        Note :
            The order of the subarrays in the resulting 2D array does not matter.   

        Problem Constraints
            1 <= N <= 100
            1 <= A[i] <= 105

        Input Format
            First argument A is an array of integers.

        Output Format
            Return a 2D array of integers in any order

        Input 1:
            A = [1, 2, 3]

        Output 1:
            [[1], [1, 2], [1, 2, 3], [2], [2, 3], [3]]

        Input 2:
            A = [5, 2, 1, 4]

        Output 2:
            [[1 ], [1 4 ], [2 ], [2 1 ], [2 1 4 ], [4 ], [5 ], [5 2 ], [5 2 1 ], [5 2 1 4 ] ]

        */

        // CODE
        vector<vector<int> > Solution::solve(vector<int> &A) {

            /*
                i -> (0 to N){
                    j -> (i to N){
                        index -> (i to j)
                    }
                }
            */
            vector<vector<int>> result;
            for(int st=0; st<(A.size()); st++){
                for(int end=st; end<(A.size()); end++){
                    vector<int> subarray;
                    for(int i=st; i<=end; i++){
                        subarray.push_back(A[i]);
                    }
                    result.push_back(subarray);
                }
            }
            return result;
        }
    // Q4. Special Subsequences "AG"
        /*
        Q.4 -> You have given a string A having Uppercase English letters.
        You have to find how many times subsequence "AG" is there in the given string.
        NOTE: Return the answer modulo 109 + 7 as the answer can be very large.

        Note :
            

        Problem Constraints
            1 <= length(A) <= 10^5  

        Input Format
            First and only argument is a string A.

        Output Format
            Return an integer denoting the answer.


        Input 1:
            A = "ABCGAG"

        Output 1:
            3

        Input 2:
            A = "GAB"

        Output 2:
            0

        */

        // CODE
        int Solution::solve(string A) {

            /*
                traverse form N to 0
                check if G then increase the count of G
                check if A then add the count of G in Ans
            */
            const int MOD = 1000000007;
            int cnt =0;
            int ans =0;
            for(int i=(A.size()-1); i>=0; i--){
                if(A[i] == 'G'){
                    cnt++;
                }
                if(A[i] == 'A'){
                    ans = (ans + cnt) % MOD;
                }
            }

            return ans;
        }
    // Q1. Pick from both sides!
        /*
        Q.1 -> You are given an integer array A of size N.
        You have to perform B operations. In one operation, you can remove either the leftmost or the rightmost element of the array A.
        Find and return the maximum possible sum of the B elements that were removed after the B operations.

        NOTE: Suppose B = 3, and array A contains 10 elements, then you can:
        Remove 3 elements from front and 0 elements from the back, OR
        Remove 2 elements from front and 1 element from the back, OR
        Remove 1 element from front and 2 elements from the back, OR
        Remove 0 elements from front and 3 elements from the back.

        Problem Constraints
            1 <= N <= 10^5
            1 <= B <= N
            -103 <= A[i] <= 10^3

        Input Format
            First argument is an integer array A.
            Second argument is an integer B.

        Output Format
            Return an integer denoting the maximum possible sum of elements you removed.

        Input 1:
            A = [5, -2, 3 , 1, 2]
            B = 3

        Output 1:
            8

        Input 2:
            A = [ 2, 3, -1, 4, 2, 1 ]
            B = 4

        Output 2:
            9

        */

        // CODE
            
            int Solution::solve(vector<int> &A, int B) {
                /*
                    1. take sume of first B elements
                    2. set as a max sum
                    3. take window of size B add from N-i and remove B-i index elements
                */
                int n = A.size();
                int sum = 0;
                int maxSum = 0;
                
                for (int i = 0; i < B; i++) {
                    sum += A[i];
                }
                
                maxSum = sum;
                
            
                for (int i = 1; i <= B; i++) {
                    sum -= A[B - i];
                    sum += A[n - i];
                    maxSum = std::max(maxSum, sum);
                }

                return maxSum;

                
            }
    // Q2. Leaders in an array
        /*
        Q.2 -> Given an integer array A containing N distinct integers, you have to find all the leaders in array A. 
        An element is a leader if it is strictly greater than all the elements to its right side.

        Note :
            The rightmost element is always a leader.   

        Problem Constraints
            1 <= N <= 10^5
            1 <= A[i] <= 10^8

        Input Format
            There is a single input argument which a integer array A    

        Output Format
            Return an integer array denoting all the leader elements of the array.

        Input 1:
            A = [16, 17, 4, 3, 5, 2]

        Output 1:
            [17, 2, 5]

        Input 2:
            [5, 4]

        Output 2:
            [5, 4]

        */

        // CODE
        // carray forward teq.
        std::vector<int> findLeaders(const std::vector<int>& A) {
            /*
                1. add last element in leader
                2. take last element as a max and compare with other elements 
                3. travers from Right to left and comapare and keep updating max
            */
            int n = A.size();
            std::vector<int> leaders;
            int maxFromRight = A[n-1]; // The last element is always a leader
            leaders.push_back(maxFromRight);

            // Traverse the array from right to left
            for (int i = n - 2; i >= 0; i--) {
                if (A[i] > maxFromRight) {
                    maxFromRight = A[i];
                    leaders.push_back(A[i]);
                }
            }

            // The leaders are found in reverse order, so we need to reverse the result
            std::reverse(leaders.begin(), leaders.end());
            return leaders;
        }

        // CODE 2
        // suffix sum teq.
        vector<int> Solution::solve(vector<int> &A) {

            /*
                A = [16, 17, 4, 3, 5, 2];
                sufix = [17, 17, 5, 5, 5, 2];
            */
            int n = A.size();
            vector<int> ans;

            vector<int> suffix_A(n);

            suffix_A[n - 1] = A[n - 1];
            for (int i = n - 2; i >= 0; i--) {
                if (A[i] > suffix_A[i + 1]){
                    suffix_A[i] = A[i];
                }else{
                    suffix_A[i] = suffix_A[i+1];
                }
            }

            for(int i =0; i<n; i++){
                if(A[i]>=suffix_A[i]){
                    ans.push_back(A[i]);
                }
            }

            return ans;
        }
    // Q3. Count Subarrays
        /*
        Q.3 -> Misha likes finding all Subarrays of an Array. Now she gives you an array A of N elements and told you to find the number of subarrays of A, that have unique elements.
        Since the number of subarrays could be large, return value % 109 +7.

        Note :
            

        Problem Constraints
            1 <= N <= 10^5
            1 <= A[i] <= 10^6

        Input Format
            The only argument given is an Array A, having N integers.  

        Output Format
            Return the number of subarrays of A, that have unique elements.

        Input 1:
            A = [1, 1, 3]

        Output 1:
            4

        Input 2:
            A = [2, 1, 2]

        Output 2:
            5

        */

        // CODE
        int Solution::solve(vector<int> &A) {
            const int MOD = 1e9 + 7;

            int n = A.size();
            int left = 0, right = 0;
            std::unordered_set<int> unique_elements;
            long long result = 0;

            while (right < n) {
                while (unique_elements.count(A[right])) {
                    unique_elements.erase(A[left]);
                    left++;
                }
                unique_elements.insert(A[right]);
                result += (right - left + 1);
                result %= MOD;
                right++;
            }

            return result;

        }


        // CODE 2
        int Solution::solve(vector<int> &A) {
            int N = A.size();
            long long ans = 0; // Use long long to avoid overflow
            int l = 0; // Left pointer
            unordered_map<int, int> element_set; // To keep track of elements in the current window

            for (int r = 0; r < N; ++r) {
                // Add current element to the map
                element_set[A[r]]++;

                // If the element frequency is more than 1, move left pointer
                while (element_set[A[r]] > 1) {
                    element_set[A[l]]--;
                    if (element_set[A[l]] == 0) {
                        element_set.erase(A[l]); // Remove from map if frequency is zero
                    }
                    l++; // Shrink the window from the left
                }

                // Calculate the number of unique subarrays ending at `r`
                ans = (ans + (r - l + 1)) % 1000000007; // Adding the number of new unique subarrays
            }

            return ans; // Return the result
        }
    // Q4. Best Time to Buy and Sell Stocks I
        /*
        Q.4 -> Say you have an array, A, for which the ith element is the price of a given stock on day i.
        If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.
        Return the maximum possible profit.

        Note :
            

        Problem Constraints
            0 <= A.size() <= 700000
            1 <= A[i] <= 10^7

        Input Format
            The first and the only argument is an array of integers, A.

        Output Format
            Return an integer, representing the maximum possible profit.

        Input 1:
            A = [1, 2]

        Output 1:
            1

        Input 2:
            A = [1, 4, 5, 2, 4]

        Output 2:
            4

        */

        // CODE
        int Solution::maxProfit(const vector<int> &A) {

            if (A.size() < 2){
                return 0;
            }

            int min_price = A[0];
            int max_profit = 0;

            for (int i = 1; i < A.size(); i++) {
                min_price = std::min(min_price, A[i]);
                int current_profit = A[i] - min_price;
                max_profit = std::max(max_profit, current_profit);
            }

            return max_profit;
        }
## Sliding Window & Contribution Technique ##
    // Find the Total sum of all posible sub array
        BruteForce approach
            // Generate all possible subarrays
            for (int L = 0; L < N; ++L) {  // Left index of subarray
                for (int R = L; R < N; ++R) {  // Right index of subarray
                    long long currentSubarraySum = 0;
                    for (int k = L; k <= R; ++k) {  // Compute sum of subarray A[L...R]
                        currentSubarraySum += A[k];
                    }
                    totalSum += currentSubarraySum;
                }
            }
        Prefix Sum
            // Calculate sum of all subarrays using prefix sum
            for (int L = 0; L < N; ++L) {
                for (int R = L; R < N; ++R) {
                    if (L == 0) {
                        totalSum += prefixSum[R];
                    } else {
                        totalSum += prefixSum[R] - prefixSum[L-1];
                    }
                }
            }
        Carray forward
            // Iterate over each element and calculate its contribution to the total sum
            for (int L = 0; L < N; ++L) {
                long long currentSubarraySum = 0;
                for (int R = L; R < N; ++R) {
                    currentSubarraySum += A[R]; // Add A[R] to the current subarray sum
                    totalSum += currentSubarraySum; // Add the current subarray sum to the total sum
                }
            }
        Contribution Technique
            // Calculate contribution for each element A[i]
            for (int i = 0; i < N; ++i) {
                long long contribution = A[i] * (i + 1) * (N - i);
                totalSum += contribution;
            }
    // sliding window
        # Given an Integer Array Find Max Subarray sum of Length K
            int sum = 0;
            for (int i = 0; i < K; i++) {
                sum += A[i];
            }
            int ans = sum;
            for (int R = K; R < N; R++) {
                int L = R - K;
                sum += A[R] - A[L];
                ans = max(ans, sum);
            }
    // Shirnking Sliding Window
        int maxSubarraySum(int A, int B, vector<int>& C) {
            int max_sum = 0;
            int current_sum = 0;  
            int L = 0;  
            for (int R = 0; R < A; ++R) {  
                current_sum += C[R];
                while (current_sum > B && L <= R) {
                    current_sum -= C[L];
                    ++L;
                }
                if (current_sum <= B) {
                    max_sum = max(max_sum, current_sum);
                }
            }
            return max_sum;
        }
    // Q1. Maximum Subarray Easy
        /*
        Q.1 -> You are given an integer array C of size A. Now you need to find a subarray (contiguous elements) so that the sum of contiguous elements is maximum.
        But the sum must not exceed B.

        Note :
            

        Problem Constraints
            1 <= A <= 10^3
            1 <= B <= 10^9
            1 <= C[i] <= 10^6  

        Input Format
            The first argument is the integer A.
            The second argument is the integer B.
            The third argument is the integer array C.   

        Output Format
            Return a single integer which denotes the maximum sum.

        Input 1:
            A = 5
            B = 12
            C = [2, 1, 3, 4, 5]

        Output 1:
            12

        Input 2:
            A = 3
            B = 1
            C = [2, 2, 2]

        Output 2:
            0

        */

        // CODE
        int Solution::maxSubarray(int A, int B, vector<int> &C) {
            /*
                1. use N^2 approach
            */
            int sum = 0;
            int ans = 0;
            for(int l = 0; l < C.size(); l++) {
                for(int r = l; r < C.size(); r++) {
                    sum = 0;
                    for(int i = l; i <= r; i++) {
                        sum += C[i];
                    }
                    
                    if(sum <= B && sum > ans) {
                        ans = sum;
                    }
                }
            }
            return ans;
            
        }
        // Sliding Window Approach
        int maxSubarraySum(int A, int B, vector<int>& C) {
            int max_sum = 0;  // To track the maximum sum of subarray <= B
            int current_sum = 0;  // To maintain the sum of the current subarray
            int L = 0;  // Left pointer of the sliding window (was start)

            // Traverse the array using a sliding window
            for (int R = 0; R < A; ++R) {  // R is the right pointer (was end)
                // Add the current element to the current sum
                current_sum += C[R];
                
                // Shrink the window from the left if current_sum exceeds B
                while (current_sum > B && L <= R) {
                    current_sum -= C[L];
                    ++L;
                }

                // Update max_sum if current_sum is a valid subarray sum
                if (current_sum <= B) {
                    max_sum = max(max_sum, current_sum);
                }
            }

            return max_sum;
        }
    // Q2. Sum of All Subarrays
        /*
        Q.2 -> You are given an integer array A of length N.
        You have to find the sum of all subarray sums of A.
        More formally, a subarray is defined as a contiguous part of an array which we can obtain by deleting zero or more elements from either end of the array.
        A subarray sum denotes the sum of all the elements of that subarray.

        Note : 
            Be careful of integer overflow issues while calculations. Use appropriate datatypes.

        Problem Constraints
            1 <= N <= 10^5
            1 <= Ai <= 10^4  

        Input Format
            The first argument is the integer array A.    

        Output Format
            Return a single integer denoting the sum of all subarray sums of the given array.

        Input 1:
            A = [1, 2, 3]

        Output 1:
            20

        Input 2:
            A = [2, 1, 3]

        Output 2:
            19

        */

        // CODE
        long Solution::subarraySum(vector<int> &A) {

            long ans = 0;
            long N = A.size();
            for (long i = 0; i < N; i++) {
                ans += A[i] * (i+1) * (N-i);
            }

            return ans;

        }
    // Q3. Subarray with given sum and length
        /*
        Q.3 -> Given an array A of length N. Also given are integers B and C.
        Return 1 if there exists a subarray with length B having sum C and 0 otherwise

        Note :

        Problem Constraints
            1 <= N <= 10^5
            1 <= A[i] <= 10^4
            1 <= B <= N
            1 <= C <= 10^9  

        Input Format
            First argument A is an array of integers.
            The remaining arguments B and C are integers   

        Output Format
            Return 1 if such a subarray exist and 0 otherwise

        Input 1:
            A = [4, 3, 2, 6, 1]
            B = 3
            C = 11

        Output 1:
            1

        Input 2:
            A = [4, 2, 2, 5, 1]
            B = 4
            C = 6

        Output 2:
            0

        */

        // CODE
        int Solution::solve(vector<int> &A, int B, int C) {

            int li = 0;
            int sum = 0;

            for(int i=0; i<=(B-1); i++){
                sum += A[i];
            }

            if(sum == C){
                return 1;
            }

            for (int r=B; r<A.size(); r++){
                li = r-B;
                sum += A[r] - A[li];
                if (sum == C){
                    return 1;
                }
            }

            return 0;
        }
    // Q1. Good Subarrays Easy
        /*
        Q.1 -> Given an array of integers A, a subarray of an array is said to be good if it fulfills any one of the criteria:
        1. Length of the subarray is be even, and the sum of all the elements of the subarray must be less than B.
        2. Length of the subarray is be odd, and the sum of all the elements of the subarray must be greater than B.
        Your task is to find the count of good subarrays in A.

        Note :
            

        Problem Constraints
            1 <= len(A) <= 5 x 10^3
            1 <= A[i] <= 10^3
            1 <= B <= 10^7   

        Input Format
            The first argument given is the integer array A.
            The second argument given is an integer B.   

        Output Format
            Return the count of good subarrays in A.

        Input 1:
            A = [1, 2, 3, 4, 5]
            B = 4

        Output 1:
            6

        Input 2:
            A = [13, 16, 16, 15, 9, 16, 2, 7, 6, 17, 3, 9]
            B = 65

        Output 2:
            36

        */

        // CODE
        int Solution::solve(vector<int> &A, int B) {

            int cnt = 0;
            for(int l=0; l<A.size(); l++){
                int sum = 0;
                for(int r=l; r<A.size(); r++){
                    sum += A[r];
                    int length = r-l+1;
                    if((length%2 == 0 && sum < B) || (length%2==1 && sum > B)){
                        cnt++;
                    }

                
                }
            }

            return cnt;

        }
    // Q2. Minimum Swaps
        /*
        Q.2 -> Given an array of integers A and an integer B, find and return the minimum number of swaps required to bring all the numbers less than or equal to B together.

        Note :
            It is possible to swap any two elements, not necessarily consecutive.      

        Problem Constraints
        1 <= length of the array <= 100000
        -10^9 <= A[i], B <= 10^9  

        Input Format
            The first argument given is the integer array A.
            The second argument given is the integer B.   

        Output Format
            Return the minimum number of swaps.

        Input 1:
            A = [1, 12, 10, 3, 14, 10, 5]
            B = 8

        Output 1:
            2

        Input 2:
            A = [5, 17, 100, 11]
            B = 20

        Output 2:
            1

        */

        // CODE
        int Solution::solve(vector<int> &A, int B) {

            int n = A.size();
            
            int count = 0;
            for (int i = 0; i < n; i++) {
                if (A[i] <= B) {
                    count++;
                }
            }

            int swap_count_need = 0;
            for (int i = 0; i < count; i++) {
                if (A[i] > B) {
                    swap_count_need++;
                }
            }

            int min_swap_count = swap_count_need;
            
            for(int r = count; r<n; r++){
                if (A[r] > B) {
                    swap_count_need++;
                }

                int li = r-count;
                if(A[li] > B){
                    swap_count_need--;
                }

                min_swap_count = std::min(min_swap_count, swap_count_need);
            }
            return min_swap_count;
        }
    // Q3. Subarray with least average
        /*
        Q.3 -> Given an array A of size N, find the subarray of size B with the least average.

        Note :
            

        Problem Constraints
            1 <= B <= N <= 10^5
            -10^5 <= A[i] <= 10^5  

        Input Format
            First argument contains an array A of integers of size N.
            Second argument contains integer B.   

        Output Format
            Return the index of the first element of the subarray of size B that has least average.
            Array indexing starts from 0.

        Input 1:
            A = [3, 7, 90, 20, 10, 50, 40]
            B = 3

        Output 1:
            3

        Input 2:
            A = [3, 7, 5, 20, -10, 0, 12]
            B = 2

        Output 2:
            4

        */

        // CODE
        int Solution::solve(vector<int> &A, int B) {
            
            int li = 0;
            int sum = 0;
            double min_avg;
            int index = 0;
            for(int i=0; i<=(B-1); i++){
                sum += A[i];
            }

            // Initialize min_avg with the average of the first subarray
            min_avg = sum / static_cast<double>(B);
            index = 0;

            for (int r = B; r < A.size(); r++) {
                // Update the sliding window sum
                sum += A[r] - A[li];
                li++;

                // Calculate the average of the current subarray
                double avg = sum / static_cast<double>(B);

                // Update min_avg and index if necessary
                if (avg < min_avg) {
                    min_avg = avg;
                    index = li;
                }
            }

            return index;
        }
    // Q4. Counting Subarrays Easy
        /*
        Q.4 -> Given an array A of N non-negative numbers and a non-negative number B,
        you need to find the number of subarrays in A with a sum less than B.
        We may assume that there is no overflow.



        Note :
            

        Problem Constraints
            1 <= N <= 5 x 10^3
            1 <= A[i] <= 1000
            1 <= B <= 10^7  

        Input Format
            First argument is an integer array A.
            Second argument is an integer B.   

        Output Format
            Return an integer denoting the number of subarrays in A having sum less than B

        Input 1:
            A = [2, 5, 6]
            B = 10

        Output 1:
            4

        Input 2:
            A = [1, 11, 2, 3, 15]
            B = 10

        Output 2:
            4

        */

        // CODE

        int Solution::solve(vector<int> &A, int B) {
            int cnt = 0;
            for(int l=0; l<A.size(); l++){
                int sum = 0;
                for(int r=l; r<A.size(); r++){
                    sum += A[r];
                    if (sum < B) {
                        cnt++;
                    }
                }
            }

            return cnt;
        }

## 2D Matrices ##
    // Row-wise Traversal
        for (int i = 0; i < N; i++) {
            int sum = 0; // Initialize sum for each row
            for (int j = 0; j < M; j++) {
                sum += A[i][j]; // Sum up elements in the current row
            }
            std::cout << "Sum of row " << i << ": " << sum << std::endl; // Print the sum
        }
    // Column-wise Traversal
        for (int j = 0; j < M; j++) {
            int sum = 0; // Initialize sum for each row
            for (int i = 0; i < M; i++) {
                sum += A[i][j]; // Sum up elements in the current row
            }
            std::cout << "Sum of column " << i << ": " << sum << std::endl; // Print the sum
        }
    // How to print Principal Digonal
        for (int i = 0; i < N; i++) {
            cout<< A[i][i] << " ";
        }
    // How to print Anitiagonal
        for (int i = 0; i < N; i++) {
            cout<< A[i][N-1-i] << " ";
        }   
    // print all elements Digonaly and Anti digonaly
        void printAntiDiagonals(vector<vector<int>>& matrix) {
            // Traverse each anti-diagonal starting from the first column
            for (int C = 0; C < m; ++C) {
                int i = 0;
                int j = C;
                while (i < n && j >= 0) {
                    cout << matrix[i][j] << " ";
                    ++i;
                    --j;
                }
                cout << endl;
            }
            // Traverse each anti-diagonal starting from the last row
            for (int R = 1; R < n; ++R) {
                int i = R;
                int j = m - 1;

                while (i < n && j >= 0) {
                    cout << matrix[i][j] << " ";
                    ++i;
                    --j;
                }
                cout << endl;
            }
        }
    // Travers All upper Trangular element
        for (int C = 0; C < m; ++C) {
            int i = 0;
            int j = C;
            while (i < n && j >= 0) {
                cout << matrix[i][j] << " ";
                ++i;
                --j;
            }
            cout << endl;
        }
    // Transpose of 2D Square Matrix
        // Iterate only through the upper triangle of the matrix
        for (int i = 0; i < N; i++) {
            for (int j = i + 1; j < N; j++) {
                // Swap elements to transpose
                swap(matrix[i][j], matrix[j][i]);
            }
        }

    // Rotate the 2D Matrix
        // first transpose the matrix A and reverse the each row
        transposeMatrix(A);
        for (int i = 0; i < N; i++) {
            reverse(A[i].begin(), A[i].end()); // Reverse each row
        }
    // Q1. Column Sum
        /*
        Q.1 -> You are given a 2D integer matrix A, return a 1D integer array containing column-wise sums of original matrix.

        Note :
            

        Problem Constraints
        1 <= A.size() <= 10^3
        1 <= A[i].size() <= 10^3
        1 <= A[i][j] <= 10^3

        Input Format
            First argument is a 2D array of integers.(2D matrix).  

        Output Format
            Return an array containing column-wise sums of original matrix.

        Input 1:
            [1,2,3,4]
            [5,6,7,8]
            [9,2,3,4]

        Output 1:
            {15,10,13,16}

        Input 2:


        Output 2:


        */

        // CODE

        vector<int> Solution::solve(vector<vector<int> > &A) {
            if (A.empty() || A[0].empty()) {
                return {};
            }

            int rows = A.size();
            int cols = A[0].size();
            std::vector<int> colSums(cols, 0);

            for (int col = 0; col < cols; ++col) {
                for (int row = 0; row < rows; ++row) {
                    colSums[col] += A[row][col];
                }
            }

            return colSums;
        
        }
    // Q2. Main Diagonal Sum
        /*
        Q.2 -> You are given a N X N integer matrix. You have to find the sum of all the main diagonal elements of A.
        Main diagonal of a matrix A is a collection of elements A[i, j] such that i = j.

        Note :
            

        Problem Constraints
            1 <= N <= 10^3
            -1000 <= A[i][j] <= 1000  

        Input Format
            There are 1 lines in the input. First 2 integers R, C are the number of rows and columns. Then R * C integers follow corresponding to the rowwise numbers in the 2D array A.  

        Output Format
            Return an integer denoting the sum of main diagonal elements.

        Input 1:
            3 3 1 -2 -3 -4 5 -6 -7 -8 9

        Output 1:
            15

        Input 2:
            2 2 3 2 2 3

        Output 2:
            6

        */

        // CODE
        int Solution::solve(const vector<vector<int> > &A) {

            int N = A.size();
            int sum = 0;
            for(int i=0;i<N;i++){
                sum+=A[i][i];
            }

            return sum;
        }
    // Q3. Anti Diagonals
        /*
        Q.3 -> Give a N * N square matrix A, return an array of its anti-diagonals. Look at the example for more details.

        Note :
            

        Problem Constraints
            1<= N <= 1000
            1<= A[i][j] <= 1e9
            

        Input Format
            Only argument is a 2D array A of size N * N.   

        Output Format
            Return a 2D integer array of size (2 * N-1) * N, representing the anti-diagonals of input array A.
            The vacant spaces in the grid should be assigned to 0.    

        Input 1:
            1 2 3
            4 5 6
            7 8 9

        Output 1:
            1 0 0
            2 4 0
            3 5 7
            6 8 0
            9 0 0

        Input 2:
            1 2
            3 4

        Output 2:
            1 0
            2 3
            4 0

        */

        // CODE
        vector<vector<int> > Solution::diagonal(vector<vector<int> > &A) {

            int N = A.size();
            std::vector<std::vector<int>> diagonal_matrix(2*N-1, std::vector<int>(N));
            int di = 0;
            for (int c=0; c<=N-1;c++){
                int i=0;
                int j=c;
                int dj=0;
                while(i<N && j>=0){
                    diagonal_matrix[di][dj] = A[i][j];
                    i++;
                    j--;
                    dj++;

                }
                while(dj<N){
                    diagonal_matrix[di][dj] = 0;
                    dj++;
                }
                di++;
            }

            for (int r=1; r<=N-1;r++){
                int i=r;
                int j=N-1;
                int dj=0;
                while(i<N && j>=0){
                    diagonal_matrix[di][dj] = A[i][j];
                    i++;
                    j--;
                    dj++;

                }
                while(dj<N){
                    diagonal_matrix[di][dj] = 0;
                    dj++;
                }
                di++;
            }


            return diagonal_matrix;
        }
    // Q4. Matrix Transpose
        /*
        Q.4 -> Given a 2D integer array A, return the transpose of A.
        The transpose of a matrix is the matrix flipped over its main diagonal, switching the matrix's row and column indices.


        Note :
            

        Problem Constraints
            1 <= A.size() <= 1000
            1 <= A[i].size() <= 1000
            1 <= A[i][j] <= 1000  

        Input Format
            First argument is a 2D matrix of integers.  

        Output Format
            You have to return the Transpose of this 2D matrix.

        Input 1:
            A = [[1, 2, 3],[4, 5, 6],[7, 8, 9]]

        Output 1:
            [[1, 4, 7], [2, 5, 8], [3, 6, 9]]

        Input 2:
            A = [[1, 2],[1, 2],[1, 2]]

        Output 2:
            [[1, 1, 1], [2, 2, 2]]

        */

        // CODE
        vector<vector<int> > Solution::solve(vector<vector<int> > &A) {

            if (A.empty() || A[0].empty()) {
                return {};
            }

            int rows = A.size();
            int cols = A[0].size();
            std::vector<std::vector<int>> transposed(cols, std::vector<int>(rows));

            for (int row = 0; row < rows; ++row) {
                for (int col = 0; col < cols; ++col) {
                    transposed[col][row] = A[row][col];
                }
            }

            return transposed;
        }
    // Q5. Rotate Matrix
        /*
        Q.5 -> You are given a n x n 2D matrix A representing an image.
        Rotate the image by 90 degrees (clockwise).
        You need to do this in place.

        Note :
            If you end up using an additional array, you will only receive partial score. 

        Problem Constraints
            1 <= n <= 1000

        Input Format
            First argument is a 2D matrix A of integers  

        Output Format
            Return the 2D rotated matrix.

        Input 1:
            [
                [1, 2],
                [3, 4]
            ]

        Output 1:
            [
                [3, 1],
                [4, 2]
            ]

        Input 2:
            [
                [1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]
            ]

        Output 2:
            [
                [7, 4, 1],
                [8, 5, 2],
                [9, 6, 3]
            ]

        */

        // CODE
        void Solution::solve(vector<vector<int> > &A) {

            int N = A.size();

            // tanspose of A
            for (int i=0;i<N-1;i++){
                for (int j=i+1;j<=N-1;j++){
                    int temp = A[i][j];
                    A[i][j]= A[j][i];
                    A[j][i] = temp;
                }
            }

            for (int i=0;i<=N-1;i++){

                int ri = 0;
                int rj = (A[i].size()-1);


                while(ri<rj){
                    A[i][ri] = A[i][ri] + A[i][rj];
                    A[i][rj] = A[i][ri] - A[i][rj];
                    A[i][ri] = A[i][ri] - A[i][rj];
                
                    ri++;
                    rj--;
                }

            }
        }
    // Q1. Matrix Scalar Product
        /*
        Q.1 -> You are given a matrix A and and an integer B, you have to perform scalar multiplication of matrix A with an integer B.

        Note :
            

        Problem Constraints
            1 <= A.size() <= 1000
            1 <= A[i].size() <= 1000
            1 <= A[i][j] <= 1000
            1 <= B <= 1000

        Input Format
            First argument is 2D array of integers A representing matrix.
            Second argument is an integer B.

        Output Format
            You have to return a 2D array of integers after doing required operations.

        Input 1:
            A = [[1, 2, 3],
                [4, 5, 6],
                [7, 8, 9]]
            B = 2 

        Output 1:
            [[2, 4, 6], 
            [8, 10, 12], 
            [14, 16, 18]]

        Input 2:
            A = [[1]]
            B = 5 

        Output 2:
            [[5]]

        */

        // CODE
        vector<vector<int> > Solution::solve(vector<vector<int> > &A, int B) {

            for(int i=0;i<A.size();i++){
                for (int j=0; j<A[i].size();j++){
                    A[i][j] = A[i][j]*B;
                }
            }
            return A;
        }
    // Q2. Add the matrices
        /*
        Q.2 -> 
            You are given two matrices A & B of same size, you have to return another matrix which is the sum of A and B.

        Note :
            Matrices are of same size means the number of rows and number of columns of both matrices are equal.
            The Following will give you an idea of matrix addition:

        Problem Constraints
            1 <= A.size(), B.size() <= 1000 1 <= A[i].size(), B[i].size() <= 1000 1 <= A[i][j], B[i][j] <= 1000

        Input Format
            The first argument is the 2D integer array A The second argument is the 2D integer array B   

        Output Format
            You have to return a vector of vector of integers after doing required operations.

        Input 1:
            A = [[1, 2, 3],   
                [4, 5, 6],   
                [7, 8, 9]]  

            B = [[9, 8, 7],   
                [6, 5, 4],   
                [3, 2, 1]]

        Output 1:
            [[10, 10, 10],   
            [10, 10, 10],   
            [10, 10, 10]]

        Input 2:
            A = [[1, 2, 3],   
                [4, 1, 2],   
                [7, 8, 9]]  

            B = [[9, 9, 7],   
                [1, 2, 4],   
                [4, 6, 3]]

        Output 2:
            [[10, 11, 10],   
            [5,   3,  6],   
            [11, 14, 12]]

        */

        // CODE
        vector<vector<int> > Solution::solve(vector<vector<int> > &A, vector<vector<int> > &B) {

            for(int i=0;i<A.size();i++){
                for (int j=0; j<A[i].size();j++){
                    A[i][j] = A[i][j] + B[i][j];
                }
            }
            return A;
        }
    // Q3. Minor Diagonal Sum
        /*
        Q.3 -> 
            You are given a N X N integer matrix. You have to find the sum of all the minor diagonal elements of A.
            Minor diagonal of a M X M matrix A is a collection of elements A[i, j] such that i + j = M + 1 (where i, j are 1-based).
            
        Note :
            

        Problem Constraints
            1 <= N <= 10^3
            -1000 <= A[i][j] <= 1000

        Input Format
            First and only argument is a 2D integer matrix A.   

        Output Format
            Return an integer denoting the sum of minor diagonal elements.

        Input 1:
            A = [[1, -2, -3],
            [-4, 5, -6],
            [-7, -8, 9]]

        Output 1:
            -5

        Input 2:
            A = [[3, 2],
            [2, 3]]

        Output 2:
            4

        */

        // CODE
        int Solution::solve(const vector<vector<int> > &A) {

            int N = A.size();
            int sum = 0;

            for (int i = 0; i < N; ++i) {
                sum += A[i][N - i - 1];
            }

            return sum;
        }
    // Q4. Row Sum
        /*
        Q.4 ->  Row Sum

        Note :
            

        Problem Constraints
            1 <= A.size() <= 10^3
            1 <= A[i].size() <= 10^3
            1 <= A[i][j] <= 10^3

        Input Format
            First argument A is a 2D array of integers.(2D matrix).

        Output Format
            Return an array containing row-wise sums of original matrix.

        Input 1:
            [1,2,3,4]
            [5,6,7,8]
            [9,2,3,4]

        Output 1:
            [10,26,18]

        Input 2:


        Output 2:


        */

        // CODE
        vector<int> Solution::solve(vector<vector<int> > &A) {

            if (A.empty() || A[0].empty()) {
                return {};
            }

            std::vector<int> rowSums(A.size(), 0);

            for (int i =0; i<A.size();i++){
                int sum=0;
                for (int j=0; j<A[i].size();j++){
                    sum += A[i][j];
                }
                rowSums[i] = sum;
            }


            return rowSums;
        }

## One Dimensional ##
    // Q1. Max Sum Contiguous Subarray
        /*
        Q.1 -> Find the maximum sum of contiguous non-empty subarray within an array A of length N.

        Note :
            

        Problem Constraints
            1 <= N <= 1e6
            -1000 <= A[i] <= 1000

        Input Format
            The first and the only argument contains an integer array, A.

        Output Format
            Return an integer representing the maximum possible sum of the contiguous subarray.

        Input 1:
            A = [1, 2, 3, 4, -10] 

        Output 1:
            10

        Input 2:
            A = [-2, 1, -3, 4, -1, 2, 1, -5, 4] 


        Output 2:
            6

        */

        // CODE
        int Solution::maxSubArray(const vector<int> &A) {

            int ans = INT_MIN;
            int sum = 0;
            for (int i=0; i<A.size(); i++){
                sum +=A[i];
                if (ans < sum){
                    ans = sum;
                }

                if(sum < 0){
                    sum = 0;
                }
            }

            return ans;
        }
    // Q2. Continuous Sum Query
        /*

        Q.2 -> Problem Description
        There are A beggars sitting in a row outside a temple. Each beggar initially has an empty pot. When the devotees come to the temple, they donate some amount of coins to these beggars. Each devotee gives a fixed amount of coin(according to their faith and ability) to some K beggars sitting next to each other.

        Given the amount P donated by each devotee to the beggars ranging from L to R index, where 1 <= L <= R <= A, find out the final amount of money in each beggar's pot at the end of the day, provided they don't fill their pots by any other means.
        For ith devotee B[i][0] = L, B[i][1] = R, B[i][2] = P, given by the 2D array B

        Note :
            

        Problem Constraints
            1 <= A <= 2 * 10^5
            1 <= L <= R <= A
            1 <= P <= 10^3
            0 <= len(B) <= 10^5

        Input Format
            The first argument is a single integer A.
            The second argument is a 2D integer array B.

        Output Format
            Return an array(0 based indexing) that stores the total number of coins in each beggars pot.

        Input 1:
            A = 5
            B = [[1, 2, 10], [2, 3, 20], [2, 5, 25]]

        Output 1:
            10 55 45 25 25


        */

        // CODE
        vector<int> Solution::solve(int A, vector<vector<int> > &B) {

            vector<int> ans(A);

            for (int i=0;  i<B.size(); i++){
                int l = B[i][0] -1;
                int r = B[i][1] - 1;
                int x = B[i][2];

                ans[l] += x;
                if (r!=(A-1)){
                    ans[r+1] -= x;
                }
            }

            for (int i=1;  i<A; i++){
                ans[i] = ans[i-1] + ans[i];
            }

            return ans;
        }
    // Q3. Rain Water Trapped
        /*

        Q.3 -> Given a vector A of non-negative integers representing an elevation map where the width of each bar is 1, compute how much water it is able to trap after raining.

        Note :
            

        Problem Constraints
            1 <= |A| <= 100000

        Input Format
            First and only argument is the vector A    

        Output Format
            Return one integer, the answer to the question

        Input 1:
            A = [0, 1, 0, 2]


        Output 1:
            1

        Input 2:
            A = [1, 2]

        Output 2:
            0

        */

        // CODE
        int Solution::trap(const vector<int> &A) {

            int n = A.size();
            vector<int> lmax(n);
            lmax[0] = A[0];
            for (int i=1; i<n; i++){
                lmax[i] = std::max(lmax[i-1], A[i]);
            }

            vector<int> rmax(n);
            rmax[n-1] = A[n-1];
            for (int i=n-2; i>=0; i--){
                rmax[i] = std::max(rmax[i+1], A[i]);
            }

            int ans = 0;

            for (int i=1; i<n; i++){
                ans += std::min(lmax[i], rmax[i]) - A[i];

            }

            return ans;

        }
    // Q1. Add One To Number
        /*
        Q.1 -> Given a non-negative number represented as an array of digits, add 1 to the number ( increment the number represented by the digits ).

        The digits are stored such that the most significant digit is at the head of the list.

        NOTE: Certain things are intentionally left unclear in this question which you should practice asking the interviewer. For example: for this problem, the following are some good questions to ask :

        Q: Can the input have 0's before the most significant digit. Or, in other words, is 0 1 2 3 a valid input?
        A: For the purpose of this question, YES
        Q: Can the output have 0's before the most significant digit? Or, in other words, is 0 1 2 4 a valid output?
        A: For the purpose of this question, NO. Even if the input has zeroes before the most significant digit.

        Note :
            

        Problem Constraints
            1 <= size of the array <= 1000000

        Input Format
            First argument is an array of digits.  

        Output Format
            Return the array of digits after adding one.

        Input 1:
            [1, 2, 3]

        Output 1:
            [1, 2, 4]

        */

        // CODE
        vector<int> Solution::plusOne(vector<int> &A) {
            int n = A.size();
            int index = 0;
            while (index < n && A[index] == 0) {
                index++;
            }

            if (index == n) {
                return {1};
            }

            std::vector<int> result(A.begin() + index, A.end());

            n = result.size();
            for (int i = n - 1; i >= 0; --i) {
                if (result[i] == 9) {
                    result[i] = 0;
                } else {
                    result[i] += 1;
                    return result;
                }
            }
            result.insert(result.begin(), 1);
            return result;
        }
    // Q2. Flip
        /*
        Q.2 -> You are given a binary string A(i.e., with characters 0 and 1) consisting of characters A1, A2, ..., AN. In a single operation, you can choose two indices, L and R, such that 1  L  R  N and flip the characters AL, AL+1, ..., AR. By flipping, we mean changing character 0 to 1 and vice-versa.
        Your aim is to perform ATMOST one operation such that in the final string number of 1s is maximized.
        If you don't want to perform the operation, return an empty array. Else, return an array consisting of two elements denoting L and R. If there are multiple solutions, return the lexicographically smallest pair of L and R.

        NOTE: 
            Pair (a, b) is lexicographically smaller than pair (c, d) if a < c or, if a == c and b < d.
            

        Problem Constraints
            1 <= size of string <= 100000

        Input Format
            First and only argument is a string A.  

        Output Format
            Return an array of integers denoting the answer.

        Input 1:
            A = "010"

        Output 1:
            [1, 1]

        Input 2:
            A = "111"

        Output 2:
            []

        */

        // CODE
        vector<int> Solution::flip(string A) {
            int n = A.size();
            std::vector<int> transformed(n);
            
            for (int i = 0; i < n; ++i) {
                if (A[i] == '0') {
                    transformed[i] = 1;
                } else {
                    transformed[i] = -1;
                }
            }
            
            int max_sum = 0;
            int current_sum = 0;
            int start = 0;
            int temp_start = 0;
            int end = -1;
            
            for (int i = 0; i < n; ++i) {
                current_sum += transformed[i];
                
                if (current_sum > max_sum) {
                    max_sum = current_sum;
                    start = temp_start;
                    end = i;
                }
                
                if (current_sum < 0) {
                    current_sum = 0;
                    temp_start = i + 1;
                }
            }
            
            if (end == -1) {
                return {};
            }
            
            return {start + 1, end + 1};
        }

## Two Dimensional ##
    // Q1. Spiral Order Matrix II
        /*

        Q.1 -> Given an integer A, generate a square matrix filled with elements from 1 to A2 in spiral order and return the generated square matrix.

        Note :
            

        Problem Constraints
            1 <= A <= 1000

        Input Format
            First and only argument is integer A   

        Output Format
            Return a 2-D matrix which consists of the elements added in spiral order.

        Input 1:
            1

        Output 1:
            [ [1] ]

        Input 2:
            2

        Output 2:
            [
                [1, 2], 
                [4, 3]
            ]

        Input 3:
            5

        Output 3:
            [
                [1,   2,  3,  4, 5], 
                [16, 17, 18, 19, 6], 
                [15, 24, 25, 20, 7], 
                [14, 23, 22, 21, 8], 
                [13, 12, 11, 10, 9]
            ]

        */

        // CODE
        vector<vector<int> > Solution::generateMatrix(int A) {

            std::vector<std::vector<int>> matrix(A, std::vector<int>(A, 0));

            int r=0;
            int c=0;
            int count = 1;
            int N = A;
            while (N > 1){
                for (int i=1; i<N; i++){
                    matrix[r][c] = count;
                    count++;
                    c++;
                }
                for (int i=1; i<N; i++){
                    matrix[r][c] = count;
                    count++;
                    r++;
                }
                for (int i=1; i<N; i++){
                    matrix[r][c] = count;
                    count++;
                    c--;
                }
                for (int i=1; i<N; i++){
                    matrix[r][c] = count;
                    count++;
                    r   --;
                }

                r++;
                c++;
                N-=2;

            }
            if (N==1){
                matrix[r][c] = count;
            }
            return matrix;
        }
    // Q2. Search in a row wise and column wise sorted matrix
        /*

        Q.2 -> Given a matrix of integers A of size N x M and an integer B.
        In the given matrix every row and column is sorted in non-decreasing order. Find and return the position of B in the matrix in the given form:
        If A[i][j] = B then return (i * 1009 + j)
        If B is not present return -1.

        Note 1: Rows are numbered from top to bottom and columns are numbered from left to right.
        Note 2: If there are multiple B in A then return the smallest value of i*1009 +j such that A[i][j]=B.
        Note 3: Expected time complexity is linear
        Note 4: Use 1-based indexing

        Problem Constraints
            1 <= N, M <= 1000
            -100000 <= A[i] <= 100000
            -100000 <= B <= 100000

        Input Format
            The first argument given is the integer matrix A.
            The second argument given is the integer B.

        Output Format
            Return the position of B and if it is not present in A return -1 instead.

        Input 1:
            A = [[1, 2, 3]
                [4, 5, 6]
                [7, 8, 9]]
            B = 2

        Output 1:
            1011

        Input 2:
            A = [[1, 2]
            [3, 3]]
            B = 3

        Output 2:
            2019
        */

        // CODE
        int Solution::solve(vector<vector<int> > &A, int B) {
            int n = A.size();
            int m = A[0].size();
            int r = 0;
            int c = m-1;
            int result = INT_MAX;

            while(r<n && c>=0){
                if(A[r][c] == B){
                    int currentIndex = ((r + 1) * 1009 + (c + 1));
                    result = min(result, currentIndex);
                    c--;
                }else if(A[r][c] < B){
                    r++;
                }else{
                    c--;
                }
            }

            return (result == INT_MAX) ? -1 : result;
        }
    // Q3. Sum of all Submatrices
        /*
        Q.3 -> Given a 2D Matrix A of dimensions N*N, we need to return the sum of all possible submatrices.

        Note :
            

        Problem Constraints
            1 <= N <=30
            0 <= A[i][j] <= 10

        Input Format
            Single argument representing a 2-D array A of size N x N.

        Output Format
            Return an integer denoting the sum of all possible submatrices in the given matrix.

        Input 1:
            A = [ [1, 1]
            [1, 1] ]


        Output 1:
            16

        Input 2:
            A = [ [1, 2]
            [3, 4] ]

        Output 2:
            40

        */

        // CODE
        int Solution::solve(vector<vector<int> > &A) {

            int ans = 0;
            for (int i=0; i<A.size(); i++){
                for (int j=0; j<A[i].size(); j++){
                    ans += A[i][j] * ((i+1)* (j+1) * (A.size()-i) * (A[i].size() -j));
                }
            }
            
            return ans;
        }

    // Q4. Row with maximum number of ones
        /*

        Q.4 -> 
        Given a binary sorted matrix A of size N x N. Find the row with the maximum number of 1.

        NOTE:

        If two rows have the maximum number of 1 then return the row which has a lower index.
        Rows are numbered from top to bottom and columns are numbered from left to right.
        Assume 0-based indexing.
        Assume each row to be sorted by values.
        Expected time complexity is O(rows + columns).


        Problem Constraints
            1 <= N <= 1000
            0 <= A[i] <= 1

        Input Format
            The only argument given is the integer matrix A.

        Output Format
            Return the row with the maximum number of 1.

        Input 1:
            A = [   [0, 1, 1]
                [0, 0, 1]
                [0, 1, 1]   ]

        Output 1:
            0

        Input 2:
            A = [   [0, 0, 0, 0]
                [0, 0, 0, 1]
                [0, 0, 1, 1]
                [0, 1, 1, 1]    ]

        Output 2:
            3

        */

        // CODE
        int Solution::solve(vector<vector<int> > &A) {
            int ans = 0;
            int r = 0;
            int n = A.size();
            int c = A[0].size()-1;

            while(r < n && c >=0){
                while(c>=0 && A[r][c] == 1){
                    c--;
                    ans = r;
                }
                r++;
            }

            return ans;

        }
    // Q1. Minimum Swaps
        /*

        Q.1 -> Given an array of integers A and an integer B, find and return the minimum number of swaps required to bring all the numbers less than or equal to B together.

        Note: It is possible to swap any two elements, not necessarily consecutive

        Problem Constraints
            1 <= length of the array <= 100000
            -10^9 <= A[i], B <= 10^9

        Input Format
            The first argument given is the integer array A.
            The second argument given is the integer B.

        

        Output Format
            Return the minimum number of swaps.

        Input 1:
            A = [1, 12, 10, 3, 14, 10, 5]
            B = 8

        Output 1:
            2

        Input 2:
            A = [5, 17, 100, 11]
            B = 20

        Output 2:
            1

        */

        // CODE
        int Solution::solve(vector<int> &A, int B) {

            int n = A.size();
            int count = 0;

            // Step 1: Count elements <= B
            for (int i = 0; i < n; i++) {
                if (A[i] <= B) {
                    count++;
                }
            }

            // If no elements are <= B, no swaps needed
            if (count == 0) return 0;

            // Step 2: Use sliding window to find the minimum number of elements > B in any window of size count
            int bad = 0; // Elements > B in the current window
            for (int i = 0; i < count; i++) {
                if (A[i] > B) {
                    bad++;
                }
            }

            int min_swaps = bad;

            // Slide the window across the array
            for (int i = 0, j = count; j < n; i++, j++) {
                if (A[i] > B) {
                    bad--;
                }
                if (A[j] > B) {
                    bad++;
                }
                min_swaps = std::min(min_swaps, bad);
            }

            return min_swaps;
        }


## Interview Problems ##
    // Q1. Length of longest consecutive ones
        /*
        Q.1 -> Given a binary string A. It is allowed to do at most one swap between any 0 and 1. Find and return the length of the longest consecutive 1s that can be achieved.
        
        Problem Constraints
            1 <= length of string <= 1000000
            A contains only characters 0 and 1.

        Input Format
            The only argument given is string A.
            

        Output Format
            Return the length of the longest consecutive 1s that can be achieved.

        Input 1:
            A = "111000"

        Output 1:
            3

        Input 2:
            A = "111011101"

        Output 2:
            7

        */

        // CODE
        int Solution::solve(string A) {

            int one = 0;
            int n = A.size();
            for (int i = 0; i < n; i++) {
                if (A[i] == '1') {
                    one++;
                }
            }

            // If all characters are '1'
            if (one == n) {
                return one;
            }

            int ans = 0;
            for (int i = 0; i < n; i++) {
                if (A[i] == '0') {
                    int l = 0;
                    // Count consecutive 1's on the left of '0'
                    for (int j = i - 1; j >= 0; j--) {
                        if (A[j] == '1') {
                            l++;
                        } else {
                            break;
                        }
                    }

                    int r = 0;
                    // Count consecutive 1's on the right of '0'
                    for (int j = i + 1; j < n; j++) {
                        if (A[j] == '1') {
                            r++;
                        } else {
                            break;
                        }
                    }

                    // Maximum consecutive 1's we can get by swapping this '0'
                    int total_ones = l + r + 1;
                    // If total_ones exceeds the actual number of 1's, adjust it
                    total_ones = min(total_ones, one);

                    ans = max(ans, total_ones);
                }
            }

            return ans;
        }
    // Q2. Majority Element
        /*
        Q.2 -> Given an array of size N, find the majority element. The majority element is the element that appears more than floor(n/2) times.
        You may assume that the array is non-empty and the majority element always exists in the array.

        Note :
            

        Problem Constraints
            1 <= N <= 5*10^5
            1 <= num[i] <= 10^9

        Input Format
            Only argument is an integer array.        

        Output Format
            Return an integer.

        Input 1:
            [2, 1, 2]

        Output 1:
            2

        Input 2:
            [1, 1, 1]

        Output 2:
            1

        */

        // CODE
        int Solution::majorityElement(const vector<int> &A) {
            int m = -1;
            int f = 0;
            long n = A.size();
            for (long i=0; i<n; i++){
                if(f==0){
                    m=A[i];
                    f++;
                }else if(A[i] == m){
                    f++;
                }else{
                    f--;
                }
            }

            f = 0;
            for (long i=0; i<n; i++){
                if(A[i] == m){
                    f++;
                }
            }

            if(f > n/2){
                return m;
            }else{
                return -1;
            }
        }
    // Q3. Count Increasing Triplets
        /*
        Q.3 -> You are given an array A of N elements. Find the number of triplets i,j and k such that i<j<k and A[i]<A[j]<A[k]

        Note :
            

        Problem Constraints
            1 <= N <= 10^3
            1 <= A[i] <= 10^9

        Input Format
            First argument A is an array of integers.    

        Output Format
            Return an integer.

        Input 1:
            A = [1, 2, 4, 3]

        Output 1:
            2

        Input 2:
            A = [2, 1, 2, 3]

        Output 2:
            1

        */

        // CODE
        int Solution::solve(vector<int> &A) {
            int n = A.size();
            if (n < 3) return 0;
            
            vector<int> left_smaller(n, 0);
            vector<int> right_larger(n, 0);

            // Fill left_smaller array
            for (int j = 1; j < n; ++j) {
                for (int i = 0; i < j; ++i) {
                    if (A[i] < A[j]) {
                        left_smaller[j]++;
                    }
                }
            }

            // Fill right_larger array
            for (int j = 0; j < n - 1; ++j) {
                for (int k = j + 1; k < n; ++k) {
                    if (A[j] < A[k]) {
                        right_larger[j]++;
                    }
                }
            }

            // Calculate the number of valid triplets
            int triplet_count = 0;
            for (int j = 0; j < n; ++j) {
                triplet_count += left_smaller[j] * right_larger[j];
            }

            return triplet_count;
        }
    // Q1. N/3 Repeat Number
        /*
        Q.1 -> You're given a read-only array of N integers. Find out if any integer occurs more than N/3 times in the array in linear time and constant additional space.
        If so, return the integer. If not, return -1.

        If there are multiple solutions, return any one.

        Note: Read-only array means that the input array should not be modified in the process of solving the problem
            

        Problem Constraints
            1 <= N <= 7*10^5
            1 <= A[i] <= 10^9

        Input Format
            The only argument is an integer array A.     

        Output Format
            Return an integer.

        Input 1:
            [1 2 3 1 1]

        Output 1:
            1

        Input 2:
            [1 2 3]

        Output 2:
            -1

        */

        // CODE
        int Solution::repeatedNumber(const vector<int> &A) {
            // Do not write main() function.
            // Do not read input, instead use the arguments to the function.
            // Do not print the output, instead return values as specified
            // Still have a doubt. Checkout www.interviewbit.com/pages/sample_codes/ for more details

            int n = A.size();
            if (n == 0) return -1;

            // Step 1: Find potential candidates
            int candidate1 = 0, candidate2 = 0, count1 = 0, count2 = 0;

            for (int num : A) {
                if (candidate1 == num) {
                    count1++;
                } else if (candidate2 == num) {
                    count2++;
                } else if (count1 == 0) {
                    candidate1 = num;
                    count1 = 1;
                } else if (count2 == 0) {
                    candidate2 = num;
                    count2 = 1;
                } else {
                    count1--;
                    count2--;
                }
            }

            // Step 2: Verify the candidates
            count1 = 0;
            count2 = 0;

            for (int num : A) {
                if (num == candidate1) {
                    count1++;
                } else if (num == candidate2) {
                    count2++;
                }
            }

            if (count1 > n / 3) return candidate1;
            if (count2 > n / 3) return candidate2;

            return -1;
        }
    // Q2. Check anagrams
        /*
        Q.2 -> You are given two lowercase strings A and B each of length N. Return 1 if they are anagrams to each other and 0 if not.

        Note : Two strings A and B are called anagrams to each other if A can be formed after rearranging the letters of B.

        Note :
            

        Problem Constraints
            1 <= N <= 10^5
            A and B are lowercase strings

        Input Format
            Both arguments A and B are a string. 

        Output Format
            Return 1 if they are anagrams and 0 if not

        Input 1:
            A = "cat"
            B = "bat"

        Output 1:
            A = "secure"
            B = "rescue"

        Input 2:
            0

        Output 2:
            1

        */

        // CODE
        int Solution::solve(string A, string B) {

            if (A.length() != B.length()) {
                return 0;
            }

            std::vector<int> freqA(26, 0);
            std::vector<int> freqB(26, 0);

            for (int i = 0; i < A.length(); ++i) {
                freqA[A[i] - 'a']++;
                freqB[B[i] - 'a']++;
            }

            for (int i = 0; i < 26; ++i) {
                if (freqA[i] != freqB[i]) {
                    return 0;
                }
            }

            return 1;
        }
    // Q3. Colorful Number
        /*
        Q.3 -> Given a number A, find if it is COLORFUL number or not.

        If number A is a COLORFUL number return 1 else, return 0.

        What is a COLORFUL Number:

        A number can be broken into different consecutive sequence of digits. 
        The number 3245 can be broken into sequences like 3, 2, 4, 5, 32, 24, 45, 324, 245 and 3245. 
        This number is a COLORFUL number, since the product of every consecutive sequence of digits is different

        Note :
            

        Problem Constraints
            1 <= A <= 2 * 109

        Input Format
            The first and only argument is an integer A.

        Output Format
            Return 1 if integer A is COLORFUL else return 0.

        Input 1:
            A = 23

        Output 1:
            1

        Input 2:
            A = 236

        Output 2:
            0

        */

        // CODE
        int Solution::colorful(int A) {
            std::string num = std::to_string(A);
            std::unordered_set<long long> productSet;

            for (int i = 0; i < num.size(); ++i) {
                long long product = 1;
                for (int j = i; j < num.size(); ++j) {
                    product *= (num[j] - '0');
                    if (productSet.find(product) != productSet.end()) {
                        return 0;
                    }
                    productSet.insert(product);
                }
            }

            return 1;
        }

    // Q1. First Missing Integer
        /*
        Q.1 -> Given an unsorted integer array, A of size N. Find the first missing positive integer.

        Note : Your algorithm should run in O(n) time and use constant space.
            

        Problem Constraints
            1 <= N <= 1000000
            -109 <= A[i] <= 10^9

        Input Format
            First argument is an integer array A.

        Output Format
            Return an integer denoting the first missing positive integer.

        Input 1:
            [1, 2, 0]

        Output 1:
            3

        Input 2:
            [3, 4, -1, 1]

        Output 2:
            2

        Input 3:
            [-8, -7, -6]

        Output 3:
            1

        */

        // CODE
        int Solution::firstMissingPositive(vector<int> &A) {

            int N = A.size();

            // Place each number in its correct position
            for (int i = 0; i < N; ++i) {
                while (A[i] > 0 && A[i] <= N && A[i] != A[A[i] - 1]) {
                    std::swap(A[i], A[A[i] - 1]);
                }
            }

            // Find the first index which does not have the correct number
            for (int i = 0; i < N; ++i) {
                if (A[i] != i + 1) {
                    return i + 1;
                }
            }

            // If all positions are filled with correct numbers, the missing number is N + 1
            return N + 1;
        }
    // Q2. Merge Sorted Overlapping Intervals - 2
        /*
        Q.2 -> You are given a collection of intervals A in a 2-D array format, where each interval is represented by a pair of integers `[start, end]`. The intervals are sorted based on their start values.
        Your task is to merge all overlapping intervals and return the resulting set of non-overlapping intervals.

        Note :
            

        Problem Constraints
            1 <= len(A) <= 100000.
            1 <= A[i][0] <= A[i][1] <= 100000
            A is sorted based on the start value (A[i][0])

        Input Format
            First argument is a list of intervals in 2-Dimentional Array.    

        Output Format
            Return the sorted list of intervals after merging all the overlapping intervals.

        Input 1:
            [ [1, 3], [2, 6], [8, 10], [15, 18] ]

        Output 1:
            [ [1, 6], [8, 10], [15, 18] ]

        Input 2:
            [ [2, 10], [4, 9], [6, 7] ]

        Output 2:
            [ [2, 10] ]

        */

        // CODE
        vector<vector<int> > Solution::solve(vector<vector<int> > &A) {

            long N = A.size();

            if (N == 0) return {};
            std::vector<std::vector<int>> result;

            std::vector<int> current_array = A[0];
            for (long i=1; i<N; i++){
                if(A[i][0] <= current_array[1]){
                    // overlap
                    // merge
                    current_array[1] = std::max(current_array[1], A[i][1]);
                }else{
                    result.push_back(current_array);
                    current_array[0] = A[i][0];
                    current_array[1] = A[i][1];
                }
            }

            result.push_back(current_array);

            return result;
        }
    // Q3. Merge Intervals - 2
        /*
        Q.3 -> You have a set of non-overlapping intervals. You are given a new interval [start, end], insert this new interval into the set of intervals (merge if necessary).
        You may assume that the intervals were initially sorted according to their start times.

        Note :
            

        Problem Constraints
            0 <= |intervals| <= 10^5

        Input Format
            First argument is the vector of intervals
            second argument is the new interval to be merged

        Output Format
            Return the vector of intervals after merging

        Input 1:
            Given intervals [1, 3], [6, 9] insert and merge [2, 5]

        Output 1:
            [ [1, 5], [6, 9] ]

        Input 2:
            Given intervals [1, 3], [6, 9] insert and merge [2, 6] .

        Output 2:
            [ [1, 9] ]

        */

        // CODE
        vector<vector<int> > Solution::insert(vector<vector<int> > &A, vector<int> &B) {

            int N = A.size();

            std::vector<std::vector<int>> result;
            if (N == 0) {
                result.push_back(B);
                return result;
            }

            bool inserted = false;

            for (int i = 0; i < N; ++i) {
                if (A[i][1] < B[0]) {
                    // The current interval ends before the new interval starts, add it to the result
                    result.push_back(A[i]);
                } else if (A[i][0] > B[1]) {
                    // The current interval starts after the new interval ends, add the new interval first if not done already
                    if (!inserted) {
                        result.push_back(B);
                        inserted = true;
                    }
                    result.push_back(A[i]);
                } else {
                    // The intervals overlap, merge them
                    B[0] = std::min(B[0], A[i][0]);
                    B[1] = std::max(B[1], A[i][1]);
                }
            }

            // Add the merged interval if it hasn't been added yet
            if (!inserted) {
                result.push_back(B);
            }

            return result;
        }
    // Q1. Next Permutation
        /*
        Q.1 -> Implement the next permutation, which rearranges numbers into the numerically next greater permutation of numbers for a given array A of size N.
        If such arrangement is not possible, it must be rearranged as the lowest possible order, i.e., sorted in ascending order.

        Note :
            The replacement must be in-place, do not allocate extra memory.
            DO NOT USE LIBRARY FUNCTION FOR NEXT PERMUTATION. Use of Library functions will disqualify your submission retroactively and will give you penalty points.

        Problem Constraints
            1 <= N <= 5 * 10^5
            1 <= A[i] <= 10^9

        Input Format
            The first and the only argument of input has an array of integers, A.

        Output Format
            Return an array of integers, representing the next permutation of the given array.

        Input 1:
            A = [1, 2, 3]

        Output 1:
            [1, 3, 2]

        Input 2:
            A = [3, 2, 1]

        Output 2:
            [1, 2, 3]

        */

        // CODE
        vector<int> Solution::nextPermutation(vector<int> &A) {

            int n = A.size();
            if (n <= 1) return A;

            int i = n - 2;

            // Step 1: Find the pivot
            while (i >= 0 && A[i] >= A[i + 1]) {
                i--;
            }

            if (i >= 0) {
                // Step 2: Find the successor
                int j = n - 1;
                while (A[j] <= A[i]) {
                    j--;
                }
                // Step 3: Swap pivot and successor
                swap(A[i], A[j]);
            }

            // Step 4: Reverse the suffix
            reverse(A.begin() + i + 1, A.end());

            return A;
            
        }
    // Q2. Number of Digit One
        /*
        Q.2 -> Given an integer A, find and return the total number of digit 1 appearing in all non-negative integers less than or equal to A.

        Note :
            

        Problem Constraints
            0 <= A <= 10^9

        Input Format
            The only argument given is the integer A.

        Output Format
            Return the total number of digit 1 appearing in all non-negative integers less than or equal to A.

        Input 1:
            A = 10

        Output 1:
            2

        Input 2:
            A = 11

        Output 2:
            4

        */

        // CODE
        int Solution::solve(int A) {
            if (A < 0) return 0;
            
            int count = 0;
            long long factor = 1; // factor represents 10^d where d is the digit place (units, tens, hundreds, etc.)
            
            while (factor <= A) {
                long long lowerNumbers = A % factor;
                long long currentDigit = (A / factor) % 10;
                long long higherNumbers = A / (factor * 10);
                
                // Count the number of 1's contributed by the current digit place
                if (currentDigit < 1) {
                    count += higherNumbers * factor;
                } else if (currentDigit == 1) {
                    count += higherNumbers * factor + lowerNumbers + 1;
                } else {
                    count += (higherNumbers + 1) * factor;
                }
                
                factor *= 10;
            }
            
            return count;
        }

## Array Extra ##
    // Introduction to array
        // Largest Element in an Array
            int largestElement(const vector<int>& A) {
                int largest = INT_MIN;
                for (int i = 0; i < A.size(); i++) {
                    if (A[i] > largest) {
                        largest = A[i];
                    }
                }
                return largest;
            }
        // Second Largest Element in an array
            int secondLargestElement(const vector<int>& A) {
                int largest = INT_MIN;
                int secondLargest = INT_MIN;

                for (int i = 0; i < A.size(); i++) {
                    if (A[i] > largest) {
                        secondLargest = largest;
                        largest = A[i];
                    } else if (A[i] > secondLargest && A[i] < largest) {
                        secondLargest = A[i];
                    }
                }
                return secondLargest;
            }
        // Check if the array is sorted
            bool isArraySorted(const vector<int>& Arr) {
                for (int i = 1; i < Arr.size(); i++) {
                    if (Arr[i] < Arr[i - 1]) {
                        return false;  // Return false if the current element is less than the previous one
                    }
                }
                return true;  // Return true if the array is sorted
            }
        // Remove duplicates from an array (inplace)
            vector<int> removeDuplicatesInPlace(vector<int>& arr) {
                if (arr.empty()) return arr;
                
                int i = 0;
                for (int j = 1; j < arr.size(); j++) {
                    if (arr[i] != arr[j]) {
                        i++;
                        arr[i] = arr[j];
                    }
                }
                arr.resize(i + 1);  // Resize the array to exclude duplicates
                return arr;
            }
    // Rotate Array by K places | Union, Intersection of Sorted Arrays
        // Left Rotate Array by 1 place
            // Solution
                std::vector<int> leftRotateByOne(std::vector<int>& arr) {
                    int temp = arr[0]; // Store the first element
                    for (int i = 1; i < arr.size(); ++i) {
                        arr[i - 1] = arr[i]; // Shift elements left
                    }
                    arr[arr.size() - 1] = temp; // Place the first element at the end
                    return arr;
                }
        // Left Rotate Array by D Place
            // Solution 1 
                std::vector<int> leftRotateByD(std::vector<int>& arr, int d) {
                    int n = arr.size();
                    d = d % n; // Handle rotations larger than array size
                    std::vector<int> temp(d);
                    
                    // Store first d elements in temp
                    for (int i = 0; i < d; ++i) {
                        temp[i] = arr[i];
                    }
                    
                    // Shift the rest of the elements
                    for (int i = d; i < n; ++i) {
                        arr[i - d] = arr[i];
                    }
                    
                    // Copy elements from temp to the end of arr
                    for (int i = 0; i < d; ++i) {
                        arr[n - d + i] = temp[i];
                    }
                    
                    return arr;
                }
            // Solution 2
                void reverse(std::vector<int>& arr, int start, int end) {
                    while (start < end) {
                        std::swap(arr[start], arr[end]);
                        start++;
                        end--;
                    }
                }

                std::vector<int> leftRotateByDOptimal(std::vector<int>& arr, int d) {
                    int n = arr.size();
                    d = d % n; // Handle rotations larger than array size
                    reverse(arr, 0, d - 1);    // Reverse first d elements
                    reverse(arr, d, n - 1);    // Reverse remaining elements
                    reverse(arr, 0, n - 1);    // Reverse the entire array
                    return arr;
                }
        // Move all Zeros to the end of the array
            // Solution 1
                std::vector<int> moveZerosToEnd(std::vector<int>& arr) {
                    std::vector<int> temp;
                    for (int i = 0; i < arr.size(); ++i) {
                        if (arr[i] != 0) {
                            temp.push_back(arr[i]); // Collect non-zero elements
                        }
                    }
                    
                    // Fill remaining positions with 0
                    for (int i = 0; i < temp.size(); ++i) {
                        arr[i] = temp[i];
                    }
                    for (int i = temp.size(); i < arr.size(); ++i) {
                        arr[i] = 0;
                    }
                    
                    return arr;
                }
            // Solution 2
                std::vector<int> moveZerosToEndOptimal(std::vector<int>& arr) {
                    int j = -1; // Position of the first zero
                    
                    // Find the first zero
                    for (int i = 0; i < arr.size(); ++i) {
                        if (arr[i] == 0) {
                            j = i;
                            break;
                        }
                    }
                    
                    // Move non-zero elements to the front
                    for (int i = j + 1; i < arr.size(); ++i) {
                        if (arr[i] != 0) {
                            std::swap(arr[i], arr[j]);
                            j++;
                        }
                    }
                    
                    return arr;
                }
        // Linear Search
            int linearSearch(const std::vector<int>& arr, int target) {
                for (int i = 0; i < arr.size(); ++i) {
                    if (arr[i] == target) {
                        return i; // Found the target element
                    }
                }
                return -1; // Element not found
            }
        // Union of Two sorted Array
            // Solution 1
                std::vector<int> unionOfSortedArrays(const std::vector<int>& a, const std::vector<int>& b) {
                    std::set<int> unionSet(a.begin(), a.end());
                    unionSet.insert(b.begin(), b.end());
                    return std::vector<int>(unionSet.begin(), unionSet.end());
                }
            // Solution 2
                std::vector<int> unionOfSortedArraysOptimal(const std::vector<int>& a, const std::vector<int>& b) {
                    int i = 0, j = 0;
                    std::vector<int> unionResult;
                    while (i < a.size() && j < b.size()) {
                        if (a[i] <= b[j]) {
                            if (unionResult.empty() || unionResult.back() != a[i]) {
                                unionResult.push_back(a[i]);
                            }
                            i++;
                        } else {
                            if (unionResult.empty() || unionResult.back() != b[j]) {
                                unionResult.push_back(b[j]);
                            }
                            j++;
                        }
                    }
                    while (i < a.size()) {
                        if (unionResult.empty() || unionResult.back() != a[i]) {
                            unionResult.push_back(a[i]);
                        }
                        i++;
                    }
                    while (j < b.size()) {
                        if (unionResult.empty() || unionResult.back() != b[j]) {
                            unionResult.push_back(b[j]);
                        }
                        j++;
                    }
                    return unionResult;
                }
        // Intersection of Two sorted Array
            // Solution 
                std::vector<int> intersectionOfSortedArrays(const std::vector<int>& a, const std::vector<int>& b) {
                    int i = 0, j = 0;
                    std::vector<int> intersectionResult;
                    while (i < a.size() && j < b.size()) {
                        if (a[i] < b[j]) {
                            i++;
                        } else if (b[j] < a[i]) {
                            j++;
                        } else {
                            if (intersectionResult.empty() || intersectionResult.back() != a[i]) {
                                intersectionResult.push_back(a[i]);
                            }
                            i++;
                            j++;
                        }
                    }
                    return intersectionResult;
                }    
    // Find element that appears once | Find missing number | Max Consecutive number of 1's | Arrays Part-3
        // Missing NO
            int missingNumberBruteForce(const vector<int>& arr, int N) {
                for (int num = 1; num <= N + 1; num++) {
                    bool found = false;
                    for (int i = 0; i < N; i++) {
                        if (arr[i] == num) {
                            found = true;
                            break;
                        }
                    }
                    if (!found) return num;
                }
                return -1; // Should never reach here
            }

            int missingNumberBetter(const vector<int>& arr, int N) {
                vector<bool> found(N + 2, false);
                for (int num : arr) {
                    found[num] = true;
                }
                for (int num = 1; num <= N + 1; num++) {
                    if (!found[num]) return num;
                }
                return -1; // Should never reach here
            }

            int missingNumberSum(const vector<int>& arr, int N) {
                int totalSum = (N + 1) * (N + 2) / 2;
                int arraySum = 0;
                for (int num : arr) {
                    arraySum += num;
                }
                return totalSum - arraySum;
            }

            int missingNumberXor(const vector<int>& arr, int N) {
                int xorN = 0, xorA = 0;
                for (int i = 1; i <= N + 1; i++) {
                    xorN ^= i;
                }
                for (int num : arr) {
                    xorA ^= num;
                }
                return xorN ^ xorA;
            }
        // Maximum Consucutive one's
            int findMaxConsecutiveOnes(const vector<int>& arr) {
                int maxCnt = 0; // To store the maximum count of consecutive 1's
                int cnt = 0;    // To store the current streak of 1's

                for (int num : arr) {
                    if (num == 1) {
                        cnt++;
                        maxCnt = max(maxCnt, cnt); // Update maxCnt if cnt is greater
                    } else {
                        cnt = 0; // Reset count when encountering a 0
                    }
                }

                return maxCnt;
            }
    // Longest Subarray with sum K | Brute - Better - Optimal | Generate Subarrays
        // Genrating all Subarray
            int longestSubarrayBruteForce(const vector<int>& A, int K) {
                int maxLen = 0;
                int N = A.size();
                for (int i = 0; i < N; i++) {
                    for (int j = i; j < N; j++) {
                        int sum = 0;
                        for (int k = i; k <= j; k++) {
                            sum += A[k];
                        }
                        if (sum == K) {
                            maxLen = max(maxLen, j - i + 1);
                        }
                    }
                }
                return maxLen;
            }
        // Carry Forward
            int longestSubarrayCarryForward(const vector<int>& A, int K) {
                int maxLen = 0;
                int N = A.size();
                for (int i = 0; i < N; i++) {
                    int sum = 0;
                    for (int j = i; j < N; j++) {
                        sum += A[j];
                        if (sum == K) {
                            maxLen = max(maxLen, j - i + 1);
                        }
                    }
                }
                return maxLen;
            }
        // Better (Using Hashing and Prefix Sum)
            int longestSubarrayHashing(const vector<int>& A, int K) {
                unordered_map<int, int> prefixMap; // (prefix_sum, index)
                int maxLen = 0;
                int prefixSum = 0;

                for (int i = 0; i < A.size(); i++) {
                    prefixSum += A[i];

                    // If the prefix sum is equal to K, the subarray starts from index 0
                    if (prefixSum == K) {
                        maxLen = i + 1;
                    }

                    // If (prefixSum - K) is found, update maxLen
                    if (prefixMap.find(prefixSum - K) != prefixMap.end()) {
                        maxLen = max(maxLen, i - prefixMap[prefixSum - K]);
                    }

                    // Store prefix sum in the map if not already present
                    if (prefixMap.find(prefixSum) == prefixMap.end()) {
                        prefixMap[prefixSum] = i;
                    }
                }

                return maxLen;
            }
        // Optimal (Two pointer)
            int longestSubarrayTwoPointers(const vector<int>& A, int K) {
                int L = 0, R = 0, sum = 0, maxLen = 0;

                while (R < A.size()) {
                    // Expand the window by adding A[R]
                    sum += A[R];

                    // Shrink the window from the left if sum exceeds K
                    while (sum > K && L <= R) {
                        sum -= A[L];
                        L++;
                    }

                    // Check if we have a valid subarray with sum == K
                    if (sum == K) {
                        maxLen = max(maxLen, R - L + 1);
                    }

                    // Move the right pointer
                    R++;
                }

                return maxLen;
            }
    // 2 Sum Problem
        // Brute Force Solution (O(N))
            pair<int, int> twoSumBruteForce(vector<int>& nums, int K) {
                int N = nums.size();
                for (int i = 0; i < N - 1; i++) {
                    for (int j = i + 1; j < N; j++) {
                        if (nums[i] + nums[j] == K) {
                            return {i, j}; // Return the indices
                        }
                    }
                }
                return {-1, -1}; // No solution found
            }
        // Better Solution (Hashing - O(N))
            pair<int, int> twoSumHashing(vector<int>& nums, int K) {
                unordered_map<int, int> hashmap; // Stores {value, index}
                for (int i = 0; i < nums.size(); i++) {
                    int complement = K - nums[i];
                    if (hashmap.find(complement) != hashmap.end()) {
                        return {hashmap[complement], i}; // Found the pair
                    }
                    hashmap[nums[i]] = i; // Store the current element in the map
                }
                return {-1, -1}; // No solution found
            }
        // Optimal Solution (Two Pointers - O(N))
            pair<int, int> twoSumTwoPointers(vector<int>& nums, int K) {
                vector<pair<int, int>> sortedNums; // Store value and original index
                for (int i = 0; i < nums.size(); i++) {
                    sortedNums.push_back({nums[i], i});
                }

                sort(sortedNums.begin(), sortedNums.end()); // Sort based on value

                int L = 0, R = sortedNums.size() - 1;
                while (L < R) {
                    int sum = sortedNums[L].first + sortedNums[R].first;
                    if (sum == K) {
                        return {sortedNums[L].second, sortedNums[R].second}; // Return original indices
                    } else if (sum < K) {
                        L++; // Increase left pointer
                    } else {
                        R--; // Decrease right pointer
                    }
                }
                return {-1, -1}; // No solution found
            }
    // Sort an array of 0's 1's & 2's 
        void sortArray(vector<int>& arr) {
            sort(arr.begin(), arr.end());
        }

        void sortArrayByCounting(vector<int>& arr) {
            int count0 = 0, count1 = 0, count2 = 0;

            for (int num : arr) {
                if (num == 0) count0++;
                else if (num == 1) count1++;
                else count2++;
            }

            int index = 0;
            while (count0--) arr[index++] = 0;
            while (count1--) arr[index++] = 1;
            while (count2--) arr[index++] = 2;
        }

        void sortArrayDutchNationalFlag(vector<int>& arr) {
            int low = 0, mid = 0, high = arr.size() - 1;

            while (mid <= high) {
                if (arr[mid] == 0) {
                    swap(arr[low], arr[mid]);
                    low++;
                    mid++;
                } else if (arr[mid] == 1) {
                    mid++;
                } else { // arr[mid] == 2
                    swap(arr[mid], arr[high]);
                    high--;
                }
            }
        }
    // Majority Element I
        int majorityElementBruteForce(vector<int>& arr) {
            int n = arr.size();

            for (int i = 0; i < n; i++) {
                int count = 0;
                for (int j = 0; j < n; j++) {
                    if (arr[j] == arr[i]) count++;
                }
                if (count > n / 2) return arr[i];
            }
            return -1; // Shouldn't reach here if a majority element is guaranteed.
        }

        int majorityElementHashing(vector<int>& arr) {
            unordered_map<int, int> count;
            int n = arr.size();

            for (int num : arr) {
                count[num]++;
                if (count[num] > n / 2) return num;
            }
            return -1; // Shouldn't reach here if a majority element is guaranteed.
        }

        int majorityElementMooreVoting(vector<int>& arr) {
            int candidate = -1, count = 0;

            // First pass: Find a candidate
            for (int num : arr) {
                if (count == 0) {
                    candidate = num;
                    count = 1;
                } else if (num == candidate) {
                    count++;
                } else {
                    count--;
                }
            }

            // Second pass: Verify the candidate (optional if majority is guaranteed)
            count = 0;
            for (int num : arr) {
                if (num == candidate) count++;
            }

            if (count > arr.size() / 2) return candidate;
            return -1; // Shouldn't reach here if a majority element is guaranteed.
        }
    // Kadane's Algorithm | Maximum Subarray Sum | Finding and Printing
        // BruteForce
        int maxSubarraySumBruteForce(vector<int>& arr) {
            int n = arr.size();
            int maxSum = INT_MIN;

            for (int start = 0; start < n; ++start) {
                for (int end = start; end < n; ++end) {
                    int currentSum = 0;
                    for (int k = start; k <= end; ++k) {
                        currentSum += arr[k];
                    }
                    maxSum = max(maxSum, currentSum);
                }
            }
            return maxSum;
        }
        // Better
        int maxSubarraySumBetter(vector<int>& arr) {
            int n = arr.size();
            int maxSum = INT_MIN;

            for (int start = 0; start < n; ++start) {
                int currentSum = 0;
                for (int end = start; end < n; ++end) {
                    currentSum += arr[end];
                    maxSum = max(maxSum, currentSum);
                }
            }
            return maxSum;
        }

        // kadane's Algo
        pair<int, vector<int>> maxSubarraySumKadane(vector<int>& arr) {
            int maxSum = INT_MIN, currentSum = 0;
            int start = 0, end = 0, tempStart = 0;

            for (int i = 0; i < arr.size(); ++i) {
                currentSum += arr[i];

                if (currentSum > maxSum) {
                    maxSum = currentSum;
                    start = tempStart;
                    end = i;
                }

                if (currentSum < 0) {
                    currentSum = 0;
                    tempStart = i + 1;
                }
            }

            vector<int> subarray(arr.begin() + start, arr.begin() + end + 1);
            return {maxSum, subarray};
        }
    // Rearrange Array Elements by Sign | 2 Varieties of same Problem
        vector<int> rearrangeEqualBruteForce(vector<int>& A) {
            vector<int> positive, negative;

            // Separate positive and negative numbers
            for (int num : A) {
                if (num > 0)
                    positive.push_back(num);
                else
                    negative.push_back(num);
            }

            // Rearrange in alternating order
            vector<int> result;
            for (int i = 0; i < positive.size(); ++i) {
                result.push_back(positive[i]);
                result.push_back(negative[i]);
            }

            return result;
        }

        vector<int> rearrangeEqualOptimal(vector<int>& A) {
            vector<int> result(A.size());
            int positive = 0, negative = 1;

            for (int num : A) {
                if (num > 0) {
                    result[positive] = num;
                    positive += 2;
                } else {
                    result[negative] = num;
                    negative += 2;
                }
            }

            return result;
        }

        vector<int> rearrangeUnequal(vector<int>& A) {
            vector<int> positive, negative;

            // Separate positive and negative numbers
            for (int num : A) {
                if (num > 0)
                    positive.push_back(num);
                else
                    negative.push_back(num);
            }

            vector<int> result;
            int i = 0, j = 0;

            // Alternate between positive and negative
            while (i < positive.size() && j < negative.size()) {
                result.push_back(positive[i++]);
                result.push_back(negative[j++]);
            }

            // Add remaining positive numbers
            while (i < positive.size())
                result.push_back(positive[i++]);

            // Add remaining negative numbers
            while (j < negative.size())
                result.push_back(negative[j++]);

            return result;
        }
    // Best Time to Buy and Sell Stock
        int maxProfitBruteForce(vector<int>& prices) {
            int maxProfit = 0;
            for (int i = 0; i < prices.size(); ++i) {
                for (int j = i + 1; j < prices.size(); ++j) {
                    maxProfit = max(maxProfit, prices[j] - prices[i]);
                }
            }
            return maxProfit;
        }

        int maxProfitOptimal(vector<int>& prices) {
            int minPrice = INT_MAX;  // Minimum price seen so far
            int maxProfit = 0;       // Maximum profit achievable

            for (int price : prices) {
                minPrice = min(minPrice, price);           // Update minimum price
                maxProfit = max(maxProfit, price - minPrice); // Update maximum profit
            }

            return maxProfit;
        }
    // Next Permutation
        // Function to generate all permutations
        void generatePermutations(vector<int>& nums, vector<vector<int>>& permutations, int start) {
            if (start == nums.size()) {
                permutations.push_back(nums);
                return;
            }
            for (int i = start; i < nums.size(); ++i) {
                swap(nums[start], nums[i]);
                generatePermutations(nums, permutations, start + 1);
                swap(nums[start], nums[i]); // Backtrack
            }
        }

        void nextPermutationBruteForce(vector<int>& nums) {
            vector<vector<int>> permutations;

            // Step 1: Generate all permutations
            generatePermutations(nums, permutations, 0);

            // Step 2: Sort permutations lexicographically
            sort(permutations.begin(), permutations.end());

            // Step 3: Find the current permutation
            for (int i = 0; i < permutations.size(); ++i) {
                if (permutations[i] == nums) {
                    // Step 4: Return the next permutation, or the first if at the end
                    if (i + 1 < permutations.size()) {
                        nums = permutations[i + 1];
                    } else {
                        nums = permutations[0];
                    }
                    return;
                }
            }
        }
        // Better
        int main() {
            vector<int> A = {1, 2, 3};

            // Generate the next permutation using STL
            if (next_permutation(A.begin(), A.end())) {
                cout << "Next permutation: ";
                for (int num : A) cout << num << " ";
            } else {
                cout << "No next permutation, sorted to smallest: ";
                for (int num : A) cout << num << " ";
            }
            return 0;
        }
        // Optimal
        void nextPermutation(vector<int>& A) {
            int n = A.size(), ind = -1;

            // Step 1: Find the breakpoint
            for (int i = n - 2; i >= 0; --i) {
                if (A[i] < A[i + 1]) {
                    ind = i;
                    break;
                }
            }

            // If no breakpoint, it's the last permutation
            if (ind == -1) {
                reverse(A.begin(), A.end());
                return;
            }

            // Step 2: Find the smallest larger element from the end
            for (int i = n - 1; i > ind; --i) {
                if (A[i] > A[ind]) {
                    swap(A[i], A[ind]);
                    break;
                }
            }

            // Step 3: Reverse the subarray from ind + 1 to the end
            reverse(A.begin() + ind + 1, A.end());
        }
    // Leaders in an Array
        vector<int> findLeadersBruteForce(vector<int>& A) {
            int n = A.size();
            vector<int> leaders;

            for (int i = 0; i < n; ++i) {
                bool isLeader = true;

                // Check all elements to the right
                for (int j = i + 1; j < n; ++j) {
                    if (A[j] >= A[i]) {
                        isLeader = false;
                        break;
                    }
                }

                if (isLeader) {
                    leaders.push_back(A[i]);
                }
            }

           return leaders;
        }

        vector<int> findLeadersBetter(vector<int>& A) {
            int n = A.size();
            vector<int> prefixMax(n);
            vector<int> leaders;

            // Step 1: Create the prefixMax array
            prefixMax[n - 1] = A[n - 1];
            for (int i = n - 2; i >= 0; --i) {
                prefixMax[i] = max(A[i], prefixMax[i + 1]);
            }

            // Step 2: Find leaders
            for (int i = 0; i < n; ++i) {
                if (A[i] == prefixMax[i]) {
                    leaders.push_back(A[i]);
                }
            }

            return leaders;
        }

        vector<int> findLeadersOptimal(vector<int>& A) {
            int n = A.size();
            vector<int> leaders;
            int maxRight = INT_MIN;

            // Traverse from right to left
            for (int i = n - 1; i >= 0; --i) {
                if (A[i] >= maxRight) {
                    maxRight = A[i];
                    leaders.push_back(A[i]);
                }
            }

            // Reverse the leaders as we added them from right to left
            reverse(leaders.begin(), leaders.end());

            return leaders;
        }
    // Longest Consecutive Sequence
        // BruteForce
        bool linearSearch(vector<int>&a, int num) {
            int n = a.size(); //size of array
            for (int i = 0; i < n; i++) {
                if (a[i] == num)
                    return true;
            }
            return false;
        }
        int longestSuccessiveElements(vector<int>&a) {
            int n = a.size(); //size of array
            int longest = 1;
            //pick a element and search for its
            //consecutive numbers:
            for (int i = 0; i < n; i++) {
                int x = a[i];
                int cnt = 1;
                //search for consecutive numbers
                //using linear search:
                while (linearSearch(a, x + 1) == true) {
                    x += 1;
                    cnt += 1;
                }

                longest = max(longest, cnt);
            }
            return longest;
        }
        // Better
        int longestSuccessiveElements(vector<int>&a) {
            int n = a.size();
            if (n == 0) return 0;

            //sort the array:
            sort(a.begin(), a.end());
            int lastSmaller = INT_MIN;
            int cnt = 0;
            int longest = 1;

            //find longest sequence:
            for (int i = 0; i < n; i++) {
                if (a[i] - 1 == lastSmaller) {
                    //a[i] is the next element of the
                    //current sequence.
                    cnt += 1;
                    lastSmaller = a[i];
                }
                else if (a[i] != lastSmaller) {
                    cnt = 1;
                    lastSmaller = a[i];
                }
                longest = max(longest, cnt);
            }
            return longest;

        }
        // Optimal
        int longestSuccessiveElements(vector<int>&a) {
            int n = a.size();
            if (n == 0) return 0;

            int longest = 1;
            unordered_set<int> st;
            //put all the array elements into set:
            for (int i = 0; i < n; i++) {
                st.insert(a[i]);
            }

            //Find the longest sequence:
            for (auto it : st) {
                //if 'it' is a starting number:
                if (st.find(it - 1) == st.end()) {
                    //find consecutive numbers:
                    int cnt = 1;
                    int x = it;
                    while (st.find(x + 1) != st.end()) {
                        x = x + 1;
                        cnt = cnt + 1;
                    }
                    longest = max(longest, cnt);
                }
            }
            return longest;

        }
    // Set Matrix Zeroes
        // Bruteforce
            void setMatrixZeroes(vector<vector<int>>& matrix) {
                int rows = matrix.size();
                int cols = matrix[0].size();

                // Mark rows and columns with -1 (but avoid overwriting existing 0s)
                for (int i = 0; i < rows; ++i) {
                    for (int j = 0; j < cols; ++j) {
                        if (matrix[i][j] == 0) {
                            for (int k = 0; k < cols; ++k) {
                                if (matrix[i][k] != 0) matrix[i][k] = -1;
                            }
                            for (int k = 0; k < rows; ++k) {
                                if (matrix[k][j] != 0) matrix[k][j] = -1;
                            }
                        }
                    }
                }

                // Replace all -1s with 0
                for (int i = 0; i < rows; ++i) {
                    for (int j = 0; j < cols; ++j) {
                        if (matrix[i][j] == -1) matrix[i][j] = 0;
                    }
                }
            }
        // Better
            void setMatrixZeroes(vector<vector<int>>& matrix) {
                int rows = matrix.size();
                int cols = matrix[0].size();

                vector<int> rowMarker(rows, 0);
                vector<int> colMarker(cols, 0);

                // Mark the rows and columns
                for (int i = 0; i < rows; ++i) {
                    for (int j = 0; j < cols; ++j) {
                        if (matrix[i][j] == 0) {
                            rowMarker[i] = 1;
                            colMarker[j] = 1;
                        }
                    }
                }

                // Set the cells to 0 based on markers
                for (int i = 0; i < rows; ++i) {
                    for (int j = 0; j < cols; ++j) {
                        if (rowMarker[i] == 1 || colMarker[j] == 1) {
                            matrix[i][j] = 0;
                        }
                    }
                }
            }
        // Optimal
            void setMatrixZeroes(vector<vector<int>>& matrix) {
                int rows = matrix.size();
                int cols = matrix[0].size();
                bool col0 = true;

                // Mark the first row and first column
                for (int i = 0; i < rows; ++i) {
                    if (matrix[i][0] == 0) col0 = false;
                    for (int j = 1; j < cols; ++j) {
                        if (matrix[i][j] == 0) {
                            matrix[i][0] = 0;
                            matrix[0][j] = 0;
                        }
                    }
                }

                // Use marks to set elements to 0
                for (int i = rows - 1; i >= 0; --i) {
                    for (int j = cols - 1; j >= 1; --j) {
                        if (matrix[i][0] == 0 || matrix[0][j] == 0) {
                            matrix[i][j] = 0;
                        }
                    }
                    if (!col0) matrix[i][0] = 0;
                }
            }
    // Rotate Matrix
    // Spiral Traversal of Matrix
    // Count Subarray sum Equals K
    // Pascal Triangle | Finding nCr in minimal time
    // Majority Element II
    // 3 Sum
    // 4 Sum
    // Number of Subarrays with Xor K
    // Merge Overlapping Intervals
    // Merge Sorted arrays without extra space
    // Find the Missing and Repeating Number
    // Count Inversion in an Array
    // Reverse Pairs
    // Maximum Product Subarray

// Two Pointers
## Two Pointers ##
    // Q1. Container With Most Water
        /*
        Q.1 -> Given N non-negative integers A[0], A[1], ..., A[N-1] , where each represents a point at coordinate (i, A[i]).
        N vertical lines are drawn such that the two endpoints of line i is at (i, A[i]) and (i, 0).
        Find two lines, which together with x-axis forms a container, such that the container contains the most water. You need to return this maximum area.

        Note: You may not slant the container. It is guaranteed that the answer will fit in integer limits.

        Problem Constraints
            1 <= N <= 10^5
            1 <= A[i] <= 10^5   

        Input Format
            Single Argument representing a 1-D array A.

        Output Format
            Return single Integer denoting the maximum area you can obtain.

        Input 1:
            A = [1, 5, 4, 3]

        Output 1:
            6

        Input 2:
            A = [1]

        Output 2:
            0

        */

        // CODE

        int Solution::maxArea(vector<int> &A) {
            int left = 0;                // Left pointer
            int right = A.size() - 1;     // Right pointer
            int max_area = 0;             // To store the maximum area

            while (left < right) {
                // Calculate the area between the two lines
                int height = min(A[left], A[right]); // The shorter line determines the height
                int width = right - left;            // Distance between the two lines
                int area = height * width;           // Current area

                // Update max_area if the current area is larger
                max_area = max(max_area, area);

                // Move the pointer corresponding to the shorter line inward
                if (A[left] < A[right]) {
                    left++;
                } else {
                    right--;
                }
            }

            return max_area;  // Return the maximum area found
        }
    // Q2. Subarray with given sum
        /*
        Q.2 -> Given an array of positive integers A and an integer B, find and return first continuous subarray which adds to B.
        If the answer does not exist return an array with a single integer "-1".
        First sub-array means the sub-array for which starting index in minimum.

        Note :
            

        Problem Constraints
            1 <= length of the array <= 100000
            1 <= A[i] <= 109
            1 <= B <= 109

        Input Format
            The first argument given is the integer array A.
            The second argument given is integer B.    

        Output Format
            Return the first continuous sub-array which adds to B and if the answer does not exist return an array with a single integer "-1".

        Input 1:
            A = [1, 2, 3, 4, 5]
            B = 5

        Output 1:
            [2, 3]

        Input 2:
            A = [5, 10, 20, 100, 105]
            B = 110

        Output 2:
            [-1]

        */

        // CODE
        vector<int> Solution::solve(vector<int> &A, int B) {
            int start = 0;          // Start of the subarray
            int curr_sum = 0;       // Current sum of the subarray
            
            // Traverse through the array
            for (int end = 0; end < A.size(); end++) {
                // Add current element to the sum
                curr_sum += A[end];
                
                // Shrink the window from the left if the sum is greater than B
                while (curr_sum > B && start <= end) {
                    curr_sum -= A[start];
                    start++;
                }
                
                // Check if we have found the subarray with sum equals to B
                if (curr_sum == B) {
                    // Return the subarray from start to end (1-based index)
                    return vector<int>(A.begin() + start, A.begin() + end + 1);
                }
            }
            
            // If no subarray is found, return -1
            return {-1};
        }
    // Q3. Pairs with given sum II
        /*
        Q.3 -> Given a sorted array of integers (not necessarily distinct) A and an integer B, find and return how many pair of integers ( A[i], A[j] ) such that i != j have sum equal to B.
        Since the number of such pairs can be very large, return number of such pairs modulo (109 + 7).

        Note :
            

        Problem Constraints
            1 <= |A| <= 100000
            1 <= A[i] <= 10^9
            1 <= B <= 10^9   

        Input Format
            The first argument given is the integer array A.
            The second argument given is integer B.

        Output Format
            Return the number of pairs for which sum is equal to B modulo (10^9+7).

        Input 1:
            A = [1, 1, 1]
            B = 2

        Output 1:
            3

        Input 2:
            A = [1, 5, 7, 10]
            B = 8

        Output 2:
            1

        */

        // CODE
        int Solution::solve(vector<int> &A, int B) {
            int n = A.size();
            int i = 0, j = n - 1;
            int mod = 1e9 + 7;
            long long ans = 0;

            while (i < j) {
                if (A[i] + A[j] < B) {
                    // If the sum is less than B, move i to increase the sum
                    i++;
                } else if (A[i] + A[j] > B) {
                    // If the sum is greater than B, move j to decrease the sum
                    j--;
                } else {
                    // If A[i] + A[j] == B
                    if (A[i] == A[j]) {
                        // Scenario 1: A[i] == A[j], count number of elements between i and j
                        long long numOfElements = j - i + 1;
                        long long numOfPairs = (numOfElements * (numOfElements - 1)) / 2;
                        ans = (ans + numOfPairs) % mod;
                        break;
                    } else {
                        // Scenario 2: A[i] != A[j], count the number of occurrences of A[i] and A[j]
                        long long countOfElements_i = 1;
                        while (i + 1 < j && A[i] == A[i + 1]) {
                            countOfElements_i++;
                            i++;
                        }

                        long long countOfElements_j = 1;
                        while (j - 1 > i && A[j] == A[j - 1]) {
                            countOfElements_j++;
                            j--;
                        }

                        // Multiply the counts of A[i] and A[j] to get the number of pairs
                        long long numOfPairs = (countOfElements_i * countOfElements_j) % mod;
                        ans = (ans + numOfPairs) % mod;

                        // Move pointers to the next distinct elements
                        i++;
                        j--;
                    }
                }
            }

            return (int)ans;
        }
    // Q4. Pairs with Given Difference
        /*
        Q.4 -> Given an one-dimensional integer array A of size N and an integer B.
        Count all distinct pairs with difference equal to B.
        Here a pair is defined as an integer pair (x, y), where x and y are both numbers in the array and their absolute difference is B.

        Note :
            

        Problem Constraints
            1 <= N <= 104
            0 <= A[i], B <= 105

        Input Format
            First argument is an one-dimensional integer array A of size N.
            Second argument is an integer B.

        Output Format
            Return an integer denoting the count of all distinct pairs with difference equal to B.

        Input 1:
            A = [1, 5, 3, 4, 2]
            B = 3

        Output 1:
            2

        Input 2:
            A = [8, 12, 16, 4, 0, 20]
            B = 4

        Output 2:
            5

        Input 3:
            A = [1, 1, 1, 2, 2]
            B = 0

        Output 3:
            2

        */

        // CODE
        int Solution::solve(vector<int> &A, int B) {
        int ans = 0;

            // Handle the case where the difference is 0 (count duplicates)
            if (B == 0) {
                unordered_map<int, int> mp;  // Map to count occurrences
                for (const auto &val : A) {
                    if (++mp[val] == 2) {
                        ++ans;  // Found a duplicate
                    }
                }
                return ans;
            }

            unordered_set<int> s;  // Set to store unique elements
            for (const auto &val : A) {
                if (s.count(val) == 0) {  // If val is not already counted
                    if (s.count(val + B)) ++ans;  // Check for (val + B)
                    if (s.count(val - B)) ++ans;  // Check for (val - B)
                }
                s.insert(val);  // Insert val into the set
            }
            
            return ans;  // Return the total count of distinct pairs
        }
    // Q1. 3 Sum
        /*.
        Q.1 -> Given an array A of N integers, find three integers in A such that the sum is closest to a given number B. Return the sum of those three integers.
        Assume that there will only be one solution.

        Note :
            

        Problem Constraints
            -108 <= B <= 108
            1 <= N <= 104
            -108 <= A[i] <= 108

        Input Format
            First argument is an integer array A of size N.
            Second argument is an integer B denoting the sum you need to get close to.

        Output Format
            Return a single integer denoting the sum of three integers which is closest to B.

        Input 1:
            A = [-1, 2, 1, -4]
            B = 1

        Output 1:
            2

        Input 2:
            A = [1, 2, 3]
            B = 6

        Output 2:
            6

        */

        // CODE
        int Solution::threeSumClosest(vector<int> &A, int B) {
            sort(A.begin(), A.end()); // Sort the array
                int sum = 0; // Variable to store the closest sum
                int diff = numeric_limits<int>::max(); // Initialize diff to a large value

                for (int i = 0; i < A.size(); i++) {
                    int l = 0; // Left pointer
                    int r = A.size() - 1; // Right pointer

                    while (l < r) {
                        if (l == i) l++; // Skip the current index if it's the left pointer
                        else if (r == i) r--; // Skip the current index if it's the right pointer
                        else {
                            int currentSum = A[i] + A[l] + A[r];

                            // Update the closest sum if the current difference is smaller
                            if (abs(diff) >= abs(B - currentSum)) {
                                diff = B - currentSum;
                                sum = currentSum;
                            }

                            // Adjust pointers based on the current sum
                            if (currentSum > B) {
                                r--; // Move right pointer left to decrease the sum
                            } else {
                                l++; // Move left pointer right to increase the sum
                            }
                        }
                    }
                }
                return sum; // Return the closest sum found
        }
    // Q2. Array 3 Pointers
        /*
        Q.2 -> You are given 3 sorted arrays A, B and C.
        Find i, j, k such that : max(abs(A[i] - B[j]), abs(B[j] - C[k]), abs(C[k] - A[i])) is minimized.
        Return the minimum max(abs(A[i] - B[j]), abs(B[j] - C[k]), abs(C[k] - A[i])).

        Note :

        Problem Constraints
            1 <= len(A), len(B), len(c) <= 106
            0 <= A[i], B[i], C[i] <= 107   

        Input Format
            First argument is an integer array A.
            Second argument is an integer array B.
            Third argument is an integer array C.    

        Output Format
            Return an single integer denoting the minimum max(abs(A[i] - B[j]), abs(B[j] - C[k]), abs(C[k] - A[i])).

        Input 1:
            A = [1, 4, 10]
            B = [2, 15, 20]
            C = [10, 12]

        Output 1:
            5

        Input 2:
            A = [3, 5, 6]
            B = [2]
            C = [3, 4]

        Output 2:
            1

        */

        // CODE
        int Solution::minimize(const vector<int> &A, const vector<int> &B, const vector<int> &C) {
            int i = 0, j = 0, k = 0;
            int minMaxDiff = numeric_limits<int>::max();

            while (i < A.size() && j < B.size() && k < C.size()) {
                // Get the current values
                int a = A[i];
                int b = B[j];
                int c = C[k];

                // Calculate max of the absolute differences
                int maxDiff = max({abs(a - b), abs(b - c), abs(c - a)});

                // Update the minimum max difference found
                minMaxDiff = min(minMaxDiff, maxDiff);

                // Move the pointer pointing to the smallest value
                if (a <= b && a <= c) {
                    i++; // Move pointer in A
                } else if (b <= a && b <= c) {
                    j++; // Move pointer in B
                } else {
                    k++; // Move pointer in C
                }
            }

            return minMaxDiff; // Return the minimized maximum difference
        }
    // Q3. Max Continuous Series of 1s
        /*
        Q.3 -> Given a binary array A, find the maximum sequence of continuous 1's that can be formed by replacing at-most B zeroes.
        For this problem, return the indices of maximum continuous series of 1s in order.
        If there are multiple possible solutions, return the sequence which has the minimum start index. 

        Note :
            

        Problem Constraints
            0 <= B <= 105
            1 <= size(A) <= 105
            0 <= A[i] <= 1   

        Input Format
            First argument is an binary array A.
            Second argument is an integer B. 

        Output Format
            Return an array of integers denoting the indices(0-based) of 1's in the maximum continuous series.

        Input 1:
            A = [1, 1, 0, 1, 1, 0, 0, 1, 1, 1]
            B = 1

        Output 1:
            [0, 1, 2, 3, 4]

        Input 2:
            A = [1, 0, 0, 0, 1, 0, 1]
            B = 2

        Output 2:
            [3, 4, 5, 6]

        */

        // CODE
        vector<int> Solution::maxone(vector<int> &A, int B) {
            int left = 0, right = 0, maxLength = 0, maxStart = 0;
            int zeroCount = 0;
            int n = A.size();

            while (right < n) {
                // Expand the window by moving the right pointer
                if (A[right] == 0) {
                    zeroCount++;
                }

                // If zeroCount exceeds B, move the left pointer to shrink the window
                while (zeroCount > B) {
                    if (A[left] == 0) {
                        zeroCount--;
                    }
                    left++;
                }

                // Update the maximum length and starting index if we found a longer window
                if (right - left + 1 > maxLength) {
                    maxLength = right - left + 1;
                    maxStart = left;
                }

                right++; // Move the right pointer to the next position
            }

            // Prepare the result indices
            vector<int> result;
            for (int i = maxStart; i < maxStart + maxLength; i++) {
                result.push_back(i);
            }

            return result; // Return the indices of the maximum continuous series of 1's
        }
    // Q4. Another Count Rectangles
        /*
        Q.4 -> Given a sorted array of distinct integers A and an integer B, find and return how many rectangles with distinct configurations can be created using elements of this array as length and breadth whose area is lesser than B.
        (Note that a rectangle of 2 x 3 is different from 3 x 2 if we take configuration into view)

        Note :
            

        Problem Constraints
            1 <= |A| <= 100000
            1 <= A[i] <= 109
            1 <= B <= 109   

        Input Format
            The first argument given is the integer array A.
            The second argument given is integer B.

        Output Format
            Return the number of rectangles with distinct configurations with area less than B modulo (109 + 7).

        Input 1:
            A = [1, 2]
            B = 5

        Output 1:
            4

        Input 2:
            A = [1, 2]
            B = 1

        Output 2:
            0

        */

        // CODE
        int Solution::solve(vector<int> &A, int B) {
            int n = A.size();
            long long ans = 0; // Use long long to prevent overflow
            int l = 0, r = n - 1;

            while (l <= r) {
                long long multiply = static_cast<long long>(A[l]) * static_cast<long long>(A[r]);
                if (multiply < B) {
                    // Count configurations with A[l] as length and A[j] as breadth for j in [l, r]
                    ans += (2 * (r - l) + 1); // 2 configurations for each valid pair
                    l++; // Move left pointer right
                } else {
                    r--; // Move right pointer left
                }
            }

            return static_cast<int>(ans % 1000000007); // Return result modulo 10^9 + 7
        }
    // Q5. Closest pair from sorted arrays
        /*
        Q.5 -> 
        Given two sorted arrays of distinct integers, A and B, and an integer C, find and return the pair whose sum is closest to C and the pair has one element from each array.
        More formally, find A[i] and B[j] such that abs((A[i] + B[j]) - C) has minimum value.
        If there are multiple solutions find the one with minimum i and even if there are multiple values of j for the same i then return the one with minimum j.
        Return an array with two elements {A[i], B[j]}.

        Note :
            

        Problem Constraints
            1 <= length of both the arrays <= 105
            1 <= A[i], B[i] <= 109
            1 <= C <= 109   

        Input Format
            The first argument given is the integer array A.
            The second argument given is the integer array B.
            The third argument given is integer C.

        Output Format
            Return an array of size 2 denoting the pair which has sum closest to C.

        Input 1:
            A = [1, 2, 3, 4, 5]
            B = [2, 4, 6, 8]
            C = 9

        Output 1:
            [1, 8]

        Input 2:
            A = [5, 10, 20]
            B = [1, 2, 30]
            C = 13


        Output 2:
            [10, 2]

        */

        // CODE
        vector<int> Solution::solve(vector<int> &A, vector<int> &B, int C) {
            int left = 0;
            int right = B.size() - 1;
            int i = -1;
            int j = -1;
            int diff = INT_MAX; // Initialize difference to maximum

            while (left < A.size() && right >= 0) {
                int sum = A[left] + B[right];
                int currDiff = abs(sum - C);

                // Update if current difference is smaller
                if (currDiff < diff) {
                    diff = currDiff;
                    i = left;
                    j = right;
                } else if (currDiff == diff) {
                    // When left is the same, update j if right is greater
                    if (A[left] == A[i]) {
                        j = right;
                    }
                }

                // Move pointers based on comparison of sum and C
                if (sum > C) {
                    right--; // Decrease the sum
                } else if (sum < C) {
                    left++; // Increase the sum
                } else {
                    break; // Exact match found
                }
            }

            return {A[i], B[j]}; // Return the pair
        }
## Two Pointers & Sliding Window Extra ##
    // Introduction to Sliding Window and Two pointer
        // Largest Subarray with sum <=k
        int findLength(vector<int> &arr, int N, int K) {
            int l = 0, r = 0;
            int sum = 0;
            int maxLength = 0;

            while (r < N) {
                // Add the current element to the sum
                sum += arr[r];

                // Shrink the window from the left as long as the sum exceeds K
                while (sum > K) {
                    sum -= arr[l];
                    l++;
                }

                // Update the maximum length of the subarray with sum <= K
                if (sum <= K) {
                    maxLength = max(maxLength, r - l + 1);
                }

                // Move the right pointer
                r++;
            }

            return maxLength;
        }
    // Maximum Points You Can Obtain from Cards
        int maxSum(vector<int>& nums, int k) {
            int n = nums.size();
            
            // Compute the sum of the first k elements
            int lsum = 0;
            for (int i = 0; i < k; i++) {
                lsum += nums[i];
            }

            // Initialize the maxSum with the sum of the first k elements
            int maxSum = lsum;

            // Now, calculate the max sum by moving elements from the left part to the right part
            int rsum = 0;
            int ri = n - 1;  // Right pointer for the last k elements

            for (int i = k - 1; i >= 0; i--) {
                // Remove the current element from the left part and add the corresponding element from the right part
                lsum -= nums[i];
                rsum += nums[ri];

                // Move the right pointer
                ri--;

                // Update the maxSum with the current sum
                maxSum = max(maxSum, lsum + rsum);
            }

            return maxSum;
        }   
    // Longest Substring Without Repeating Characters
        int longestSubstringWithoutRepeatingCharacters(const string &s) {
            vector<int> hash(256, -1);  // Array to store the last occurrence of each character
            int n = s.size();
            int l = 0, r = 0, maxlen = 0;

            // Traverse the string using the right pointer
            while (r < n) {
                // If the character is already in the window, adjust the left pointer
                if (hash[s[r]] != -1) {
                    // Move left pointer to the right of the last occurrence of the current character
                    l = max(l, hash[s[r]] + 1);
                }

                // Update the maximum length of the substring
                maxlen = max(maxlen, r - l + 1);

                // Update the last occurrence of the character at index r
                hash[s[r]] = r;

                // Move the right pointer to the right
                r++;
            }

            return maxlen;
        }
    // Max Consecutive Ones III (at max k zeros allowed)  
        int maxConsecutiveOnes(vector<int>& nums, int k) {
            int maxlen = 0, l = 0, r = 0, zeros = 0;
            int n = nums.size();

            while (r < n) {
                if (nums[r] == 0) {
                    zeros++;
                }
                
                // Shrink window if zeros exceed k
                while (zeros > k) {
                    if (nums[l] == 0) {
                        zeros--;
                    }
                    l++;
                }

                // Calculate the length of the current valid window
                maxlen = max(maxlen, r - l + 1);
                r++;
            }
            return maxlen;
        }
        int maxConsecutiveOnes(vector<int>& nums, int k) {
            int maxlen = 0, l = 0, r = 0, zeros = 0;
            int n = nums.size();

            while (r < n) {
                if (nums[r] == 0) {
                    zeros++;
                }

                // Shrink window if zeros exceed k
                if (zeros > k) {
                    if (nums[l] == 0) {
                        zeros--;
                    }
                    l++;
                }

                // Calculate the length of the current valid window
                if (zeros <= k) {
                    maxlen = max(maxlen, r - l + 1);
                }
                r++;
            }
            return maxlen;
        }
    // Fruit Into Baskets   
        int totalFruit(vector<int>& arr, int K) {
            int l = 0, r = 0, maxlen = 0;
            unordered_map<int, int> map; // To track the count of each fruit
            
            while (r < arr.size()) {
                map[arr[r]]++;
                
                // Shrink the window if the number of unique fruits exceeds K
                while (map.size() > K) {  // assuming K = 2 here for this problem
                    map[arr[l]]--;
                    if (map[arr[l]] == 0) {
                        map.erase(arr[l]);
                    }
                    l++;
                }
                
                // Calculate the current window size and update maxlen
                if (map.size() <= K) {
                    maxlen = max(maxlen, r - l + 1);
                }
                
                r++;
            }
            return maxlen;
        }
        int totalFruit(vector<int>& arr, int K) {
            int l = 0, r = 0, maxlen = 0;
            unordered_map<int, int> map; // To track the count of each fruit
            
            while (r < arr.size()) {
                map[arr[r]]++;
                
                // Shrink the window if the number of unique fruits exceeds K
                if (map.size() > K) {  // assuming K = 2 here for this problem
                    map[arr[l]]--;
                    if (map[arr[l]] == 0) {
                        map.erase(arr[l]);
                    }
                    l++;
                }
                
                // Calculate the current window size and update maxlen
                if (map.size() <= K) {
                    maxlen = max(maxlen, r - l + 1);
                }
                
                r++;
            }
            return maxlen;
        }
    // Longest Substring With At Most K Distinct Characters
        int lengthOfLongestSubstringKDistinct(string s, int K) {
            int l = 0, r = 0, maxlen = 0;
            unordered_map<char, int> map; // To track frequency of characters

            while (r < s.size()) {
                map[s[r]]++;

                // Shrink the window if the number of distinct characters exceeds K
                while (map.size() > K) {
                    map[s[l]]--;
                    if (map[s[l]] == 0) {
                        map.erase(s[l]); // Remove character from map if count is 0
                    }
                    l++;
                }

                // Update the maximum length of the window
                if (map.size() <= K) {
                    maxlen = max(maxlen, r - l + 1);
                }

                r++;
            }

            return maxlen;
        }  
        int lengthOfLongestSubstringKDistinct(string s, int K) {
            int l = 0, r = 0, maxlen = 0;
            unordered_map<char, int> map; // To track frequency of characters

            while (r < s.size()) {
                map[s[r]]++;

                // Directly shrink the window if map size exceeds K
                if (map.size() > K) {
                    map[s[l]]--;
                    if (map[s[l]] == 0) {
                        map.erase(s[l]);
                    }
                    l++;
                }

                // Update the maximum length of the window
                if (map.size() <= K) {
                    maxlen = max(maxlen, r - l + 1);
                }

                r++;
            }

            return maxlen;
        }
    // Number of Substrings Containing All Three Characters
        int countSubstringsContainingAllChars(string s) {
            vector<int> Lastseen(3, -1); // Tracks last seen positions for 'a', 'b', 'c'
            int cnt = 0;

            for (int i = 0; i < s.size(); i++) {
                // Update last seen position of current character
                Lastseen[s[i] - 'a'] = i;

                // Check if all three characters have been seen
                if (Lastseen[0] != -1 && Lastseen[1] != -1 && Lastseen[2] != -1) {
                    // The count is incremented by the number of substrings ending at index `i`
                    cnt += 1 + min({Lastseen[0], Lastseen[1], Lastseen[2]});
                }
            }

            return cnt;
        }   
    // Longest Repeating Character Replacement   
        int longestRepeatingCharacterReplacementSolution1(string S, int K) {
            int l = 0, r = 0, maxlen = 0, maxf = 0;
            vector<int> hash(26, 0); // Frequency array for characters
            
            while (r < S.size()) {
                hash[S[r] - 'A']++;
                maxf = *max_element(hash.begin(), hash.end()); // Find the max frequency

                while ((r - l + 1) - maxf > K) {
                    hash[S[l] - 'A']--;
                    maxf = 0;
                    for (int i = 0; i < 26; ++i) {
                        maxf = max(maxf, hash[i]); // Recalculate maxf
                    }
                    l++;
                }

                if ((r - l + 1) - maxf <= K) {
                    maxlen = max(maxlen, r - l + 1);
                }
                r++;
            }

            return maxlen;
        }
        int longestRepeatingCharacterReplacementSolution2(string S, int K) {
            int l = 0, r = 0, maxlen = 0, maxf = 0;
            vector<int> hash(26, 0); // Frequency array for characters
            
            while (r < S.size()) {
                hash[S[r] - 'A']++;
                maxf = max(maxf, hash[S[r] - 'A']); // Update maxf

                if ((r - l + 1) - maxf > K) {
                    hash[S[l] - 'A']--;
                    l++;
                }

                if ((r - l + 1) - maxf <= K) {
                    maxlen = max(maxlen, r - l + 1);
                }
                r++;
            }

            return maxlen;
        }
    // Binary Subarrays With Sum | count subarray sum = k
        // Function to count subarrays with sum less than or equal to k
        int F_less_equal_K(vector<int>& arr, int k) {
            if (k < 0) return 0; // No subarray can have a sum less than zero in a binary array

            int l = 0, r = 0, sum = 0, count = 0;
            int n = arr.size();

            while (r < n) {
                sum += arr[r]; // Increment the sum with the current element
                while (sum > k) {
                    sum -= arr[l]; // Reduce the sum from the left side
                    l++;
                }
                count += (r - l + 1); // Count subarrays ending at index r
                r++;
            }

            return count;
        }

        // Main function to count subarrays with sum exactly equal to k
        int countSubarraysWithSum(vector<int>& arr, int k) {
            return F_less_equal_K(arr, k) - F_less_equal_K(arr, k - 1);
        }   
    // Count No. of Nice Subarray | No. of Subarray with no. of odd no is K
        // Function to count subarrays with sum less than or equal to K
        int F_less_equal_K(vector<int>& arr, int K) {
            if (K < 0) return 0; // No subarray can have negative sum
            
            int l = 0, count = 0, sum = 0;
            for (int r = 0; r < arr.size(); ++r) {
                sum += arr[r]; // Add current element to the sum

                // Shrink the window if sum exceeds K
                while (sum > K) {
                    sum -= arr[l];
                    l++;
                }

                // Count valid subarrays ending at index r
                count += (r - l + 1);
            }

            return count;
        }
        // Function to count subarrays with exactly K odd numbers
        int countNiceSubarrays(vector<int>& nums, int K) {
            // Step 1: Convert odd numbers to 1 and even numbers to 0
            vector<int> transformed(nums.size());
            for (int i = 0; i < nums.size(); ++i) {
                transformed[i] = (nums[i] % 2 != 0) ? 1 : 0;
            }

            // Step 2 & 3: Return the difference between counts
            return F_less_equal_K(transformed, K) - F_less_equal_K(transformed, K - 1);
        }
    // Subarray with k different integers
        // Function to count subarrays with at most K different integers
        int F(vector<int>& arr, int K) {
            int l = 0, count = 0;
            unordered_map<int, int> freqMap; // Map to count frequencies of elements

            for (int r = 0; r < arr.size(); ++r) {
                // Increment frequency of the current element
                freqMap[arr[r]]++;

                // If the size of the map exceeds K, shrink the window from the left
                while (freqMap.size() > K) {
                    freqMap[arr[l]]--;
                    if (freqMap[arr[l]] == 0) {
                        freqMap.erase(arr[l]);
                    }
                    l++;
                }

                // Count subarrays ending at index r with at most K different integers
                count += (r - l + 1);
            }

            return count;
        }
        // Function to count subarrays with exactly K different integers
        int subarraysWithKDistinct(vector<int>& nums, int K) {
            return F(nums, K) - F(nums, K - 1);
        }   
    // Minimum Window Substring


// Bit Manipulations
## Bit Manipulations Basics ##
    // Q1. Add Binary Strings
        /*
        Q.1 -> Given two binary strings A and B. Return their sum (also a binary string).

        Note :
            

        Problem Constraints
            1 <= length of A <= 105
            1 <= length of B <= 105
            A and B are binary strings  

        Input Format
            The two argument A and B are binary strings.  

        Output Format
            Return a binary string denoting the sum of A and B

        Input 1:
            A = "100"
            B = "11"

        Output 1:
            "111"

        Input 2:
            A = "110"
            B = "10"

        Output 2:
            "1000"

        */

        // CODE
        string Solution::addBinary(string A, string B) {

            //  A = "100" - L=3
            //  B = "11" - L=2
            int lenA = A.size();
            int lenB = B.size();
            
            // Ensure both strings are of the same length by padding with leading zeros
            int max_len = std::max(lenA, lenB);
            std::string A_padded = std::string(max_len - lenA, '0') + A;  
            std::string B_padded = std::string(max_len - lenB, '0') + B; // "0" + "11" = "011"
            
            std::string result = "";
            int carry = 0;
            
            // Traverse the strings from right to left
            for (int i = max_len - 1; i >= 0; --i) {

                // If A_padded[i] is '0', then A_padded[i] - '0' equals 48 - 48, which is 0.
                // If A_padded[i] is '1', then A_padded[i] - '0' equals 49 - 48, which is 1.
                int bit_A = A_padded[i] - '0';  // Converts '0' or '1' to 0 or 1
                int bit_B = B_padded[i] - '0';  // Converts '0' or '1' to 0 or 1
                
                // Calculate the sum of the current bits plus the carry
                int total = bit_A + bit_B + carry;
                
                // Append the current bit to the result (total % 2)
                result.push_back(total % 2 + '0');  // Converts 0 or 1 back to '0' or '1'
                
                // Update the carry (total // 2)
                carry = total / 2;
            }
            
            // If there's a carry left, add it to the result
            if (carry) {
                result.push_back('1');
            }
            
            // Reverse the result to get the correct order
            std::reverse(result.begin(), result.end());
            
            return result;
        }
## Bit Manipulations 1 ##
    // Q1. Set Bit
        /*
        Q.1 -> You are given two integers A and B.
        Set the A-th bit and B-th bit in 0, and return output in decimal Number System.

        Note :
            The bit positions are 0-indexed, which means that the least significant bit (LSB) has index 0.  

        Problem Constraints
            0 <= A <= 30
            0 <= B <= 30

        Input Format
            First argument A is an integer.
            Second argument B is an integer.  

        Output Format
            Return an integer.

        Input 1:
            A = 3
            B = 5

        Output 1:
            40

        Input 2:
            A = 4
            B = 4

        Output 2:
            16

        */

        // CODE
        int Solution::solve(int A, int B) {
            /*
                A = 2
                B = 1
                0     = 0000
                1<<A  = 0100
                1<<B  = 0010
                ans   = 0110
            */
            return ((0 | 1<<A) | (0|1<<B));
            
        }
    // Q2. Unset i-th bit
        /*
        Q.2 -> You are given two integers A and B.
        If B-th bit in A is set, make it unset.
        If B-th bit in A is unset, leave as it is.
        Return the updated A value.

        Note :
            The bit position is 0-indexed, which means that the least significant bit (LSB) has index 0.    
            

        Problem Constraints
            1 <= A <= 10^9
            0 <= B <= 30 

        Input Format
            First argument A is an integer.
            Second argument B is an integer.        

        Output Format
            Return an integer.

        Input 1:
            A = 4
            B = 1

        Output 1:
            4

        Input 2:
            A = 5
            B = 2

        Output 2:
            1

        */

        // CODE
        int Solution::solve(int A, int B) {
            
            return A & ~(1 << B);
        }
    // Q3. Check bit
        /*
        Q.3 -> You are given two integers A and B.
        Return 1 if B-th bit in A is set
        Return 0 if B-th bit in A is unset


        Note :
            The bit position is 0-indexed, which means that the least significant bit (LSB) has index 0.

        Problem Constraints
            1 <= A <= 109
            0 <= B <= 30

        Input Format
            First argument A is an integer.
            Second argument B is an integer.

        Output Format
            Return an integer.

        Input 1:
            A = 4
            B = 1

        Output 1:
            0

        Input 2:
            A = 5
            B = 2

        Output 2:
            1

        */

        // CODE
        int Solution::solve(int A, int B) {

            if( (A & 1<<B) == 0){
                return 0;
            }else{
                return 1;
            }
        }
    // Q4. Number of 1 Bits
        /*
        Q.4 -> Write a function that takes an integer and returns the number of 1 bits present in its binary representation.

        Note :
            

        Problem Constraints
            1 <= A <= 109

        Input Format
            First and only argument contains integer A  

        Output Format
            Return an integer

        Input 1:
            11

        Output 1:
            3

        Input 2:
            6

        Output 2:
            2

        */

        // CODE
        int Solution::numSetBits(int A) {

            int count = 0;
            while(A > 0){

                if ((A & 1) != 0){
                    count++;
                }

                A= A>>1;

            }

            return count;
        }
    // Q5. Help From Sam
        /*
        Q.5 -> Alex and Sam are good friends. Alex is doing a lot of programming these days. He has set a target score of A for himself.
        Initially, Alex's score was zero. Alex can double his score by doing a question, or Alex can seek help from Sam for doing questions that will contribute 1 to Alex's score. Alex wants his score to be precisely A. Also, he does not want to take much help from Sam.
        Find and return the minimum number of times Alex needs to take help from Sam to achieve a score of A.

        Note :

        Problem Constraints
        0 <= A <= 10^9 

        Input Format
            The only argument given is an integer A.   

        Output Format
            Return the minimum number of times help taken from Sam.

        Input 1:
            A = 5

        Output 1:
            2

        Input 2:
            A = 3

        Output 2:
            2

        */

        // CODE
        int Solution::solve(int A) {
            int count = 0;
            while(A>0){
                if(A%2 == 0){
                    A /= 2;
                }else{
                    A -= 1;
                    count ++;
                }
            }

            return count;
        }
    // Q6. Toggle i-th bit
        /*
        Q.6 -> ou are given two integers A and B.
        If B-th bit in A is set, make it unset
        If B-th bit in A is unset, make it set
        Return the updated A value

        Note :
            

        Problem Constraints
            1 <= A <= 10^9
            0 <= B <= 30    

        Input Format
            First argument A is an integer.
            Second argument B is an integer.   

        Output Format
            Return an integer.

        Input 1:
            A = 4
            B = 1

        Output 1:
            6

        Input 2:
            A = 5
            B = 2

        Output 2:
            1

        */

        // CODE
        int Solution::solve(int A, int B) {
            return (A^ 1<<B);
        }
    // Q1. Unset x bits from right
        /*
        Q.1 -> Given an integer A. Unset B bits from the right of A in binary.
        For example, if A = 93 and B = 4, the binary representation of A is 1011101.
        If we unset the rightmost 4 bits, we get the binary number 1010000, which is equal to the decimal value 80.

        Note : 
            

        Problem Constraints
            1 <= A <= 10^18
            1 <= B <= 60

        Input Format
            The first argument is a single integer A.
            The second argument is a single integer B.

        Output Format
            Return the number with B unset bits from the right.

        Input 1:
            A = 25
            B = 3

        Output 1:
            24

        Input 2:
            A = 37
            B = 3

        Output 2:
            32

        */

        // CODE
        long Solution::solve(long A, int B) {

            // Create a mask with the rightmost B bits unset
            /*
                long A
                B = 3
            */
            long mask = 1;
            mask = ~((mask << B)-1);
            // long mask = ~((1L << B) - 1);
            // Apply the mask to A
            return A & mask;
        }
    // Q2. Finding Good Days
        /*
        Q.2 -> Alex has a cat named Boomer. He decides to put his cat to the test for eternity.
        He starts on day 1 with one stash of food unit, every next day, the stash doubles.
        If Boomer is well behaved during a particular day, only then she receives food worth equal to the stash produced on that day.
        Boomer receives a net worth of A units of food. What is the number of days she received the stash?

        Note :
            

        Problem Constraints
            1 <= A <= (2^31)-1

        Input Format
            First and only argument is an integer A.

        Output Format
            Return an integer denoting the number of days Boomer was well behaved.

        Input 1:
            A = 5

        Output 1:
            2

        Input 2:
            A = 8

        Output 2:
            1

        */

        // CODE
        int Solution::solve(int A) {
            int count = 0;
            while (A > 0) {
                count += A & 1; // Increment count if the least significant bit is 1
                A >>= 1;        // Right shift A by 1 to process the next bit
            }
            return count;
        }
    // Q3. Find nth Magic Number
        /*
        Q.3 -> 
        Given an integer A, find and return the Ath magic number.
        A magic number is defined as a number that can be expressed as a power of 5 or a sum of unique powers of 5.
        First few magic numbers are 5, 25, 30(5 + 25), 125, 130(125 + 5), .

        Note :

        Problem Constraints
            1 <= A <= 5000

        Input Format
            The only argument given is integer A.
            

        Output Format
            Return the Ath magic number.

        Input 1:
            A = 3

        Output 1:
            30

        Input 2:
            A = 10

        Output 2:
            650

        */

        // CODE
        int Solution::solve(int A) {
            if (A <= 0) return 0;

            int magic = 0;
            int powerOf5 = 5;

            for (int i = 0; i <= 31; ++i) {
                if (A & (1 << i)) {
                    magic += powerOf5;
                }
                powerOf5 *= 5;
            }

            return magic;

        }

## Bit Manipulations 2 ##
    // Q1. Single Number
        /*
        Q.1 -> Given an array of integers A, every element appears twice except for one. Find that integer that occurs once.

        Note :
            Your algorithm should have a linear runtime complexity. Could you implement it without using extra memory? 

        Problem Constraints
            1 <= |A| <= 2000000
            0 <= A[i] <= INTMAX

        Input Format
            The first and only argument of input contains an integer array A.

        Output Format
            Return a single integer denoting the single element.

        Input 1:
            A = [1, 2, 2, 3, 1]

        Output 1:
            3

        Input 2:
            A = [1, 2, 2]

        Output 2:
            1

        */

        // CODE
        int Solution::singleNumber(const vector<int> &A) {
            int ans = 0;
            for(int i=0; i<A.size(); i++){
                ans = ans^A[i];
            }

            return ans;
        }
    // Q2. Single Number II
        /*

        Q.2 -> Given an array of integers, every element appears thrice except for one, which occurs once.
        Find that element that does not appear thrice.

        Note :
            Your algorithm should have a linear runtime complexity.
            Could you implement it without using extra memory?
            

        Problem Constraints
            2 <= A <= 5*10^6
            0 <= A <= INTMAX

        Input Format
            First and only argument of input contains an integer array A.       

        Output Format
            Return a single integer.

        Input 1:
            A = [1, 2, 4, 3, 3, 2, 2, 3, 1, 1]

        Output 1:
            4

        Input 2:
            A = [0, 0, 0, 1]

        Output 2:
            1

        */

        // CODE
        int Solution::singleNumber(const vector<int> &A) {

            int ans = 0;
            for(int b=0; b<31; b++){
                int count = 0;
                for (int i=0; i<A.size(); i++){
                    if((A[i] & (1<<b)) > 0){
                        count++;
                    }
                }
                if(count %3 == 1){
                    ans = ans | (1<<b);
                }
            }

            return ans;
        }
    // Q3. Single Number III
        /*
        Q.3 -> Given an array of positive integers A, two integers appear only once, and all the other integers appear twice.
        Find the two integers that appear only once.


        Note :
            Return the two numbers in ascending order.

        Problem Constraints
            2 <= |A| <= 100000
            1 <= A[i] <= 10^9

        Input Format
            The first argument is an array of integers of size N.

        Output Format
            Return an array of two integers that appear only once.

        Input 1:
            A = [1, 2, 3, 1, 2, 4]

        Output 1:
            [3, 4]

        Input 2:
            A = [1, 2]

        Output 2:
            [1, 2]

        */

        // CODE
        vector<int> Solution::solve(vector<int> &A) {

            int xo = A[0];
            for(int i=1; i<A.size(); i++){
                xo ^= A[i];
            }

            // find position of anyone set bit

            int b=-1;

            for (int i=0; i<=31; i++){
                if((xo & (1<<i)) > 0){
                    b=i;
                    break;
                }
            }

            int x = 0;
            int y = 0;

            for (int i=0; i<A.size(); i++){
                if((A[i] & (1<< b)) > 0){
                    x ^= A[i];
                }else{
                    y ^= A[i];
                }
            }

            if (x > y) {
                return {y, x};
            } else {
                return {x, y};
            }

        }
    // Q4. Find Two Missing Numbers
        /*
        Q.4 ->Given an array A of length N where all the elements are distinct and are in the range [1, N+2].
        Two numbers from the range [1, N+2] are missing from the array A. Find the two missing numbers.

        Note :
            

        Problem Constraints
            1 <= N <= 10^5
            1 <= A[i] <= N+2
            The elements of array A are distinct

        Input Format
            Only argument A is an array of integers 

        Output Format
            Return a sorted array of size 2 denoting the missing elements.

        Input 1:
            A = [3, 2, 4]

        Output 1:
            3[1, 5]

        Input 2:
            A = [5, 1, 3, 6]

        Output 2:
            [2, 4]

        */

        // CODE
        vector<int> Solution::solve(vector<int> &A) {

            int N = A.size();
            long long totalSum = (N + 2LL) * (N + 3) / 2; // Sum of first N+2 natural numbers
            long long totalSquareSum = (N + 2LL) * (N + 3) * (2 * (N + 2) + 1) / 6; // Sum of squares of first N+2 natural numbers

            long long arraySum = 0;
            long long arraySquareSum = 0;

            for (int num : A) {
                arraySum += num;
                arraySquareSum += (long long)num * num;
            }

            long long sumDiff = totalSum - arraySum; // x + y
            long long squareSumDiff = totalSquareSum - arraySquareSum; // x^2 + y^2

            // (x + y)^2 = x^2 + y^2 + 2xy
            long long xySum = (sumDiff * sumDiff - squareSumDiff) / 2; // x * y

            long long discriminant = sumDiff * sumDiff - 4 * xySum;
            int x = (sumDiff + sqrt(discriminant)) / 2;
            int y = sumDiff - x;

            if (x > y) {
                return {y, x};
            } else {
                return {x, y};
            }
        }
    // Q5. Maximum AND Pair
        /*
        Q.5 -> Given an array A. For every pair of indices i and j (i != j), find the maximum A[i] & A[j].

        Note :

        Problem Constraints
            1 <= len(A) <= 10^5
            1 <= A[i] <= 10^9

        Input Format
            The first argument is an integer array A.   

        Output Format
            Return a single integer that is the maximum A[i] & A[j].

        Input 1:
            A = [53, 39, 88]

        Output 1:
            37

        Input 2:
            A = [38, 44, 84, 12] 

        Output 2:
            36

        */

        // CODE
        int Solution::solve(vector<int> &A) {
        int ans = 0;

        for (int b=31; b>=0; b--){
            int count = 0;
            for (int i=0; i<A.size(); i++){
                if((A[i]&(1<<b)) > 0){
                    count++;
                }
            }

            if (count >=2){
                ans = ans | (1<<b);
                for(int i=0; i<A.size(); i++){
                        if((A[i]&(1<<b)) == 0){
                            A[i] = 0;
                        }
                }
            }
        }

        return ans;
        }
    // Q6. SUBARRAY OR
        /*
        Q.6 -> You are given an array of integers A of size N.
        The value of a subarray is defined as BITWISE OR of all elements in it.
        Return the sum of value of all subarrays of A % 10^9 + 7.

        Note :
            

        Problem Constraints
            1 <= N <= 10^5
            1 <= A[i] <= 10^8

        Input Format
            The first argument given is the integer array A. 

        Output Format
            Return the sum of Value of all subarrays of A % 10^9 + 7.

        Input 1:
            A = [1, 2, 3, 4, 5]

        Output 1:
            71

        Input 2:
            A = [7, 8, 9, 10]

        Output 2:
            110

        */

        // CODE
        int Solution::solve(vector<int> &A) {

            const int MOD = 1000000007;

            int N = A.size();
            long long result = 0;

            // Iterate over each bit position
            for (int bit = 0; bit < 31; ++bit) {
                long long contribution = 0;
                int lastIndex = -1;

                for (int i = 0; i < N; ++i) {
                    if (A[i] & (1 << bit)) {
                        lastIndex = i;
                    }
                    contribution += (lastIndex + 1);
                    contribution %= MOD;
                }

                result += (contribution * (1 << bit)) % MOD;
                result %= MOD;
            }

            return result;
        }
    // Q1. Strange Equality
        /*
        Q.1 -> Given an integer A.
        Two numbers, X and Y, are defined as follows:
        X is the greatest number smaller than A such that the XOR sum of X and A is the same as the sum of X and A.
        Y is the smallest number greater than A, such that the XOR sum of Y and A is the same as the sum of Y and A.
        Find and return the XOR of X and Y.


        NOTE 1: XOR of X and Y is defined as X ^ Y where '^' is the BITWISE XOR operator.
        NOTE 2: Your code will be run against a maximum of 100000 Test Cases. 
            

        Problem Constraints
            1 <= A <= 10^9

        Input Format
            First and only argument is an integer A.

        Output Format
            Return an integer denoting the XOR of X and Y.

        Input 1:
            A = 5

        Output 1:
            10

        */

        // CODE
        int Solution::solve(int A) {
        // Special case for A = 0
        if (A == 0) {
            return 0;
        }

        // Find the rightmost set bit (consider all bits for A with only 1 set bit)
        int rightmost_set_bit = A;

        // Handle cases where A has multiple set bits (excluding LSB)
        if (A > 0) {
            rightmost_set_bit = A & (A - 1);
        }

        // Calculate X (XOR with rightmost set bit)
        int X = A ^ rightmost_set_bit;

        // Calculate Y (add rightmost set bit)
        int Y = A + rightmost_set_bit;

        // XOR of X and Y
        return X ^ Y;
        }
    // Q2. Min XOR value
        /*
        Q.2 -> Given an integer array A of N integers, find the pair of integers in the array which have minimum XOR value. Report the minimum XOR value.
        Note :
            

        Problem Constraints
            2 <= length of the array <= 100000
            0 <= A[i] <= 10^9

        Input Format
            First and only argument of input contains an integer array A.

        Output Format
            Return a single integer denoting minimum xor value.

        Input 1:
            A = [0, 2, 5, 7]

        Output 1:
            2

        Input 2:
            A = [0, 4, 7, 9]

        Output 2:
            3

        */

        // CODE
        int Solution::findMinXor(vector<int> &A) {
            // Sort the array
            sort(A.begin(), A.end());
            
            int minXOR = INT_MAX;
            
            // Calculate minimum XOR between adjacent elements
            for (int i = 0; i < A.size() - 1; ++i) {
                int currentXOR = A[i] ^ A[i + 1];
                minXOR = min(minXOR, currentXOR);
            }
            
            return minXOR;
        }
    // Q3. Sum of Xor of all Pairs
        /*
        Q.3 -> 
        Given an array A of N integers. Find the sum of bitwise XOR all pairs of numbers in the array.
        Since the answer can be large, return the remainder after the dividing the answer by 10^9+7.

        Note :

        Problem Constraints
            1 <= N <= 10^5
            1 <= A[i] < 10^9

        Input Format
            Only argument A is an array of integers
            

        Output Format
            Return an integer denoting the sum of xor of all pairs of number in the array.

        Input 1:
            A = [1, 2, 3]

        Output 1:
            6

        Input 2:
            A = [3, 4, 2]

        Output 2:
            14

        */

        // CODE
        int Solution::solve(vector<int> &A) {
            int MOD = 1000000007;
            int N = A.size();
            long long totalXOR = 0;
            
            // Calculate total XOR of all elements
            for (int num : A) {
                totalXOR ^= num;
            }
            
            long long result = 0;
            
            // Calculate the contribution of each bit position
            for (int bit = 0; bit <= 30; ++bit) {
                long long countOnes = 0;
                for (int num : A) {
                    if (num & (1 << bit)) {
                        countOnes++;
                    }
                }
                
                // Number of pairs where both numbers have this bit set
                long long pairsWithBitSet = (countOnes * (N - countOnes)) % MOD;
                
                // Contribution to the result by this bit position
                result = (result + (pairsWithBitSet * (1LL << bit)) % MOD) % MOD;
            }
            
            return result;
        }

## Bit Manipulation Extra ##
    // Introduction To Bit Manipulation
    // Must Know Tricks in Bit Manipulation | Swap two numbers without third variable
        // Swap two NO
            // XOR swap algorithm
            A = A ^ B;
            B = A ^ B;  // (A ^ B) ^ B = A
            A = A ^ B;  // (A ^ B) ^ A = B
        // Check if the ith Bit is Set
            bool isBitSetLeftShift(int N, int i) {
                return (N & (1 << i)) != 0;
            }

            bool isBitSetRightShift(int N, int i) {
                return ((N >> i) & 1) == 1;
            }
        // Set the ith Bit
            int setBit(int N, int i) {
                return N | (1 << i);
            }
        // Unset the ith Bit
            int unsetBit(int N, int i) {
                return N & ~(1 << i);
            }

        //  Toggle the ith Bit
            int toggleBit(int N, int i) {
                return N ^ (1 << i);
            }
        // Remove the Last Set Bit (Rightmost)
            int removeLastSetBit(int N) {
                return N & (N - 1);
            }
        // Check if a Number is a Power of 2
            bool isPowerOfTwo(int N) {
                return (N > 0) && ((N & (N - 1)) == 0);
            }
        // Count the Number of Set Bits
            // Method 1: Modulo Operation
            int countSetBits(int N) {
                int cnt = 0;
                while (N > 1) {
                    if (N % 2 == 1) cnt++;
                    N = N / 2;
                }
                if (N == 1) cnt++;
                return cnt;
            }
        // Method 2: Using Bitwise AND with Right Shift
        int countSetBits(int N) {
            int cnt = 0;
            while (N > 0) {
                cnt += N & 1;
                N = N >> 1;
            }
            return cnt;
        }

        // Method 3: Using N & (N - 1)
        int countSetBits(int N) {
            int cnt = 0;
            while (N != 0) {
                N = N & (N - 1);
                cnt++;
            }
            return cnt;
        }
    // Minimum Bit Flips to Convert Number | Bit Manipulation
        int minBitFlips(int A, int B) {
            int XOR = A ^ B;  // XOR operation to find differing bits
            int count = 0;
            
            // Count the number of 1's in XOR result
            while (XOR > 0) {
                XOR = XOR & (XOR - 1);  // Removes the rightmost set bit
                count++;
            }
            return count;
        }
    // Power Set
        void printAllSubsets(const vector<int>& set) {
            int n = set.size();
            int powerSetSize = 1 << n; // 2^n subsets

            for (int mask = 0; mask < powerSetSize; ++mask) {
                cout << "{ ";
                for (int i = 0; i < n; ++i) {
                    // Check if the ith bit in the mask is set
                    if (mask & (1 << i)) {
                        cout << set[i] << " ";
                    }
                }
                cout << "}" << endl;
            }
        }
    // Single Number-I
        int singleNumber(const vector<int>& nums) {
            int result = 0;
            for (int num : nums) {
                result ^= num; // XOR all numbers
            }
            return result;
        }
    // Single Number II
        // solution 1
        int singleNumber(vector<int>& nums) {
            int ans = 0;
            // Iterate over each bit position from 0 to 31
            for (int bit = 0; bit < 32; ++bit) {
                int cnt = 0;
                // Count the number of `1`s at the current bit position across all numbers
                for (int num : nums) {
                    if (num & (1 << bit)) { // Check if the `bit` is set in `num`
                        cnt++;
                    }
                }
                // If the count is not divisible by 3, set the corresponding bit in `ans`
                if (cnt % 3 != 0) {
                    ans |= (1 << bit); // Set the `bit` in `ans`
                }
            }
            return ans;
        }

        // Solution 2
        int singleNumber(vector<int>& nums) {
            sort(nums.begin(), nums.end()); // Sort the array
            int n = nums.size();
            
            // Check in steps of 3 for mismatch
            for (int i = 1; i < n; i += 3) {
                if (nums[i] != nums[i - 1]) {
                    return nums[i - 1]; // Found the single number
                }
            }
            return nums[n - 1]; // Return the last element if not found earlier
        }

        // Solution 3
        int singleNumber(vector<int>& nums) {
            int ones = 0, twos = 0;
            
            for (int num : nums) {
                ones = (ones ^ num) & ~twos; // Update `ones` with the bits that have appeared once
                twos = (twos ^ num) & ~ones; // Update `twos` with the bits that have appeared twice
            }
            
            return ones; // The single number remains in `ones`
        }
    // Single Number III
        vector<int> singleNumber(vector<int>& nums) {
            int xorResult = 0;
            // Step 1: XOR all elements to find xorResult = a ^ b (where a and b are the unique numbers)
            for (int num : nums) {
                xorResult ^= num;
            }
            
            // Step 2: Find the rightmost set bit in xorResult
            int rightmostSetBit = xorResult & -xorResult; // Isolates the rightmost set bit
            // int rightmostSetBit = (xorResult & xorResult-1) & xorResult; // Isolates the rightmost set bit
            
            // Step 3: Divide elements into two groups and XOR separately
            int num1 = 0, num2 = 0;
            for (int num : nums) {
                if (num & rightmostSetBit) {
                    num1 ^= num; // XOR group where the bit is set
                } else {
                    num2 ^= num; // XOR group where the bit is not set
                }
            }
            
            return {num1, num2};
        }
    // XOR of Numbers in a Given Range
    // Function to compute XOR from 1 to N
        int xorFrom1ToN(int N) {
            if (N % 4 == 0) return N;
            if (N % 4 == 1) return 1;
            if (N % 4 == 2) return N + 1;
            return 0; // N % 4 == 3
        }

        // Function to compute XOR from L to R
        int xorFromLToR(int L, int R) {
            return xorFrom1ToN(R) ^ xorFrom1ToN(L - 1);
        }
        

    // Divide Two Integers without using Multiplication and Division Operators
        int divide(int dividend, int divisor) {
            // Handle edge cases
            if (divisor == 0) return INT_MAX; // Division by zero case
            if (dividend == INT_MIN && divisor == -1) return INT_MAX; // Overflow case
            
            // Determine the sign of the result
            bool negative = (dividend < 0) ^ (divisor < 0); // True if the result is negative
            
            // Convert both dividend and divisor to their absolute values
            long long absDividend = abs((long long)dividend);
            long long absDivisor = abs((long long)divisor);
            
            long long result = 0;
            
            // Use bitwise shifting to divide
            while (absDividend >= absDivisor) {
                long long tempDivisor = absDivisor, multiple = 1;
                // Shift divisor left (equivalent to multiplying by 2) until it exceeds the dividend
                while (absDividend >= (tempDivisor << 1)) {
                    tempDivisor <<= 1;
                    multiple <<= 1;
                }
                // Subtract the shifted divisor from the dividend
                absDividend -= tempDivisor;
                // Add the multiple to the result
                result += multiple;
            }
            
            // Apply sign to the result
            result = negative ? -result : result;
            
            // Clamp result to integer range
            if (result > INT_MAX) return INT_MAX;
            if (result < INT_MIN) return INT_MIN;
            
            return (int)result;
        }
---------------------------------------------------------------------------------------------------------------
//######################
//## UNIT 2 ##
//###################### 
---------------------------------------------------------------------------------------------------------------
// String
## String Basics ##
    // Q1. Toggle Case
        /*
        Q.1 -> You are given a character string A having length N, consisting of only lowercase and uppercase latin letters.
        You have to toggle case of each character of string A. For e.g 'A' is changed to 'a', 'e' is changed to 'E', etc.

        Note :
            

        Problem Constraints
            1 <= N <= 10^5
            A[i]  ['a'-'z', 'A'-'Z']



        Input Format
            First and only argument is a character string A.   

        Output Format
            Return a character string.

        Input 1:
            A = "Hello" 

        Output 1:
            hELLO 

        Input 2:
            A = "tHiSiSaStRiNg" 

        Output 2:
            ThIsIsAsTrInG 

        */

        // CODE
        string Solution::solve(string A) {

            for(int i=0; i<A.length(); i++){
                char ch = A[i];
                if('a'<= ch && ch <= 'z'){
                    A[i]=(char)(ch-32);
                }else{
                    A[i] = (char)(ch+32);
                }
            }

            return A;
        }
    // Q2. Simple Reverse
        /*
        Q.2 -> Given a string A, you are asked to reverse the string and return the reversed string.

        Note :
            

        Problem Constraints
            1 <= |A| <= 10^5
            String A consist only of lowercase characters. 

        Input Format
            First and only argument is a string A.   

        Output Format
            Return a string denoting the reversed string.

        Input 1:
            A = "scaler"

        Output 1:
            "relacs"

        Input 2:
            A = "academy"

        Output 2:
            "ymedaca"

        */

        // CODE
        string Solution::solve(string A) {

            int i = 0;
            int j= A.length()-1;

            while(i<j){
                char temp = A[i];
                A[i] = A[j];
                A[j] = temp;
                i++;
                j--;
            }

            return A;
        }
    // Q3. Reverse the String
        /*
        Q.3 -> You are given a string A of size N.
        Return the string A after reversing the string word by word.

        Note :
            A sequence of non-space characters constitutes a word.
            Your reversed string should not contain leading or trailing spaces, even if it is present in the input string.
            If there are multiple spaces between words, reduce them to a single space in the reversed string.
        

        Problem Constraints
            1 <= N <= 3 * 10^5

        Input Format
            The only argument given is string A.   

        Output Format
            Return the string A after reversing the string word by word.


        Input 1:
            A = "the sky is blue"

        Output 1:
            "blue is sky the"

        Input 2:
            A = "this is ib"

        Output 2:
            "ib is this"  

        */

        // CODE
        string Solution::solve(string A) {

            int start = 0, end = A.size() - 1;
            while (start <= end && A[start] == ' ') start++;
            while (end >= start && A[end] == ' ') end--;

            if (start > end) return "";

            vector<string> words;
            stringstream ss(A.substr(start, end - start + 1));
            string word;
            while (ss >> word) {
                words.push_back(word);
            }

            reverse(words.begin(), words.end());

            string reversedString;
            for (int i = 0; i < words.size(); ++i) {
                reversedString += words[i];
                if (i != words.size() - 1) {
                    reversedString += ' ';
                }
            }

            return reversedString;
        }
    // Q4. Longest Palindromic Substring
        /*
        Q.4 -> Given a string A of size N, find and return the longest palindromic substring in A.
        Substring of string A is A[i...j] where 0 <= i <= j < len(A)
        Palindrome string:
        A string which reads the same backwards. More formally, A is palindrome if reverse(A) = A.
        Incase of conflict, return the substring which occurs first ( with the least starting index).

        Note :
            

        Problem Constraints
            1 <= N <= 6000  

        Input Format
            First and only argument is a string A.   

        Output Format
            Return a string denoting the longest palindromic substring of string A.

        Input 1:
            A = "aaaabaaa"

        Output 1:
            "aaabaaa"

        Input 2:
            A = "abba

        Output 2:
            "abba"

        */

        // CODE
        string Solution::longestPalindrome(string A) {
            int n = A.size();
            if (n == 0) return "";

            int oddans = 1;
            int osi = 0;
            int oei = 0;


            for (int i = 0; i < n; i++) {
                int l = i;
                int r = i;
                while (l >= 0 && r < n && A[l] == A[r]) {
                    int len = r - l + 1;
                    if (len > oddans) {
                        oddans = len;
                        osi = l;
                        oei = r;
                    }
                    l--;
                    r++;
                }
            }

            int evenans = 0; 
            int esi = 0;
            int eei = 0;

            for (int i = 1; i < n; i++) {
                int l = i - 1;
                int r = i;
                while (l >= 0 && r < n && A[l] == A[r]) {
                    int len = r - l + 1;
                    if (len > evenans) {
                        evenans = len;
                        esi = l;
                        eei = r;
                    }
                    l--;
                    r++;
                }
            }

            if (evenans > oddans) {
                return A.substr(esi, evenans);
            } else {
                return A.substr(osi, oddans);
            }
            
        }
    // Q1. Longest Common Prefix
        /*
        Q.1 -> Given the array of strings A, you need to find the longest string S, which is the prefix of ALL the strings in the array.
        The longest common prefix for a pair of strings S1 and S2 is the longest string S which is the prefix of both S1 and S2.
        Example: the longest common prefix of "abcdefgh" and "abcefgh" is "abc".

        Note :
            

        Problem Constraints
            0 <= sum of length of all strings <= 1000000

        Input Format
            The only argument given is an array of strings A.  

        Output Format
            Return the longest common prefix of all strings in A.

        Input 1:
            A = ["abcdefgh", "aefghijk", "abcefgh"]

        Output 1:
            "a"

        Input 2:
            A = ["abab", "ab", "abcd"];

        Output 2:
            "ab"

        */

        // CODE
        string Solution::longestCommonPrefix(vector<string> &A) {

            int N = A.size();
            std::vector<std::string> str_prefix;
            str_prefix.push_back(A[0]);
            for (int i=1; i<N; i++){
                string A1 =  str_prefix[i-1];
                string A2 = A[i];
                
                // check comman prefix between them
                std::string common_str;
                if(A1.size() < A2.size()){
                    for(int j=0; j<A1.size(); j++){
                        if(A1[j] == A2[j]){
                            common_str+=A1[j];
                        }else{
                            break;
                        }
                    }
                }else{
                for(int j=0; j<A2.size(); j++){
                        
                        if(A1[j] == A2[j]){
                            common_str+=A1[j];
                            
                            
                        }else{
                            break;
                        }
                    }  
                }
                
                str_prefix.push_back(common_str);

            }

            return str_prefix[(str_prefix.size()-1)];
        }
    // Q2. Count Occurrences   
        /*
        Q.2 -> Find the number of occurrences of bob in string A consisting of lowercase English alphabets.


        Note :
            

        Problem Constraints
            1 <= |A| <= 1000

        Input Format
            The first and only argument contains the string A, consisting of lowercase English alphabets.  

        Output Format
            Return an integer containing the answer.

        Input 1:
            "abobc"

        Output 1:
            1

        Input 2:
            "bobob"

        Output 2:
            2

        */

        // CODE
        int Solution::solve(string A) {

            int ocurance = 0;

            for (int i=2 ;i<A.size(); i++){
                if(A[i-2] == 'b' && A[i-1] == 'o' && A[i ]== 'b'){
                    ocurance++;
                }
            }

            return ocurance;
        }

    // Q3. Amazing Subarrays
        /*
        Q.3 -> You are given a string S, and you have to find all the amazing substrings of S.
        An amazing Substring is one that starts with a vowel (a, e, i, o, u, A, E, I, O, U).

        Note :


        Problem Constraints
            1 <= length(S) <= 1e6
            S can have special characters

        Input Format
            Only argument given is string S.  

        Output Format
            Return a single integer X mod 10003, here X is the number of Amazing Substrings in given the string.

        Input 1:
            ABEC

        Output 1:
            6


        */

        // CODE
        int Solution::solve(string A) {
            long result = 0;
            for (long i = 0; i < A.size(); ++i) {
                if (A[i] == 'a' || A[i] == 'e' || A[i] == 'i' || A[i] == 'o' || A[i] == 'u' ||
                    A[i] == 'A' || A[i] == 'E' || A[i] == 'I' || A[i] == 'O' || A[i] == 'U') {
                    
                    result += (A.size()-i);
                }
            }

            return result%10003;
        }
    // Q4. Isalnum()
        /*
        Q.4 -> You are given a function isalpha() consisting of a character array A.
        Return 1 if all the characters of a character array are alphanumeric (a-z, A-Z, and 0-9) else, return 0.

        Note :
            

        Problem Constraints
            1 <= |A| <= 10^5

        Input Format
            Only argument is a character array A.  

        Output Format
            Return 1 if all the characters of the character array are alphanumeric (a-z, A-Z and 0-9), else return 0.

        Input 1:
            A = ['S', 'c', 'a', 'l', 'e', 'r', 'A', 'c', 'a', 'd', 'e', 'm', 'y', '2', '0', '2', '0']

        Output 1:
            1

        Input 2:
            A = ['S', 'c', 'a', 'l', 'e', 'r', '#', '2', '0', '2', '0']

        Output 2:
            0

        */

        // CODE
        int Solution::solve(vector<char> &A) {

            for(int i=0; i<A.size(); i++){
                int ch = A[i];
                if((ch >= 65 && ch <= 90) || (ch >= 97 && ch<= 122) || (ch >= 48 && ch<=57) ){
                
                }else{
                    return 0;
                }
            }

            return 1;
        }
## String Extra ##
    // String Rotation
        String rotation: assume you have a method isSubstring which checks if one word is a substring of another. Given two strings s1 and s2, write code to check if s2 is a rotation of s1 using only one call to isSubstring
        Eg: waterbottle is a rotation of erbottlewat
        // Function to check if s2 is a rotation of s1
        bool isSubstring(const std::string& s1, const std::string& s2) {
            return s1.find(s2) != std::string::npos;
        }

        bool isRotation(const std::string& s1, const std::string& s2) {
            // Check if the lengths of the strings are equal
            if (s1.length() != s2.length() || s1.empty()) {
                return false;
            }
            
            // Concatenate s1 with itself
            std::string concatenated = s1 + s1;

            // Use the isSubstring method to check for rotation
            return isSubstring(concatenated, s2);
        }

        int main() {
            std::string s1 = "waterbottle";
            std::string s2 = "erbottlewat";

            if (isRotation(s1, s2)) {
                std::cout << s2 << " is a rotation of " << s1 << std::endl;
            } else {
                std::cout << s2 << " is not a rotation of " << s1 << std::endl;
            }

            return 0;
        }
// MATHS
## Modular Arithmetic & GCD ##
    // Q1. Pair Sum divisible by M
        /*
        Q.1 -> Given an array of integers A and an integer B, find and return the number of pairs in A whose sum is divisible by B.
        Since the answer may be large, return the answer modulo (109 + 7).
        Note: Ensure to handle integer overflow when performing the calculations.
        Note :
            

        Problem Constraints
            1 <= length of the array <= 100000
            1 <= A[i] <= 109
            1 <= B <= 106


        Input Format
            The first argument given is the integer array A.
            The second argument given is the integer B.

        Output Format
            Return the total number of pairs for which the sum is divisible by B modulo (10^9 + 7).

        Input 1:
            A = [1, 2, 3, 4, 5]
            B = 2

        Output 1:
            4   

        Input 2:
            A = [5, 17, 100, 11]
            B = 28

        Output 2:
            1

        Example Explanation
        Explanation 1:
        All pairs which are divisible by 2 are (1,3), (1,5), (2,4), (3,5). 
        So total 4 pairs.

        */

        // CODE
        int Solution::solve(vector<int> &A, int B) {
            const int MOD = 1e9 + 7;
            vector<int> freq(B, 0);

            int ans = 0;
            for (int i = 0; i < A.size(); i++) {
                int X = (A[i] % B + B) % B; // Ensure X is non-negative
                int Y = (B - X) % B; // Compute complement remainder Y

                ans = (ans + freq[Y]) % MOD;
                freq[X]++;
            }

            return ans;
        }
    // Q2. Greatest Common Divisor
        /*
        Q.2 -> Given 2 non-negative integers A and B, find gcd(A, B)
        GCD of 2 integers A and B is defined as the greatest integer 'g' such that 'g' is a divisor of both A and B. Both A and B fit in a 32 bit signed integer.

        Note: DO NOT USE LIBRARY FUNCTIONS.
            

        Problem Constraints
            0 <= A, B <= 10^9

        Input Format
            First argument is an integer A.
            Second argument is an integer B.

        Output Format
            Return an integer denoting the gcd(A, B).

        Input 1:
            A = 4
            B = 6

        Output 1:
            2

        Input 2:
            A = 6
            B = 7

        Output 2:
            1

        */

        // CODE
        int Solution::gcd(int A, int B) {
            if(B == 0){
                return A;
            }else{
                return gcd(B, A%B);
            }
        }
    // Q3. Delete one
        /*
        Q.3 -> Problem Description
        Given an integer array A of size N. You have to delete one element such that the GCD(Greatest common divisor) of the remaining array is maximum.
        Find the maximum value of GCD.

        Note :
            

        Problem Constraints
            2 <= N <= 10^5
            1 <= A[i] <= 10^9

        Input Format
            First argument is an integer array A.

        Output Format
            Return an integer denoting the maximum value of GCD.

        Input 1:
            A = [12, 15, 18]

        Output 1:
            6

        Input 2:
            A = [5, 15, 30]

        Output 2:
            15

        Example Explanation
            Explanation 1:
                If you delete 12, gcd will be 3.
                If you delete 15, gcd will be 6.
                If you delete 18, gcd will 3.
                Maximum value of gcd is 6.

            Explanation 2:
                If you delete 5, gcd will be 15.
                If you delete 15, gcd will be 5.
                If you delete 30, gcd will be 5.
                Maximum value of gcd is 15.

        */

        // CODE
        int gcd(int A, int B) {
            if(B == 0){
                return A;
            }else{
                return gcd(B, A%B);
            }
        }

        int Solution::solve(vector<int> &A) {

            int n = A.size();
            
            // Edge case: If the array size is 2, return the maximum of the two elements
            if (n == 2) {
                return max(A[0], A[1]);
            }
            
            vector<int> prefixGCD(n, 0);
            vector<int> suffixGCD(n, 0);
            
            // Compute prefix GCD array
            prefixGCD[0] = A[0];
            for (int i = 1; i < n; i++) {
                prefixGCD[i] = gcd(prefixGCD[i - 1], A[i]);
            }
            
            // Compute suffix GCD array
            suffixGCD[n - 1] = A[n - 1];
            for (int i = n - 2; i >= 0; i--) {
                suffixGCD[i] = gcd(suffixGCD[i + 1], A[i]);
            }
            
            // Compute the maximum GCD by removing each element
            int maxGCD = max(suffixGCD[1], prefixGCD[n - 2]);
            for (int i = 1; i < n - 1; i++) {
                int currentGCD = gcd(prefixGCD[i - 1], suffixGCD[i + 1]);
                maxGCD = max(maxGCD, currentGCD);
            }
            
            return maxGCD;

        }
    // Q4. Mod Sum
        /*
        Q.4 -> Given an array of integers A, calculate the sum of A [ i ] % A [ j ] for all possible i, j pairs. Return sum % (109 + 7) as an output.

        Note :
            

        Problem Constraints
            1 <= length of the array A <= 10^5
            1 <= A[i] <= 10^3

        Input Format
            The only argument given is the integer array A.

        Output Format
            Return a single integer denoting sum % (10^9 + 7).

        Input 1:
            A = [1, 2, 3]

        Output 1:
            5

        Input 2:
            A = [17, 100, 11]

        Output 2:
            61

        Explanation 1:
            (1 % 1) + (1 % 2) + (1 % 3) + (2 % 1) + (2 % 2) + (2 % 3) + (3 % 1) + (3 % 2) + (3 % 3) = 5
        */

        // CODE
        int Solution::solve(vector<int> &A) {

            const int MOD = 1000000007;
            const int MAX_VAL = 1000;
            
            // Frequency array to count occurrences of each value in A
            vector<int> freq(MAX_VAL + 1, 0);
            for (int val : A) {
                freq[val]++;
            }

            // Calculate the sum of A[i] % A[j] for all pairs (i, j)
            long long sum = 0;
            for (int i = 1; i <= MAX_VAL; i++) {
                for (int j = 1; j <= MAX_VAL; j++) {
                    if (freq[i] > 0 && freq[j] > 0) {
                        sum = (sum + (long long)freq[i] * freq[j] * (i % j)) % MOD;
                    }
                }
            }

            return (int)sum;
        }
    // Q1. A, B and Modulo
        /*
        Q.1 -> Given two integers A and B, find the greatest possible positive integer M, such that A % M = B % M. 

        Note :
            

        Problem Constraints
            1 <= A, B <= 10^9
            A != B

        Input Format
            The first argument is an integer A.
            The second argument is an integer B.

        Output Format
            Return an integer denoting the greatest possible positive M.

        Input 1:
            A = 1
            B = 2

        Output 1:
            1

        Input 2:
            A = 5
            B = 10

        Output 2:
            5

        Example Explanation
            Explanation 1:
                1 is the largest value of M such that A % M == B % M.

            Explanation 2:
                For M = 5, A % M = 0 and B % M = 0.
                No value greater than M = 5, satisfies the condition.
        */

        // CODE
        int Solution::solve(int A, int B) {
            int diff = abs(A - B);
            
            // Return the difference as it is the greatest possible M
            return diff;
        }
    // Q2. Largest Coprime Divisor
        /*
        Q.2 -> You are given two positive numbers A and B . You need to find the maximum valued integer X such that:
        X divides A i.e. A % X = 0
        X and B are co-prime i.e. gcd(X, B) = 1

        Note :
            

        Problem Constraints
            1 <= A, B <= 10^9

        Input Format
            First argument is an integer A.
            Second argument is an integer B.

        Output Format
            Return an integer maximum value of X as descibed above.

        Input 1:
            A = 30
            B = 12

        Output 1:
            5

        Input 2:
            A = 5
            B = 10

        Output 2:
            1

        Example Explanation
            Explanation 1:
                All divisors of A are (1, 2, 3, 5, 6, 10, 15, 30). 
                The maximum value is 5 such that A%5 == 0 and gcd(5,12) = 1
        */

        // CODE
        int gcd(int A, int B) {
            if(B == 0){
                return A;
            }else{
                return gcd(B, A%B);
            }
        }

        int Solution::cpFact(int A, int B) {
            // Start with X = A
            int X = A;
            
            // Reduce X until gcd(X, B) is 1
            while (gcd(X, B) != 1) {
                X /= gcd(X, B);
            }
            
            // Return the maximum value of X which is co-prime with B
            return X;
        }
    // Q3. Divisor game
        /*
        Q.3 -> Scooby has 3 three integers A, B, and C.
        Scooby calls a positive integer special if it is divisible by B and it is divisible by C. You need to tell the number of special integers less than or equal to A.

        Note :
            

        Problem Constraints
            1 <= A, B, C <= 10^9

        Input Format
            First argument is a positive integer A
            Second argument is a positive integer B
            Third argument is a positive integer C 

        Output Format
            One integer corresponding to the number of special integers less than or equal to A.

        Input 1:
            A = 12
            B = 3
            C = 2

        Output 1:
            2

        Input 2:
            A = 6
            B = 1
            C = 4

        Output 2:
            1

        Example Explanation
            Explanation 1:
                The two integers divisible by 2 and 3 and less than or equal to 12 are 6,12.

            Explanation 2:
                Only 4 is a positive integer less than equal to 6 which is divisible by 1 and 4.
        */

        // CODE
        int gcd(int A, int B) {
            if(B == 0){
                return A;
            }else{
                return gcd(B, A%B);
            }
        }

        int Solution::solve(int A, int B, int C) {
            // Calculate the LCM of B and C
            long long lcmBC = (1LL * B * C) / gcd(B, C);
            
            // Count the number of multiples of lcmBC that are <= A
            int result = A / lcmBC;
            
            return result;
        }

## Combinatorics Basics ##
    // Q1. Pascal Triangle
        /*
        Q.1 ->  Write a program to print the pascal triangle up to A rows.

        Note :
            
        Problem Constraints
            1 <= A <= 25

        Input Format
            The first argument is an integer A.

        Output Format
            Return a 2D array consisting of A rows whose each row contains A integers.

        Input 1:
            A = 3

        Output 1:
            1 0 0 
            1 1 0 
            1 2 1 

        Input 2:
            A = 5

        Output 2:
            1 0 0 0 0
            1 1 0 0 0
            1 2 1 0 0
            1 3 3 1 0
            1 4 6 4 1 

        */

        // CODE
        vector<vector<int> > Solution::solve(int A) {
            // Initialize the 2D vector to store the Pascal triangle
            vector<vector<int>> pascal(A, vector<int>(A, 0));
            
            // Iterate over each row
            for (int i = 0; i < A; i++) {
                // The first element of every row is 1
                pascal[i][0] = 1;
                
                // Iterate over each column starting from the second column
                for (int j = 1; j <= i; j++) {
                    // Every element is the sum of the element directly above and the one to the left of it
                    pascal[i][j] = pascal[i - 1][j - 1] + pascal[i - 1][j];
                }
            }
            
            // Return the 2D array (Pascal triangle) with A rows
            return pascal;
        }
    // Q2. Excel Column Title
        /*
        Q.2 -> Given a positive integer A, return its corresponding column title as it appears in an Excel sheet.
        For example:
            1 -> A
            2 -> B
            3 -> C
            ...
            26 -> Z
            27 -> AA
            28 -> AB 

        Note :
            
        Problem Constraints
            1 <= A <= 10^9

        Input Format
            First and only argument of input contains single integer A  

        Output Format
            Return a string denoting the corresponding title.

        Input 1:
            A = 3

        Output 1:
            "C"

        Input 2:
            A = 27

        Output 2:
            "AA"

        */

        // CODE
        string Solution::convertToTitle(int A) {
            string result = "";
            
            // Continue the conversion process until A becomes zero
            while (A > 0) {
                // Subtract 1 to make it zero-based (this handles the fact that 'A' starts from 1)
                A--;
                
                // Get the character for the current column
                char ch = 'A' + (A % 26);
                result = ch + result;
                
                // Move to the next column position (divide A by 26)
                A /= 26;
            }
            
            return result;
        }
    // Q3. Compute nCr % m
        /*
        Q.3 -> Given three integers A, B, and C, where A represents n, B represents r, and C represents m, find and return the value of nCr % m where nCr % m = (n!/((n-r)!*r!))% m.
        x! means factorial of x i.e. x! = 1 * 2 * 3... * x.

        Note :

        Problem Constraints
            1 <= A * B <= 10^6
            1 <= B <= A
            1 <= C <= 10^6

        Input Format
            The first argument given is integer A ( = n).
            The second argument given is integer B ( = r).
            The third argument given is integer C ( = m).    

        Output Format
            Return the value of nCr % m

        Input 1:
            A = 5
            B = 2
            C = 13

        Output 1:
            10

        Input 2:
            A = 6
            B = 2
            C = 13

        Output 2:
            2

        */

        // CODE
        int Solution::solve(int n, int r, int m) {

            int arr[n+1][r+1];
            for(int i=0;i<=n;i++){
                arr[i][0]=1;
            }
            for(int j=1;j<=r;j++){
                arr[0][j]=0;
            }
            for(int i=1;i<=n;i++){
                for(int j=1;j<=r;j++){
                    arr[i][j]=(arr[i-1][j]%m+arr[i-1][j-1]%m)%m;
                }
            }
            return arr[n][r]%m;
        }
    // Q1. Excel Column Number
        /*
        Q.1 -> Given a column title as appears in an Excel sheet, return its corresponding column number.

        Note :
            

        Problem Constraints
            1 <= length of the column title <= 5

        Input Format
            The only argument is a string that represents the column title in the excel sheet.

        Output Format
            Return a single integer that represents the corresponding column number.

        Input 1:
            AB

        Output 1:
            28

        Input 2:
            BB

        Output 2:
            54

        */

        // CODE
        int Solution::titleToNumber(string A) {
            int column_number = 0;
            int base = 26;
            
            for (char c : A) {
                // Convert character to numeric value ('A' = 1, 'B' = 2, ..., 'Z' = 26)
                int value = c - 'A' + 1;
                // Update the column number
                column_number = column_number * base + value;
            }
            
            return column_number;
        }
    // Q2. Number of Digit One
        /*
        Q.2 -> Given an integer A, find and return the total number of digit 1 appearing in all non-negative integers less than or equal to A.

        Note :
            
        Problem Constraints
            0 <= A <= 10^9

        Input Format
            The only argument given is the integer A.

        Output Format
            Return the total number of digit 1 appearing in all non-negative integers less than or equal to A.

        Input 1:
            A = 10

        Output 1:
            2

        Input 2:
            A = 11

        Output 2:
            4

        */

        // CODE
        int Solution::solve(int A) {
            long long count = 0;
            long long factor = 1;
            long long num = A;
            
            while (num > 0) {
                long long digit = num % 10;
                num /= 10;
                
                count += num * factor;
                
                if (digit > 1) {
                    count += factor;
                } else if (digit == 1) {
                    count += (A % factor) + 1;
                }
                
                factor *= 10;
            }
            
            return count;
        }
    // Q3. Consecutive Numbers Sum
        /*
        Q.3 -> Given a positive integer A.
        Return the number of ways it can be written as a sum of consecutive positive integers.

        Note :
            

        Problem Constraints
            1 <= A <= 10^9

        Input Format
            The first and the only argument of input contains an integer, A.   

        Output Format
            Return an integer, representing the answer as described in the problem statement.

        Input 1:
            A = 5

        Output 1:
            2

        Input 2:
            A = 15

        Output 2:
            4

        */

        // CODE
        int Solution::solve(int A) {
            int count = 0;
            int k = 1;
            
            while (k * (k - 1) / 2 < A) {
                // Check if (A - k*(k-1)/2) is divisible by k
                if ((A - k * (k - 1) / 2) % k == 0) {
                    // Calculate m
                    int m = (A - k * (k - 1) / 2) / k;
                    // m must be positive
                    if (m > 0) {
                        ++count;
                    }
                }
                ++k;
            }
            
            return count;
        }

## Prime Numbers ##
    // Q1. Sorted Permutation Rank
        /*
        Q.1 -> Given a string A. Find the rank of the string amongst its permutations sorted lexicographically.
        Assume that no characters are repeated.

        Note: The answer might not fit in an integer, so return your answer % 1000003

        Note :
            

        Problem Constraints
            1 <= |A| <= 1000

        Input Format
            First argument is a string A.

        Output Format
            Return an integer denoting the rank of the given string.

        Input 1:
            A = "acb"

        Output 1:
            2

        Input 2:
            A = "a"

        Output 2:
            1

        */

        // CODE
        const int MOD = 1000003;

        // Precompute factorials and factorial inverses modulo MOD
        vector<long long> factorial(1001, 1);

        void precomputeFactorials() {
            for (int i = 2; i <= 1000; ++i) {
                factorial[i] = (factorial[i - 1] * i) % MOD;
            }
        }


        int Solution::findRank(string A) {
            precomputeFactorials();
            
            int n = A.length();
            long long rank = 1;
            
            for (int i = 0; i < n; ++i) {
                int count_smaller = 0;
                for (int j = i + 1; j < n; ++j) {
                    if (A[j] < A[i]) {
                        ++count_smaller;
                    }
                }
                
                // Count permutations starting with smaller characters
                rank = (rank + (count_smaller * factorial[n - i - 1]) % MOD) % MOD;
            }
            
            return rank;
        }
    // Q2. Count of divisors
        /*
        Q.2 -> Given an array of integers A, find and return the count of divisors of each element of the array.
        NOTE: The order of the resultant array should be the same as the input array.

        Problem Constraints
            1 <= length of the array <= 100000
            1 <= A[i] <= 10^6

        Input Format
            The only argument given is the integer array A.

        Output Format
            Return the count of divisors of each element of the array in the form of an array.

        Input 1:
            A = [2, 3, 4, 5]

        Output 1:
            [2, 2, 3, 2]

        Input 2:
            A = [8, 9, 10]

        Output 2:
            [4, 3, 4]

        */

        // CODE
        const int MAXN = 1000000;

        vector<int> precomputeDivisors() {
            vector<int> divisor_count(MAXN + 1, 0);

            for (int i = 1; i <= MAXN; ++i) {
                for (int j = i; j <= MAXN; j += i) {
                    ++divisor_count[j];
                }
            }

            return divisor_count;
        }

        vector<int> Solution::solve(vector<int> &A) {
            vector<int> divisor_count = precomputeDivisors();
            vector<int> result;
            
            for (int num : A) {
                result.push_back(divisor_count[num]);
            }
            
            return result;
        }
    // Q3. Find All Primes
        /*
        Q.3 -> Given an integer A. Find the list of all prime numbers in the range [1, A].

        Note :
            

        Problem Constraints
            1 <= A <= 10^6

        Input Format
            Only argument A is an integer.

        Output Format
            Return a sorted array of prime number in the range [1, A].

        Input 1:
            A = 7

        Output 1:
            [2, 3, 5, 7]

        Input 2:
            A = 12

        Output 2:
            [2, 3, 5, 7, 11]

        */

        // CODE
        vector<int> Solution::solve(int A) {
            vector<bool> is_prime(A + 1, true);
            vector<int> primes;
            
            // Handle edge case
            if (A < 2) return primes;
            
            is_prime[0] = is_prime[1] = false; // 0 and 1 are not prime numbers
            
            for (int p = 2; p * p <= A; ++p) {
                if (is_prime[p]) {
                    for (int multiple = p * p; multiple <= A; multiple += p) {
                        is_prime[multiple] = false;
                    }
                }
            }
            
            for (int num = 2; num <= A; ++num) {
                if (is_prime[num]) {
                    primes.push_back(num);
                }
            }
            
            return primes;
        }
    // Q1. Prime Sum
        /*
        Q.1 -> Given an even number A ( greater than 2 ), return two prime numbers whose sum will be equal to the given number.
        If there is more than one solution possible, return the lexicographically smaller solution.
        If [a, b] is one solution with a <= b, and [c,d] is another solution with c <= d, then 
        [a, b] < [c, d], If a < c OR a==c AND b < d.
            
        NOTE: A solution will always exist. Read Goldbach's conjecture.

        Problem Constraints
            4 <= A <= 2*10^7

        Input Format
            First and only argument of input is an even number A.

        Output Format
            Return a integer array of size 2 containing primes whose sum will be equal to given number.

        Input 1:
            4

        Output 1:
            [2, 2]

        */

        // CODE
        vector<int> Solution::primesum(int A) {
            // Initialize the prime vector with true
            vector<int> isprime(A + 1, 1);
            isprime[0] = isprime[1] = 0; // 0 and 1 are not primes

            // Sieve of Eratosthenes to find all primes up to A
            for (int i = 2; i * i <= A; ++i) {
                if (isprime[i]) {
                    for (int j = i * i; j <= A; j += i) {
                        isprime[j] = 0;
                    }
                }
            }

            // Find two primes whose sum is equal to A
            for (int i = 2; i <= A / 2; ++i) {
                if (isprime[i] && isprime[A - i]) {
                    return {i, A - i};
                }
            }
            
            // Return an empty vector in case no solution found (though a solution is guaranteed)
            return {};
        }
    // Q2. Lucky Numbers
        /*
        Q.2 -> A lucky number is a number that has exactly 2 distinct prime divisors.
        You are given a number A, and you need to determine the count of lucky numbers between the range 1 to A (both inclusive).

        Note :
            
        Problem Constraints
            1 <= A <= 50000

        Input Format
            The first and only argument is an integer A.    

        Output Format
            Return an integer i.e the count of lucky numbers between 1 and A, both inclusive.

        Input 1:
            A = 8

        Output 1:
            1

        Input 2:
            A = 12

        Output 2:
            3

        */

        // CODE
        int Solution::solve(int A) {
            vector<int> prime_factors_count(A + 1, 0);
            
            // Sieve to count the number of distinct prime factors for each number
            for (int i = 2; i <= A; ++i) {
                if (prime_factors_count[i] == 0) { // i is a prime number
                    for (int j = i; j <= A; j += i) {
                        prime_factors_count[j]++;
                    }
                }
            }
            
            // Count numbers with exactly 2 distinct prime factors
            int lucky_count = 0;
            for (int i = 1; i <= A; ++i) {
                if (prime_factors_count[i] == 2) {
                    lucky_count++;
                }
            }
            
            return lucky_count;
        }
## Maths Extra ##
// HASHING
## Introduction ##
    // Q1. Frequency of element query
        /*
        Q.1 -> Given an array A. You have some integers given in the array B.
        For the i-th number, find the frequency of B[i] in the array A and return a list containing all the frequencies.

        Note :
            

        Problem Constraints
            1 <= |A| <= 10^5
            1 <= |B| <= 10^5
            1 <= A[i] <= 10^5
            1 <= B[i] <= 10^5

        Input Format
            First argument A is an array of integers.
            Second argument B is an array of integers denoting the queries  

        Output Format
            Return an array of integers containing frequency of the each element in B.

        Input 1:
            A = [1, 2, 1, 1]
            B = [1, 2]

        Output 1:
            [3, 1]

        Input 2:
            A = [2, 5, 9, 2, 8]
            B = [3, 2]

        Output 2:
            [0, 2]

        */

        // CODE
        vector<int> Solution::solve(vector<int> &A, vector<int> &B) {

            unordered_map<int, int> hashMap;
            for(int i=0; i<A.size(); i++){
                if(hashMap.count(A[i]) != 0){
                    int value = hashMap[A[i]];
                    hashMap[A[i]] = value+1;
                }else{
                    hashMap[A[i]] = 1;
                }
            }

            vector<int> result(B.size(), 0);
            for(int i=0; i<B.size(); i++){
                if(hashMap.count((B[i]))){
                    result[i] = hashMap[B[i]];
                }
            }

            return result;
        }
    // Q2. Count distinct elements
        /*
        Q.2 -> Given an array A of N integers, return the number of unique elements in the array.

        Note :
            

        Problem Constraints
            1 <= N <= 10^5
            1 <= A[i] <= 10^9

        Input Format
            First argument A is an array of integers.

        Output Format
            Return an integer.

        Input 1:
            A = [3, 4, 3, 6, 6]

        Output 1:
            3

        Input 2:
            A = [3, 3, 3, 9, 0, 1, 0]

        Output 2:
            4

        */

        // CODE
        int Solution::solve(vector<int> &A) {

            std::unordered_map<int, int> hashMap;

            for(int i=0; i<A.size(); i++){
                if(hashMap.find(A[i]) != hashMap.end()){
                    int value = hashMap[A[i]];
                    hashMap[A[i]] = value+1;
                }else{
                    hashMap[A[i]] = 1;
                }
            }

            return hashMap.size();
            
        }
        int Solution::solve(std::vector<int> &A) {
            std::unordered_set<int> hs;

            for (int i = 0; i < A.size(); i++) {
                hs.insert(A[i]);
            }

            return hs.size();
        }
    // Q3. First Repeating element
        /*
        Q.3 -> Given an integer array A of size N, find the first repeating element in it.
        We need to find the element that occurs more than once and whose index of the first occurrence is the smallest.
        If there is no repeating element, return -1.

        Note :
            

        Problem Constraints
            1 <= N <= 10^5
            1 <= A[i] <= 10^9

        Input Format
            The first and only argument is an integer array A of size N.

        Output Format
            Return an integer denoting the first repeating element.

        Input 1:
            A = [10, 5, 3, 4, 3, 5, 6]

        Output 1:
            5

        Input 2:
            A = [6, 10, 5, 4, 9, 120]

        Output 2:
            -1

        */

        // CODE
        int Solution::solve(vector<int> &A) {

            std::unordered_map<int, int> hashMap;
            for(int i=0; i<A.size(); i++){
                if(hashMap.find(A[i]) != hashMap.end()){
                    int value = hashMap[A[i]];
                    hashMap[A[i]] = value+1;
                }else{
                    hashMap[A[i]] = 1;
                }
            }

            for(int i=0; i<A.size(); i++){
                if(hashMap[A[i]] > 1){
                    return A[i];
                }
            }
            return -1;
        }
    // Q4. Sub-array with 0 sum
        /*
        Q.4 -> Given an array of integers A, find and return whether the given array contains a non-empty subarray with a sum equal to 0.
        If the given array contains a sub-array with sum zero return 1, else return 0.

        Note :
            

        Problem Constraints
            1 <= |A| <= 100000
            -10^9 <= A[i] <= 10^9

        Input Format
            The only argument given is the integer array A.

        Output Format
            Return whether the given array contains a subarray with a sum equal to 0.

        Input 1:
            A = [1, 2, 3, 4, 5]

        Output 1:
            0

        Input 2:
            A = [4, -1, 1]

        Output 2:
            1

        */

        // CODE
        int Solution::solve(vector<int> &A) {
            if (A.empty()) {
                return 0;
            }

            // To store prefix sums
            std::unordered_set<long> prefixSumSet;
            long prefixSum = 0;

            // Iterate through the array
            for (int num : A) {
                // Update prefix sum
                prefixSum += num;

                // Check if prefix sum is zero or if it has been seen before
                if (prefixSum == 0 || prefixSumSet.count(prefixSum) != 0) {
                    return 1; // Subarray with zero sum found
                }

                // Add current prefix sum to the set
                prefixSumSet.insert(prefixSum);
            }

            return 0; // No subarray with zero sum
        }
    // Q5. Common Elements
        /*
        Q.5 -> Given two integer arrays, A and B of size N and M, respectively. Your task is to find all the common elements in both the array.

        Note :
            Each element in the result should appear as many times as it appears in both arrays.
            The result can be in any order.

        Problem Constraints
            1 <= N, M <= 10^5
            1 <= A[i] <= 10^9

        Input Format
            First argument is an integer array A of size N.
            Second argument is an integer array B of size M.

        Output Format
            Return an integer array denoting the common elements.

        Input 1:
            A = [1, 2, 2, 1]
            B = [2, 3, 1, 2]

        Output 1:
            [1, 2, 2]

        Input 2:
            A = [2, 1, 4, 10]
            B = [3, 6, 2, 10, 10]

        Output 2:
            [2, 10]

        */

        // CODE
        vector<int> Solution::solve(vector<int> &A, vector<int> &B) {

            std::unordered_map<int, int> countMap;
            std::vector<int> result;

            // Count occurrences of each element in A
            for (int num : A) {
                countMap[num]++;
            }

            // Find common elements in B
            for (int num : B) {
                if (countMap[num] > 0) {
                    result.push_back(num);
                    countMap[num]--;  // Decrease the count
                }
            }

            return result;
        }
    // Q1. Count unique elements
        /*
        Q.1 -> You are given an array A of N integers. Return the count of elements with frequncy 1 in the given array.

        Note :
            

        Problem Constraints
            1 <= N <= 10^5
            1 <= A[i] <= 10^9

        Input Format
            First argument A is an array of integers. 

        Output Format
            Return an integer.

        Input 1:
            A = [3, 4, 3, 6, 6]

        Output 1:
            1  

        Input 2:
            A = [3, 3, 3, 9, 0, 1, 0]

        Output 2:
            2

        */

        // CODE
        int Solution::solve(vector<int> &A) {

            std::unordered_map<int, int> hashMap;
            for(int i=0; i<A.size(); i++){
                if(hashMap.find(A[i]) != hashMap.end()){
                    int value = hashMap[A[i]];
                    hashMap[A[i]] = value+1;
                }else{
                    hashMap[A[i]] = 1;
                }
            }

            int count = 0;
            for (const auto& pair : hashMap) {
            if(pair.second == 1){
                count++;
            }
            }

            return count;
        }
    // Q2. Count Subarray Zero Sum
        /*
        Q.2 -> Given an array A of N integers.

        Find the count of the subarrays in the array which sums to zero. Since the answer can be very large, return the remainder on dividing the result with 10^9+7

        Note :

        Problem Constraints
            1 <= N <= 10^5
            -10^9 <= A[i] <= 10^9

        Input Format
            Single argument which is an integer array A.

        Output Format
            Return an integer.

        Input 1:
            A = [1, -1, -2, 2]

        Output 1:
            3    

        Input 2:
            A = [-1, 2, -1]

        Output 2:
            1

        */

        // CODE
        int Solution::solve(vector<int> &A) {
            const int MOD = 1000000007;
        // To store the frequency of prefix sums
            std::unordered_map<long, int> prefixSumFrequency;
            long prefixSum = 0;
            int count = 0;

            // Initialize the prefix sum frequency map with prefix sum 0
            prefixSumFrequency[0] = 1;

            // Iterate through the array
            for (int num : A) {
                // Update prefix sum
                prefixSum += num;

                // If the prefix sum has been seen before, add its frequency to the count
                if (prefixSumFrequency.count(prefixSum)) {
                    count = (count + prefixSumFrequency[prefixSum]) % MOD;
                }

                // Update the frequency of the current prefix sum
                prefixSumFrequency[prefixSum]++;
            }

            return count;
        }

## Problems ##
    // Q1. Check Pair Sum
        /*
        Q.1 -> Given an Array of integers B, and a target sum A.
        Check if there exists a pair (i,j) such that Bi + Bj = A and i!=j.

        Note :
            

        Problem Constraints
            1 <= Length of array B <= 10^5
            0 <= Bi <= 10^9
            0 <= A <= 10^9

        Input Format
            First argument A is the Target sum, and second argument is the array B 

        Output Format
            Return an integer value 1 if there exists such pair, else return 0.

        Input 1:
            A = 8   
            B = [3, 5, 1, 2, 1, 2]

        Output 1:
            1

        Input 2:
            A = 21   
            B = [9, 10, 7, 10, 9, 1, 5, 1, 5]

        Output 2:
            0

        */

        // CODE
        int Solution::solve(int A, vector<int> &B) {
            std::unordered_set<int> hashSet;
            for (int i=0; i<B.size(); i++){
                int check = A - B[i];
                if (hashSet.count(check)) {
                    return 1;
                }else{
                    hashSet.insert(B[i]);
                }
            }

            return 0;
        }
    // Q2. Count Pair Difference
        /*
        Q.2 -> You are given an array A of N integers and an integer B.
        Count the number of pairs (i,j) such that A[i] - A[j] = B and i  j.

        Since the answer can be very large, return the remainder after dividing the count with 109+7.

        Note :
            

        Problem Constraints
            1 <= N <= 10^5
            1 <= A[i] <= 10^9
            1 <= B <= 10^9 

        Input Format
            First argument A is an array of integers and second argument B is an integer.

        Output Format
            Return an integer.

        Input 1:
            A = [3, 5, 1, 2]
            B = 4

        Output 1:
            1

        Input 2:
            A = [1, 2, 1, 2]
            B = 1

        Output 2:
            4

        */

        // CODE
        int Solution::solve(vector<int> &A, int B) {

            unordered_map<int, int> freq;
            const int MOD = 1000000007;
            long long count = 0;

            for (int i=0; i<A.size(); i++){
            int num = A[i];
            if (freq.count(A[i] - B)) {
                    count = (count + freq[A[i] - B]) % MOD;
                }
                // Check for pairs where A[j] - A[i] = B
                if (freq.count(A[i] + B)) {
                    count = (count + freq[A[i] + B]) % MOD;
                }
                // Increase the frequency of the current number
                freq[A[i]]++;
            }

            return count;

        }
    // Q3. Subarray Sum Equals K
        /*
        Q.3 -> Given an array of integers A and an integer B.
        Find the total number of subarrays having sum equals to B.

        Note :
            

        Problem Constraints
            1 <= length of the array <= 50000
            -1000 <= A[i] <= 1000

        Input Format
            The first argument given is the integer array A.
            The second argument given is integer B.

        Output Format
            Return the total number of subarrays having sum equals to B.

        Input 1:
            A = [1, 0, 1]
            B = 1

        Output 1:
            4

        Input 2:
            A = [0, 0, 0]
            B = 0

        Output 2:
            6

        */

        // CODE
        int Solution::solve(vector<int> &A, int B) {

            int count  = 0;
            std::unordered_map<int, int> hashMap;

            int P = 0;

            for (int i=0; i<A.size(); i++){

                P += A[i];

                // If the current prefix sum is equal to B, increment count
                if (P == B) {
                    count++;
                }

                // If (P - B) is found in the hashMap, it means there is a subarray
                // ending at the current index with sum equal to B
                if (hashMap.count(P - B)) {
                    count += hashMap[P - B];
                }

                // Increment the count of the current prefix sum in the hashMap
                hashMap[P]++;
            
            }

            return count;
            
        }
    // Q4. Distinct Numbers in Window
        /*
        Q.4 -> You are given an array of N integers, A1, A2 ,..., AN and an integer B. Return the of count of distinct numbers in all windows of size B.
        Formally, return an array of size N-B+1 where i'th element in this array contains number of distinct elements in sequence Ai, Ai+1 ,..., Ai+B-1.

        NOTE: if B > N, return an empty array.

        Problem Constraints
            1 <= N <= 10^6
            1 <= A[i] <= 10^9

        Input Format
            First argument is an integer array A
            Second argument is an integer B. 

        Output Format
            Return an integer array.

        Input 1:
            A = [1, 2, 1, 3, 4, 3]
            B = 3

        Output 1:
            [2, 3, 3, 2]

        Input 2:
            A = [1, 1, 2, 2]
            B = 1

        Output 2:
            [1, 1, 1, 1]

        */

        // CODE
        vector<int> Solution::dNums(vector<int> &A, int B) {

            std::unordered_map<int, int> hashMap;
            vector<int> result;

            for (int i=0; i<B; i++){
                if (hashMap.count(A[i])) {
                    hashMap[A[i]]++;
                }else{
                hashMap[A[i]]  = 1; 
                }
            }
            result.push_back(hashMap.size());

            for(int i=B; i<A.size(); i++){
                if (hashMap.count(A[i])) {
                    hashMap[A[i]]++;
                }else{
                hashMap[A[i]]  = 1; 
                }

                int f = hashMap[A[i-B]]; // last element of privious window A[i-B]
                if(f == 1){
                    hashMap.erase(A[i-B]);
                }else{
                hashMap[A[i-B]]--;
                }

                result.push_back(hashMap.size());
            }

            return result;
        }
    // Q5. Longest Subarray Zero Sum
        /*
        Q.5 -> Given an array A of N integers.
        Find the length of the longest subarray in the array which sums to zero.
        If there is no subarray which sums to zero then return 0.

        Note :
            

        Problem Constraints
            1 <= N <= 10^5
            -10^9 <= A[i] <= 10^9

        Input Format
            Single argument which is an integer array A.   

        Output Format
            Return an integer.

        Input 1:
            A = [1, -2, 1, 2]

        Output 1:
            3

        Input 2:
            A = [3, 2, -1]

        Output 2:
            0

        */

        // CODE
        int Solution::solve(vector<int> &A) {
            unordered_map<long, int> prefixSumMap;
            int maxLength = 0;
            long prefixSum = 0;

            for (int i = 0; i < A.size(); i++) {
                prefixSum += A[i];

                // If the prefix sum is zero, the subarray from the start to the current index has a sum of zero
                if (prefixSum == 0) {
                    maxLength = i + 1;
                }

                // If the prefix sum has been seen before, it means there is a subarray with sum zero
                if (prefixSumMap.count(prefixSum)) {
                    maxLength = max(maxLength, i - prefixSumMap[prefixSum]);
                } else {
                    // Store the first occurrence of the prefix sum
                    prefixSumMap[prefixSum] = i;
                }
            }

            return maxLength;
        }
    // Q1. Count Pair Sum
        /*
        Q.1 -> You are given an array A of N integers and an integer B. Count the number of pairs (i,j) such that A[i] + A[j] = B and i  j.
        Since the answer can be very large, return the remainder after dividing the count with 10^9+7.

        Note : The pair (i,j) is same as the pair (j,i) and we need to count it only once
            

        Problem Constraints
            1 <= N <= 10^5
            1 <= A[i] <= 10^9
            1 <= B <= 10^9

        Input Format
            First argument A is an array of integers and second argument B is an integer.

        Output Format
            Return an integer.

        Input 1:
            A = [3, 5, 1, 2]
            B = 8

        Output 1:
            1

        Input 2:
            A = [1, 2, 1, 2]
            B = 3

        Output 2:
            4

        */

        // CODE
        int Solution::solve(vector<int> &A, int B) {

            const int MOD = 1000000007;
            unordered_map<int, int> freq;
            long long count = 0;

            for (int num : A) {
                // Check if the complement (B - num) exists in the map
                if (freq.count(B - num)) {
                    count = (count + freq[B - num]) % MOD;
                }
                // Increment the frequency of the current number
                freq[num]++;
            }

            return count;
        }
    // Q2. Subarray with given sum
        /*
        Q.2 -> Given an array of positive integers A and an integer B, find and return first continuous subarray which adds to B.
        If the answer does not exist return an array with a single integer "-1".
        First sub-array means the sub-array for which starting index in minimum.

        Note :
            

        Problem Constraints
            1 <= length of the array <= 100000
            1 <= A[i] <= 10^9
            1 <= B <= 10^9

        Input Format
            The first argument given is the integer array A.
            The second argument given is integer B.   

        Output Format
            Return the first continuous sub-array which adds to B and if the answer does not exist return an array with a single integer "-1".

        Input 1:
            A = [1, 2, 3, 4, 5]
            B = 5

        Output 1:
            [2, 3]

        Input 2:
            A = [5, 10, 20, 100, 105]
            B = 110

        Output 2:
            [-1]

        */

        // CODE
        vector<int> Solution::solve(vector<int> &A, int B) {
            int n = A.size();
            int left = 0, right = 0;
            long long currentSum = 0;

            while (right < n) {
                currentSum += A[right];
                while (currentSum > B && left <= right) {
                    currentSum -= A[left];
                    left++;
                }
                if (currentSum == B) {
                    return vector<int>(A.begin() + left, A.begin() + right + 1);
                }
                right++;
            }

            return vector<int>(1, -1);
        }

## Internal Implementation & Problems ##
    // Q1. Longest Increasing Subsequence
        /*
        Q.1 -> Find the longest increasing subsequence of a given array of integers, A.
        In other words, find a subsequence of array in which the subsequence's elements are in strictly increasing order, and in which the subsequence is as long as possible.
        In this case, return the length of the longest increasing subsequence.

        Note :
            

        Problem Constraints
            1 <= length(A) <= 2500
            0 <= A[i] <= 2500

        Input Format
        The first and the only argument is an integer array A. 

        Output Format
            Return an integer representing the length of the longest increasing subsequence.

        Input 1:
            A = [1, 2, 1, 5]

        Output 1:
            3

        Input 2:
            A = [0, 8, 4, 12, 2, 10, 6, 14, 1, 9, 5, 13, 3, 11, 7, 15]

        Output 2:
            6

        */

        // CODE
        int Solution::lis(const vector<int> &A) {
            if (A.empty()) return 0;

            int n = A.size();
            vector<int> dp(n, 1);  // dp[i] stores the length of the LIS ending at index i

            // Compute the length of the LIS for every element
            for (int i = 1; i < n; i++) {
                for (int j = 0; j < i; j++) {
                    if (A[i] > A[j]) {
                        dp[i] = max(dp[i], dp[j] + 1);
                    }
                }
            }

            // The result is the maximum value in the dp array
            return *max_element(dp.begin(), dp.end());
        }
    // Q2. Longest Subarray Zero Sum
        /*
        Q.2 -> Given an array A of N integers.
        Find the length of the longest subarray in the array which sums to zero.
        If there is no subarray which sums to zero then return 0.

        Note :
            

        Problem Constraints
            1 <= N <= 10^5
            -10^9 <= A[i] <= 10^9   

        Input Format
            Single argument which is an integer array A.

        Output Format
            Return an integer.

        Input 1:
            A = [1, -2, 1, 2]

        Output 1:
            3

        Input 2:
            A = [3, 2, -1]

        Output 2:
            0

        */

        // CODE
        int Solution::solve(vector<int> &A) {
            int max_len = 0; // To store the maximum length of the subarray
            unordered_map<long long, int> hm; // HashMap to store cumulative sums and their first indices
            long long sum = 0; // Cumulative sum

            for (int i = 0; i < A.size(); i++) {
                sum += A[i]; // Update cumulative sum
                
                if (sum == 0) { // If cumulative sum is zero, update max_len
                    max_len = i + 1; // Subarray from index 0 to i
                } else if (hm.find(sum) != hm.end()) { // If sum is already in the map
                    max_len = max(max_len, i - hm[sum]); // Update max_len if we found a longer subarray
                } else { // If it's the first time we see this sum
                    hm[sum] = i; // Store the index of this sum
                }
            }
            
            return max_len; // Return the maximum length found
        }
    // Q1. Colorful Number
        /*
        Q.1 -> Given a number A, find if it is COLORFUL number or not.
        If number A is a COLORFUL number return 1 else, return 0.
        What is a COLORFUL Number:
        A number can be broken into different consecutive sequence of digits. 
        The number 3245 can be broken into sequences like 3, 2, 4, 5, 32, 24, 45, 324, 245 and 3245. 
        This number is a COLORFUL number, since the product of every consecutive sequence of digits is different

        Note :
            

        Problem Constraints
            1 <= A <= 2 * 10^9

        Input Format
            The first and only argument is an integer A.

        Output Format
            Return 1 if integer A is COLORFUL else return 0.

        Input 1:
            A = 23

        Output 1:
            1

        Input 2:
            A = 236

        Output 2:
            0

        */

        // CODE
        int Solution::colorful(int A) {
            string num = to_string(A);
            unordered_set<long long> productSet;

            // Iterate through all possible subsequences of the number
            for (int i = 0; i < num.size(); i++) {
                long long product = 1;
                
                // Compute the product for subsequences starting from index 'i'
                for (int j = i; j < num.size(); j++) {
                    product *= (num[j] - '0');
                    
                    // If the product has already been seen, it's not a colorful number
                    if (productSet.find(product) != productSet.end()) {
                        return 0;  // Not colorful
                    }
                    
                    // Store the product in the set
                    productSet.insert(product);
                }
            }
            
            return 1;  // The number is colorful
        }
    // Q2. Count Subarrays
        /*
        Q.2 -> Misha likes finding all Subarrays of an Array. Now she gives you an array A of N elements and told you to find the number of subarrays of A, that have unique elements.
        Since the number of subarrays could be large, return value % 109 +7.

        Note :
            

        Problem Constraints
            1 <= N <= 10^5
            1 <= A[i] <= 10^6   

        Input Format
            The only argument given is an Array A, having N integers.

        Output Format
            Return the number of subarrays of A, that have unique elements.

        Input 1:
            A = [1, 1, 3]
                
        Output 1:
            4

        Input 2:
            A = [2, 1, 2]

        Output 2:
            5

        */

        // CODE
        const int MOD = 1e9 + 7;

        int Solution::solve(vector<int> &A) {
            int n = A.size();
            unordered_set<int> window;
            int l = 0, result = 0;
            
            for (int r = 0; r < n; r++) {
                // If the element is already in the window, shrink the window from the left
                while (window.find(A[r]) != window.end()) {
                    window.erase(A[l]);
                    l++;
                }
                
                // Add the current element to the window
                window.insert(A[r]);
                
                // The number of unique subarrays ending at r is (r - l + 1)
                result = (result + (r - l + 1)) % MOD;
            }
            
            return result;
        }
    // Q3. Sort Array in given Order
        /*
        Q.3 -> Given two arrays of integers A and B, Sort A in such a way that the relative order among the elements will be the same as those are in B.
        For the elements not present in B, append them at last in sorted order.
        Return the array A after sorting from the above method.

        NOTE: Elements of B are unique.

        Problem Constraints
            1 <= length of the array A <= 100000
            1 <= length of the array B <= 100000
            -10^9 <= A[i] <= 10^9   

        Input Format
            The first argument given is the integer array A.
            The second argument given is the integer array B    

        Output Format
            Return the array A after sorting as described.

        Input 1:
            A = [1, 2, 3, 4, 5, 4]
            B = [5, 4, 2]

        Output 1:
            [5, 4, 4, 2, 1, 3]

        Input 2:
            A = [5, 17, 100, 11]
            B = [1, 100]

        Output 2:
            [100, 5, 11, 17]

        */

        // CODE
        vector<int> Solution::solve(vector<int> &A, vector<int> &B) {
            unordered_map<int, int> freqMap;
            
            // Step 1: Create frequency map for A
            for (int num : A) {
                freqMap[num]++;
            }
            
            vector<int> result;
            
            // Step 2: Add elements from B to result in the same order
            for (int num : B) {
                if (freqMap.find(num) != freqMap.end()) {
                    int count = freqMap[num];
                    result.insert(result.end(), count, num);
                    freqMap.erase(num);  // Remove processed elements
                }
            }
            
            // Step 3: Collect remaining elements and sort them
            vector<int> remainingElements;
            for (auto& entry : freqMap) {
                int count = entry.second;
                remainingElements.insert(remainingElements.end(), count, entry.first);
            }
            
            sort(remainingElements.begin(), remainingElements.end());
            
            // Step 4: Append sorted remaining elements to result
            result.insert(result.end(), remainingElements.begin(), remainingElements.end());
            
            return result;
        }

// OOPS
## Introduction ##
## Constructor, Inheritance & Polymorphism ##
## OOPS EXTRA ##
    // Class
        class Car {
        public:
            string brand;
            int speed;

            void display() {
                cout << "Brand: " << brand << ", Speed: " << speed << " km/h" << endl;
            }
        };
        int main() {
            Car car1;
            car1.brand = "Toyota";
            car1.speed = 120;
            car1.display();
            return 0;
        }
    // Getter and Setter
        void setName(string n) {
            name = n; // Update the private attribute
        }

        // Setter for age with validation
        void setAge(int a) {
            if (a >= 0) { // Ensure age is non-negative
                age = a;
            } else {
                cout << "Invalid age!\n";
            }
        }
        // Getter for name
        string getName() {
            return name; // Return the private attribute
        }

        // Getter for age
        int getAge() {
            return age;
        }
        
        // Set values using setters
        p.setName("John");
        p.setAge(25);

        // Get values using getters
        cout << "Name: " << p.getName() << endl;
        cout << "Age: " << p.getAge() << endl;
    // Constructor
        // Default Constructor
        Person() {
            name = "Unknown";
            age = 0;
            cout << "Default Constructor called.\n";
        }
        Person p; // Default constructor is called

        // Parameterized Constructor
        Person(string n, int a) {
            name = n;
            age = a;
            cout << "Parameterized Constructor called.\n";
        }
        Person p("John", 25); // Parameterized constructor is called

        // Copy Constructor
        Person(const Person& p) {
            name = p.name;
            age = p.age;
            cout << "Copy Constructor called.\n";
        }

        Person p1("Alice", 30); // Parameterized constructor
        Person p2 = p1;         // Copy constructor is called
        p2.display();
    // Destructor
        // Destructor
        ~Person() {
            cout << "Destructor called for " << name << ".\n";
        }
    // Static and Dynamic allocation for Objects
        Person p1("John", 30); // Static allocation on the stack
        Person* p2 = new Person("Alice", 25); // Dynamic allocation on the heap
        // Explicitly delete the dynamically allocated object
        delete p2; // Destructor is called
    // Shallow Copy
        // Constructor
        Shallow(int value) {
            data = new int(value);
            cout << "Constructor called.\n";
        }

        // Copy Constructor (Shallow Copy)
        Shallow(const Shallow& obj) {
            data = obj.data; // Copy the pointer
            cout << "Shallow Copy Constructor called.\n";
        }
        Shallow obj1(42); // Constructor
        Shallow obj2 = obj1; // Shallow Copy Constructor
    // Deep Copy
        // Constructor
        Deep(int value) {
            data = new int(value);
            cout << "Constructor called.\n";
        }

        // Copy Constructor (Deep Copy)
        Deep(const Deep& obj) {
            data = new int(*obj.data); // Create a new memory allocation and copy the value
            cout << "Deep Copy Constructor called.\n";
        }

        Deep obj1(42); // Constructor
        Deep obj2 = obj1; // Deep Copy Constructor
    // Copy Assignment Operator
        Person p1("John");      // Constructor
        p1.display();

        Person p2("Alice");     // Constructor
        p2.display();

        p2 = p1;                // Copy Assignment
        p2.display();
    // Static Variable
        void counterFunction() {
            static int count = 0;  // Static variable
            count++;               // Increment each time the function is called
            cout << "Count: " << count << endl;
        }

        int main() {
            counterFunction();  // Count: 1
            counterFunction();  // Count: 2
            counterFunction();  // Count: 3
            return 0;
        }
    // Static Member Variables (in Classes)
        class MyClass {
            public:
                static int count;  // Static member variable

                MyClass() {
                    count++;
                }

                static void showCount() {
                    cout << "Count: " << count << endl;
                }
            };

            // Definition of the static member variable outside the class
            int MyClass::count = 0;

            int main() {
                MyClass obj1;
                MyClass obj2;

                MyClass::showCount();  // Accessing static method without an object
                return 0;
            }
    // Static Member Functions (in Classes)
        class MyClass {
        private:
            static int count;  // Static member variable

            public:
                MyClass() {
                    count++;  // Increment count for each object created
                }

                // Static member function
                static void showCount() {
                    cout << "Count: " << count << endl;
                }
            };

            // Definition of the static member variable
            int MyClass::count = 0;

            int main() {
                MyClass obj1;
                MyClass obj2;

                // Static function called directly from the class
                MyClass::showCount();  // Output: Count: 2

                return 0;
            }
    // Static Function (Global Scope)
        static void myFunction() {  // Static function in global scope
            cout << "This function can only be called in this file." << endl;
        }

        int main() {
            myFunction();  // Function call within the same file
            return 0;
        }
    // Abstraction
        // Abstract base class
        class Shape {
        public:
            // Pure virtual function (abstract function)
            virtual void draw() = 0;

            // A regular function
            void showInfo() {
                cout << "I am a shape." << endl;
            }

            // Virtual destructor for proper cleanup of derived objects
            virtual ~Shape() {
                cout << "Shape destroyed" << endl;
            }
        };

        // Derived class Rectangle
        class Rectangle : public Shape {
        public:
            // Implementing the abstract method
            void draw() override {
                cout << "Drawing a rectangle" << endl;
            }
        };

        // Derived class Circle
        class Circle : public Shape {
        public:
            // Implementing the abstract method
            void draw() override {
                cout << "Drawing a circle" << endl;
            }
        };

        int main() {
            // We cannot instantiate an abstract class
            // Shape s; // This will give an error

            // Create an object of Rectangle and Circle
            Shape* shape1 = new Rectangle();
            Shape* shape2 = new Circle();

            // Call the draw method (Polymorphism)
            shape1->draw();
            shape2->draw();

            // Call the common function
            shape1->showInfo();
            shape2->showInfo();

            // Clean up
            delete shape1;
            delete shape2;

            return 0;
        }
    // Single Inheritance
        // Base class
        class Vehicle {
        public:
            // Base class property
            string brand;

            // Base class method
            void honk() {
                cout << "Vehicle horn: Beep Beep!" << endl;
            }
        };

        // Derived class
        class Car : public Vehicle {
        public:
            // Derived class method
            void displayBrand() {
                cout << "Car brand: " << brand << endl;
            }
        };
    // Multilevel Inheritance
        // Base class
        class Animal {
        public:
            void eat() {
                cout << "Eating food..." << endl;
            }

            void sleep() {
                cout << "Sleeping..." << endl;
            }
        };

        // Derived class 1 (inherits from Animal)
        class Mammal : public Animal {
        public:
            void breathe() {
                cout << "Breathing air..." << endl;
            }
        };

        // Derived class 2 (inherits from Mammal)
        class Dog : public Mammal {
        public:
            void bark() {
                cout << "Barking..." << endl;
            }
        }
    // Multiple  Inheritance
        // Base class 1
        class Vehicle {
        public:
            void drive() {
                cout << "Driving the vehicle..." << endl;
            }
        };

        // Base class 2
        class Engine {
        public:
            void start() {
                cout << "Starting the engine..." << endl;
            }
        };

        // Derived class that inherits from both Vehicle and Engine
        class Car : public Vehicle, public Engine {
        public:
            void honk() {
                cout << "Car horn: Beep Beep!" << endl;
            }
        };
    // Hierarchical  Inheritance
        class Shape {
            public:
                void display() {
                    cout << "Displaying shape..." << endl;
                }
            };

            // Derived class 1
            class Circle : public Shape {
            public:
                void drawCircle() {
                    cout << "Drawing circle..." << endl;
                }
            };

            // Derived class 2
            class Rectangle : public Shape {
            public:
                void drawRectangle() {
                    cout << "Drawing rectangle..." << endl;
                }
            };
    // Hybrid  Inheritance
        // Base class 1
        class Animal {
        public:
            void breathe() {
                cout << "Animal is breathing" << endl;
            }
        };

        // Derived class 1
        class Mammal : public Animal {
        public:
            void walk() {
                cout << "Mammal is walking" << endl;
            }
        };

        // Derived class 2
        class Bird : public Animal {
        public:
            void fly() {
                cout << "Bird is flying" << endl;
            }
        };

        // Derived class 3 (Hybrid inheritance)
        class Bat : public Mammal, public Bird {
        public:
            void hangUpsideDown() {
                cout << "Bat is hanging upside down" << endl;
            }
        };

    // Diamond Problem
        class A {
        public:
            void show() {
                cout << "Class A" << endl;
            }
        };

        class B : public A {
        public:
            void show() {
                cout << "Class B" << endl;
            }
        };

        class C : public A {
        public:
            void show() {
                cout << "Class C" << endl;
            }
        };

        // Class D inherits from both B and C, leading to ambiguity
        class D : public B, public C {
            // This will cause ambiguity for the method show()
        };
    // Function Overloading
    // Operator Overloading
    // Method overrriding

---------------------------------------------------------------------------------------------------------------
//######################
//## UNIT 3 ##
//###################### 
---------------------------------------------------------------------------------------------------------------
// SORTING
## Sorting Basics ## 
    // Find the Minimum Cost to remove all elements from the array
        std::sort(A.begin(), A.end(), std::greater<int>());
        int cost = 0;
        for (int i = 0; i < A.size(); i++) {
            cost += A[i] * (i+1);
        }
    // Noble Integers
    // Noble Integers with duplicates
        std::sort(A.begin(), A.end(), std::greater<int>());
        int cnt = 0;
        for (int i = 0; i < A.size(); i++) {
            if(i==0 || A[i] != A[i-1]){
                cnt = i;
            }

            if (cnt == A[i]){
                return 1;
            }
        }
        return -1;
    // Selection Sort
        for (int i = 0; i < n - 1; i++) {
            int minIndex = i;
            for (int j = i + 1; j < n; j++) {
                if (arr[j] < arr[minIndex]) {
                    minIndex = j;
                }
            }
            if (minIndex != i) {
                swap(arr[i], arr[minIndex]);
            }
        }
    // Bubble Sort
        bool swapped;
        for (int i = 0; i < n - 1; i++) {
            swapped = false;
            for (int j = 0; j < n - i - 1; j++) {
                if (arr[j] > arr[j + 1]) {
                    swap(arr[j], arr[j + 1]);
                    swapped = true;
                }
            }
            //If no elements are swapped during a pass through the array, it means the array is already sorted.
            if (!swapped) {
                break;
            }
        }
    // Insertion Sort
        for (int i = 1; i < n; i++) {
            int key = arr[i];  // The element to be inserted in sorted part of the array
            int j = i - 1;

            while (j >= 0 && arr[j] > key) {
                arr[j + 1] = arr[j];  // Shift the element to the right
                j = j - 1;
            }
            arr[j + 1] = key;  // Place the key in its correct position
        }
    // Sort 
        // sorting in descending order 54321
        std::sort(A.begin(), A.end(), std::greater<int>());
        // sorting in ascending order 12345
        std::sort(A.begin(), A.end());
    // Q1. Elements Removal
        /*
        Q.1 -> Given an integer array A of size N. You can remove any element from the array in one operation.
        The cost of this operation is the sum of all elements in the array present before this operation.
        Find the minimum cost to remove all elements from the array.

        Note :
            

        Problem Constraints
            0 <= N <= 1000
            1 <= A[i] <= 10^3 

        Input Format
            First and only argument is an integer array A.

        Output Format
            Return an integer denoting the total cost of removing all elements from the array.

        Input 1:
            A = [2, 1]

        Output 1:
            4

        Input 2:
            A = [5]

        Output 2:
            5

        */

        // CODE
        int Solution::solve(vector<int> &A) {
            std::sort(A.begin(), A.end(), std::greater<int>());
            int cost = 0;
            for (int i = 0; i < A.size(); i++) {
                cost += A[i] * (i+1);
            }

            return cost;
        }
    // Q2. Noble Integer
        /*
        Q.2 -> Given an integer array A, find if an integer p exists in the array such that the number of integers greater than p in the array equals p.

        Note :
            

        Problem Constraints
            1 <= |A| <= 2*10^5
            -108 <= A[i] <= 10^8

        Input Format
            First and only argument is an integer array A.

        Output Format
            Return 1 if any such integer p is present else, return -1.

        Input 1:
            A = [3, 2, 1, 3]

        Output 1:
            1

        Input 2:
            A = [1, 1, 3, 3]

        Output 2:
            -1

        */

        // CODE
        int Solution::solve(vector<int> &A) {

            std::sort(A.begin(), A.end(), std::greater<int>());
            int cnt = 0;
            for (int i = 0; i < A.size(); i++) {
                if(i==0 || A[i] != A[i-1]){
                    cnt = i;
                }

                if (cnt == A[i]){
                    return 1;
                }
            }
            return -1;
        }
    // Q3. Kth Smallest Element
        /*
        Q.3 ->Find the Bth smallest element in given array A .

        NOTE: 
            Users should try to solve it in less than equal to B swaps. 
            

        Problem Constraints
            1 <= |A| <= 100000
            1 <= B <= min(|A|, 500)
            1 <= A[i] <= 10^9

        Input Format
            The first argument is an integer array A.
            The second argument is integer B.   

        Output Format
            Return the Bth smallest element in given array.

        Input 1:
            A = [2, 1, 4, 3, 2]
            B = 3


        Output 1:
            2

        Input 2:
            A = [1, 2]
            B = 2

        Output 2:
            2

        */

        // CODE
        int Solution::kthsmallest(const vector<int> &A, int B) {


            std::vector<int> vec = A;

            for (int i = 0; i < B; ++i) {
                int m = i;
                for (int j = i + 1; j < vec.size(); ++j) {
                    if (vec[j] < vec[m]) {
                        m = j;
                    }
                }
                // Swap
                std::swap(vec[i], vec[m]);
            }

            return vec[B - 1];
        }
    // Q1. Arithmetic Progression?
        /*
        Q.1 -> Given an integer array A of size N. Return 1 if the array can be arranged to form an arithmetic progression, otherwise return 0.
        A sequence of numbers is called an arithmetic progression if the difference between any two consecutive elements is the same.

        Note :
            

        Problem Constraints
            2 <= N <= 10^5
            -109 <= A[i] <= 10^9

        Input Format
            The first and only argument is an integer array A of size N.

        Output Format
            Return 1 if the array can be rearranged to form an arithmetic progression, otherwise return 0.

        Input 1:
            A = [3, 5, 1]

        Output 1:
            1

        Input 2:
            A = [2, 4, 1]

        Output 2:
            0

        */

        // CODE
        int Solution::solve(vector<int> &A) {

            std::sort(A.begin(), A.end(), std::greater<int>());
            int cost = 0;
            int d = A[1] - A[0];
            for (int i = 0; i < A.size()-1; i++) {
                if((A[i+1] - A[i]) != d){
                    return 0;
                }
            }

            return 1;
        }

## Count Sort & Merge Sort ##
    // count sort
        // Find the minimum and maximum values in the array
        int max_val = *max_element(arr.begin(), arr.end());
        int min_val = *min_element(arr.begin(), arr.end());
        // Calculate the range of numbers in the array
        int range = max_val - min_val + 1;
        // Create a count array of size equal to the range
        vector<int> count(range, 0);
        // Count the occurrences of each element in the original array
        for (int i = 0; i < n; i++) {
            count[arr[i] - min_val]++;  // Shift by 'min_val' to account for negative values
        }
        // Modify the original array using the count array
        int index = 0;
        for (int i = 0; i < range; i++) {
            while (count[i]--) {
                arr[index++] = i + min_val;  // Shift back by 'min_val'
            }
        }
    // Merge two sorted arrays into a single sorted Array
        int N = A.size();
        int M = B.size();

        vector<int> C(N+M, 0);

        int i=0,j=0,k=0;

        while(i<N  &&  j<M){
            if(A[i] <= B[j]){
                C[k] = A[i];
                i++;
                k++;
            }else{
                C[k] = B[j];
                j++;
                k++;
            }
        }

        while(i<N){
            C[k] = A[i];
            i++;
            k++;
        }
        while(j<M){
            C[k] = B[j];
            j++;
            k++;
        }
    // merge sort
        vector<int> mergeSort(const vector<int>& arr) {
            // Base case: if the array is empty or contains a single element, return it
            if (arr.size() <= 1) {
                return arr;
            }

            // Find the midpoint of the array
            int mid = arr.size() / 2;

            // Recursively sort the left half and the right half
            vector<int> left = mergeSort(vector<int>(arr.begin(), arr.begin() + mid));
            vector<int> right = mergeSort(vector<int>(arr.begin() + mid, arr.end()));

            // Merge the sorted halves
            return mergeSortedArrays(left, right);
        }
    // Inversion Count
        static const int MOD = 1e9 + 7;
        int mergeAndCount(vector<int>& A, int s, int mid, int e) {
            int len1 = mid - s + 1;
            int len2 = e - mid;
            
            vector<int> left(len1), right(len2);

            for (int i = 0; i < len1; ++i) {
                left[i] = A[s + i];
            }
            for (int i = 0; i < len2; ++i) {
                right[i] = A[mid + 1 + i];
            }

            int i = 0, j = 0, k = s, invCount = 0;
            
            while (i < len1 && j < len2) {
                if (left[i] <= right[j]) {
                    A[k++] = left[i++];
                } else {
                    A[k++] = right[j++];
                    invCount = (invCount + (len1 - i)) % MOD;
                }
            }

            while (i < len1) {
                A[k++] = left[i++];
            }

            while (j < len2) {
                A[k++] = right[j++];
            }

            return invCount;
        }

        int mergeSortAndCount(vector<int>& A, int s, int e) {

            // base case
            if (s >= e) {
                return 0;
            }

            int mid = s + (e - s) / 2;
            int invCount = 0;
            
            // sort and count left part
            invCount = (invCount + mergeSortAndCount(A, s, mid)) % MOD;
            // sort and count right part
            invCount = (invCount + mergeSortAndCount(A, mid + 1, e)) % MOD;
            // merge two part and coutn
            invCount = (invCount + mergeAndCount(A, s, mid, e)) % MOD;

            return invCount;
        }
    // Q1. Merge Two Sorted Arrays
        /*
        Q.1 -> Given two sorted integer arrays A and B, merge B and A as one sorted array and return it as an output.

        Note: A linear time complexity is expected and you should avoid use of any library function.

        Problem Constraints
            -210^9 <= A[i], B[i] <= 210^9
            1 <= |A|, |B| <= 510^4

        Input Format
            First Argument is a 1-D array representing  A.
            Second Argument is also a 1-D array representing B.

        Output Format
            Return a 1-D vector which you got after merging A and B.

        Input 1:
            A = [4, 7, 9]
            B = [2, 11, 19]

        Output 1:
            [2, 4, 7, 9, 11, 19]

        Input 2:
            A = [1]
            B = [2]

        Output 2:
            [1, 2]

        */

        // CODE
        vector<int> Solution::solve(const vector<int> &A, const vector<int> &B) {

            int N = A.size();
            int M = B.size();

            vector<int> C(N+M);

            int i=0,j=0,k=0;

            while(i<N  &&  j<M){
                if(A[i] <= B[j]){
                    C[k] = A[i];
                    i++;
                    k++;
                }else{
                    C[k] = B[j];
                    j++;
                    k++;
                }
            }

            while(i<N){
                C[k] = A[i];
                i++;
                k++;
            }
            while(j<M){
                C[k] = B[j];
                j++;
                k++;
            }

            return C;
        }
    // Q2. Inversion count in an array
        /*
        Q.2 -> Given an array of integers A. If i < j and A[i] > A[j], then the pair (i, j) is called an inversion of A. Find the total number of inversions of A modulo (10^9 + 7).

        Note :
            

        Problem Constraints
            1 <= length of the array <= 10^5
            1 <= A[i] <= 10^9

        Input Format
            The only argument given is the integer array A.

        Output Format
            Return the number of inversions of A modulo (10^9 + 7).

        Input 1:
            A = [1, 3, 2]

        Output 1:
            1

        Input 2:
            A = [3, 4, 1, 2]

        Output 2:
            4

        */

        // CODE
        static const int MOD = 1e9 + 7;

        int mergeAndCount(vector<int>& A, int s, int mid, int e) {
            int len1 = mid - s + 1;
            int len2 = e - mid;
            
            vector<int> left(len1), right(len2);

            for (int i = 0; i < len1; ++i) {
                left[i] = A[s + i];
            }
            for (int i = 0; i < len2; ++i) {
                right[i] = A[mid + 1 + i];
            }

            int i = 0, j = 0, k = s, invCount = 0;
            
            while (i < len1 && j < len2) {
                if (left[i] <= right[j]) {
                    A[k++] = left[i++];
                } else {
                    A[k++] = right[j++];
                    invCount = (invCount + (len1 - i)) % MOD;
                }
            }

            while (i < len1) {
                A[k++] = left[i++];
            }

            while (j < len2) {
                A[k++] = right[j++];
            }

            return invCount;
        }
        int mergeSortAndCount(vector<int>& A, int s, int e) {

            // base case
            if (s >= e) {
                return 0;
            }

            int mid = s + (e - s) / 2;
            int invCount = 0;
            
            // sort and count left part
            invCount = (invCount + mergeSortAndCount(A, s, mid)) % MOD;
            // sort and count right part
            invCount = (invCount + mergeSortAndCount(A, mid + 1, e)) % MOD;
            // merge two part and coutn
            invCount = (invCount + mergeAndCount(A, s, mid, e)) % MOD;

            return invCount;
        }

        int Solution::solve(vector<int> &A) {

            return mergeSortAndCount(A, 0, A.size() - 1);
        }
    // Q3. Count Sort
        /*

        Q.3 -> Given an array A. Sort this array using Count Sort Algorithm and return the sorted array.


        Note :
            

        Problem Constraints
            1 <= |A| <= 10^5
            1 <= A[i] <= 10^5

        Input Format
            The first argument is an integer array A.

        Output Format
            Return an integer array that is the sorted array A.

        Input 1:
            A = [1, 3, 1]

        Output 1:
            [1, 1, 3]

        Input 2:
            A = [4, 2, 1, 3]

        Output 2:
            [1, 2, 3, 4]

        */

        // CODE
        vector<int> Solution::solve(vector<int> &A) {

            // Handle edge case if the input vector is empty
            if (A.empty()) {
                return A;
            }
            
            // Find the minimum and maximum values to know the range of keys
            int minVal = *std::min_element(A.begin(), A.end());
            int maxVal = *std::max_element(A.begin(), A.end());
            
            // Initialize count array
            int range = maxVal - minVal + 1;
            std::vector<int> countArr(range, 0);
            
            // Store the count of each element in count array
            for (int num : A) {
                countArr[num - minVal]++;
            }
            
            // Modify count array by adding previous counts (prefix sums)
            for (int i = 1; i < range; ++i) {
                countArr[i] += countArr[i - 1];
            }
            
            // Build the output array
            std::vector<int> outputArr(A.size());
            for (int i = A.size() - 1; i >= 0; --i) {
                outputArr[countArr[A[i] - minVal] - 1] = A[i];
                countArr[A[i] - minVal]--;
            }
            
            // Return the sorted array
            return outputArr;
        }
    // Q4. Reverse pairs
        /*
        Q.4 -> Given an array of integers A, we call (i, j) an important reverse pair if i < j and A[i] > 2*A[j].
        Return the number of important reverse pairs in the given array A.

        Note :
            

        Problem Constraints
            1 <= length of the array <= 105
            -2 * 109 <= A[i] <= 2 * 109

        Input Format
            The only argument given is the integer array A.  

        Output Format
            Return the number of important reverse pairs in the given array A.

        Input 1:
            A = [1, 3, 2, 3, 1]

        Output 1:
            2

        Input 2:
            A = [4, 1, 2]

        Output 2:
            1

        */

        // CODE

        static const int MOD = 1e9 + 7;

        int mergeAndCount(vector<int>& A, int s, int mid, int e) {
            int len1 = mid - s + 1;
            int len2 = e - mid;
            int count = 0;
            vector<int> left(len1), right(len2);

            for (int i = 0; i < len1; ++i) {
                left[i] = A[s + i];
            }
            for (int i = 0; i < len2; ++i) {
                right[i] = A[mid + 1 + i];
            }

            int jj = mid + 1;
            // Count important reverse pairs
            for (int i = s; i <= mid; ++i) {
                while (jj <= e && A[i] > 2LL * A[jj]) {
                    ++jj;
                }
                count += (jj - (mid + 1));
            }

            int i = 0, j = 0, k = s;
            
            while (i < len1 && j < len2) {
                if (left[i] <= right[j]) {
                    A[k++] = left[i++];
                } else {
                    A[k++] = right[j++];
                }
            }

            while (i < len1) {
                A[k++] = left[i++];
            }

            while (j < len2) {
                A[k++] = right[j++];
            }

            return count;
        }

        int mergeSortAndCount(vector<int>& A, int s, int e) {

            // base case
            if (s >= e) {
                return 0;
            }

            int mid = s + (e - s) / 2;
            int invCount = 0;
            
            // sort and count left part
            invCount = (invCount + mergeSortAndCount(A, s, mid)) % MOD;
            // sort and count right part
            invCount = (invCount + mergeSortAndCount(A, mid + 1, e)) % MOD;
            // merge two part and coutn
            invCount = (invCount + mergeAndCount(A, s, mid, e)) % MOD;

            return invCount;
        }

        int Solution::solve(vector<int> &A) {

            return mergeSortAndCount(A, 0, A.size() - 1);
        }
    // Q1. Minimum Absolute Difference
        /*
        Q.1 -> Given an array of integers A, find and return the minimum value of | A [ i ] - A [ j ] | where i != j and |x| denotes the absolute value of x.

        Note :
            
        Problem Constraints
            2 <= length of the array <= 100000
            -109 <= A[i] <= 109

        Input Format
            The only argument given is the integer array A.   

        Output Format
            Return the minimum value of | A[i] - A[j] |.

        Input 1:
            A = [1, 2, 3, 4, 5]

        Output 1:
            1

        Input 2:
            A = [5, 17, 100, 11]

        Output 2:
            6

        */

        // CODE
        int Solution::solve(vector<int> &A) {
            // Ensure the input array has at least two elements
            if (A.size() < 2) {
                return -1; // or throw an exception if this is an invalid input case
            }

            // Sort the array
            std::sort(A.begin(), A.end());

            // Initialize minimum difference to a large value
            int minDiff = INT_MAX;

            // Find the minimum difference between adjacent elements
            for (int i = 1; i < A.size(); ++i) {
                int diff = A[i] - A[i - 1];
                if (diff < minDiff) {
                    minDiff = diff;
                }
            }

            return minDiff;
            
        }
    // Q2. Max Chunks To Make Sorted
        /*
        Q.2 -> Given an array of integers A of size N that is a permutation of [0, 1, 2, ..., (N-1)], if we split the array into some number of "chunks" (partitions), and individually sort each chunk. After concatenating them in order of splitting, the result equals the sorted array.
        What is the most number of chunks we could have made?

        Note :
            

        Problem Constraints
            1 <= N <= 100000
            0 <= A[i] < N

        Input Format
            The only argument given is the integer array A.   

        Output Format
            Return the maximum number of chunks that we could have made.

        Input 1:
            A = [1, 2, 3, 4, 0]

        Output 1:
            1

        Input 2:
            A = [2, 0, 1, 3]

        Output 2:
            2

        */

        // CODE
        int Solution::solve(vector<int> &A) {
            int N = A.size();
            int maxValue = -1;
            int chunks = 0;

            for (int i = 0; i < N; ++i) {
                // Update the maximum value encountered so far
                maxValue = max(maxValue, A[i]);
                
                // Check if current maxValue equals the current index
                if (maxValue == i) {
                    ++chunks; // We can create a valid chunk up to index i
                }
            }
            
            return chunks;
        }

## Quick Sort & Comparator Problems ##
    // Make last element as pivot. Arrange all elements smaller than pivot to left and greater than pivot to right

        int partition(std::vector<int>& A, int low, int high) {
                int pivot = A[high]; // Choosing the last element as the pivot
                int i = low - 1; // Pointer for the smaller element

                for (int j = low; j < high; j++) {
                    // If the current element is smaller than or equal to the pivot
                    if (A[j] <= pivot) {
                        i++; // Increment the pointer for the smaller element
                        std::swap(A[i], A[j]); // Swap the elements
                    }
                }
                std::swap(A[i + 1], A[high]); // Place the pivot in the correct position
                return i + 1; // Return the index of the pivot
        }
    // quick sort
        // Function to perform the partitioning
        int partition(std::vector<int>& A, int low, int high) {
            int pivot = A[high]; // Choosing the last element as the pivot
            int i = low - 1; // Pointer for the smaller element

            for (int j = low; j < high; j++) {
                // If the current element is smaller than or equal to the pivot
                if (A[j] <= pivot) {
                    i++; // Increment the pointer for the smaller element
                    std::swap(A[i], A[j]); // Swap the elements
                }
            }
            std::swap(A[i + 1], A[high]); // Place the pivot in the correct position
            return i + 1; // Return the index of the pivot
        }

        // The main function for quicksort
        void quickSort(std::vector<int>& A, int low, int high) {
            if (low < high) {
                // Partitioning index
                int pi = partition(A, low, high);

                // Recursively sort elements before and after partition
                quickSort(A, low, pi - 1);
                quickSort(A, pi + 1, high);
            }
        }
    // comparator
        // Custom comparator function
        bool compare(int a, int b) {
            // Extract tens place digit
            int tensA = (a / 10) % 10;
            int tensB = (b / 10) % 10;
            // First, sort by tens place digit in increasing order
            if (tensA != tensB) {
                return tensA < tensB;
            }
            // If tens place digits are the same, sort by value in decreasing order
            return a > b;
        }

        vector<int> Solution::solve(vector<int> &A) {
            // Sort the array using the custom comparator
            sort(A.begin(), A.end(), compare);
            return A;
        }
    // Q1. Factor Sort
        /*
        Q.1 -> You are given an array A of N elements. Sort the given array in increasing order of number of distinct factors of each element, i.e., element having the least number of factors should be the first to be displayed and the number having highest number of factors should be the last one. If 2 elements have same number of factors, then number with less value should come first.

        Note: You cannot use any extra space

        Problem Constraints
            1 <= N <= 10^4
            1 <= A[i] <= 10^4

        Input Format
            First argument A is an array of integers.

        Output Format
            Return an array of integers.

        Input 1:
            A = [6, 8, 9]

        Output 1:
            [9, 6, 8]

        Input 2:
            A = [2, 4, 7]

        Output 2:
            [2, 7, 4]

        */

        // CODE
        // Function to calculate the number of distinct factors
        int countFactors(int n) {
            int count = 0;
            for (int i = 1; i * i <= n; ++i) {
                if (n % i == 0) {
                    if (i * i == n) {
                        ++count;  // Perfect square
                    } else {
                        count += 2;  // Pair of factors
                    }
                }
            }
            return count;
        }

        vector<int> Solution::solve(vector<int> &A) {
            // Custom sort function
            sort(A.begin(), A.end(), [](int a, int b) {
                int factorsA = countFactors(a);
                int factorsB = countFactors(b);
                
                // cout << "Comparing " << a << " (factors: " << factorsA << ") and " << b << " (factors: " << factorsB << ")" << endl;

                if (factorsA == factorsB) {
                    return a < b;  // If same number of factors, sort by value
                }
                return factorsA < factorsB;  // Otherwise, sort by number of factors
            });

            // cout << "Sorted array: ";
            // for (int num : A) {
            //     cout << num << " ";
            // }
            // cout << endl;

            return A;
        }
    // Q2. Largest Number
        /*
        Q.2 -> Given an array A of non-negative integers, arrange them such that they form the largest number.

        Note: The result may be very large, so you need to return a string instead of an integer.

        Problem Constraints
            1 <= len(A) <= 100000
            0 <= A[i] <= 2*109

        Input Format
            The first argument is an array of integers.

        Output Format
            Return a string representing the largest number.

        Input 1:
            A = [3, 30, 34, 5, 9]

        Output 1:
            "9534330"

        Input 2:
            A = [2, 3, 9, 0]

        Output 2:
            "9320"

        */

        // CODE
        // Custom comparator function to sort the numbers in the desired order
        bool compare(const string &a, const string &b) {
            return a + b > b + a;
        }

        string Solution::largestNumber(vector<int> &A) {

            vector<string> strNums;
            strNums.reserve(A.size());

            // Convert each number to a string
            for (int num : A) {
                strNums.push_back(to_string(num));
            }

            // Sort the numbers using the custom comparator
            sort(strNums.begin(), strNums.end(), compare);

            // Concatenate the sorted numbers
            string result;
            for (const string &str : strNums) {
                result += str;
            }

            // Handle the case where the result is a number with leading zeros (e.g., "0000")
            if (result[0] == '0') {
                return "0";
            }

            return result;
            
        }
    // Q3. B Closest Points to Origin
        /*
        Q.3 -> You are developing a feature for Zomato that helps users find the nearest restaurants to their current location. It uses GPS to determine the user's location and has access to a database of restaurants, each with its own set of coordinates in a two-dimensional space representing their geographical location on a map. The goal is to identify the "B" closest restaurants to the user, providing a quick and convenient way to choose where to eat.

        Given a list of restaurant locations, denoted by A (each represented by its x and y coordinates on a map), and an integer B representing the number of closest restaurants to the user. The user's current location is assumed to be at the origin (0, 0).

        Here, the distance between two points on a plane is the Euclidean distance.

        You may return the answer in any order. The answer is guaranteed to be unique (except for the order that it is in.)

        NOTE: Euclidean distance between two points P1(x1, y1) and P2(x2, y2) is sqrt( (x1-x2)2 + (y1-y2)2).

        Problem Constraints
            1 <= B <= length of the list A <= 10^5
            -10^5 <= A[i][0] <= 10^5
            -10^5 <= A[i][1] <= 10^5

        Input Format
            The argument given is list A and an integer B.

        Output Format
            Return the B closest points to the origin (0, 0) in any order.

        Input 1:
            A = [ 
                    [1, 3],
                    [-2, 2] 
                ]
            B = 1

        Output 1:
            [ [-2, 2] ]

        Input 2:
            A = [
                    [1, -1],
                    [2, -1]
                ] 
            B = 1

        Output 2:
            [ [1, -1] ]

        */

        // CODE
        // Function to calculate the squared Euclidean distance
        inline int squaredDistance(int x, int y) {
            return x * x + y * y;
        }

        // Comparator function to sort based on the squared Euclidean distance
        static bool compare(const vector<int>& a, const vector<int>& b) {
            int distA = a[0] * a[0] + a[1] * a[1];
            int distB = b[0] * b[0] + b[1] * b[1];
            return distA < distB;
        }

        vector<vector<int> > Solution::solve(vector<vector<int> > &A, int B) {
            // Sort the array using the custom comparator
            sort(A.begin(), A.end(), compare);

            // Return the first B elements from the sorted array
            return vector<vector<int>>(A.begin(), A.begin() + B);
        }
    // Q4. Sort by Color
        /*
        Q.4 -> Given an array with N objects colored red, white, or blue, sort them so that objects of the same color are adjacent, with the colors in the order red, white, and blue.
        We will represent the colors as,
        red -> 0
        white -> 1
        blue -> 2

        Note : Using the library sort function is not allowed.
            

        Problem Constraints
            1 <= N <= 1000000
            0 <= A[i] <= 2

        Input Format
            First and only argument of input contains an integer array A.

        Output Format
            Return an integer array in asked order

        Input 1:
            A = [0, 1, 2, 0, 1, 2]

        Output 1:
            [0, 0, 1, 1, 2, 2]

        Input 2:
            A = [0]

        Output 2:
            [0]

        */

        // CODE
        vector<int> Solution::sortColors(vector<int> &A) {

            int low = 0, mid = 0, high = A.size() - 1;

            while (mid <= high) {
                if (A[mid] == 0) {
                    swap(A[low], A[mid]);
                    low++;
                    mid++;
                } else if (A[mid] == 1) {
                    mid++;
                } else {
                    swap(A[mid], A[high]);
                    high--;
                }
            }

            return A;
        }
    // Q1. Wave Array
        /*
        Q.1 -> Given an array of integers A, sort the array into a wave-like array and return it.
        In other words, arrange the elements into a sequence such that

        a1 >= a2 <= a3 >= a4 <= a5..... 

        NOTE: If multiple answers are possible, return the lexicographically smallest one.

        Problem Constraints
            1 <= len(A) <= 10^6
            0 <= A[i] <= 10^6

        Input Format
            The first argument is an integer array A.

        Output Format
            Return an array arranged in the sequence as described.

        Input 1:
            A = [1, 2, 3, 4]

        Output 1:
            [2, 1, 4, 3]

        Input 2:
            A = [1, 2]

        Output 2:
            [2, 1]

        */

        // CODE
        vector<int> Solution::wave(vector<int> &A) {

            // Sort the array to prepare for wave-like arrangement
            sort(A.begin(), A.end());

            // Swap every pair of adjacent elements
            for (int i = 0; i < A.size() - 1; i += 2) {
                swap(A[i], A[i + 1]);
            }

            return A;

        }
    // Q2. Tens Digit Sorting
        /*
        Q.2 -> Given an array A of N integers. Sort the array in increasing order of the value at the tens place digit of every number.

        If a number has no tens digit, we can assume value to be 0.
        If 2 numbers have same tens digit, in that case number with max value will come first
        Solution should be based on comparator.

        Note :
            

        Problem Constraints
            1 <= N <= 10^5
            1 <= A[i] <= 10^9

        Input Format
            First argument A is an array of integers.

        Output Format
            Return the array after sorting

        Input 1:
            A = [15, 11, 7, 19]

        Output 1:
            [7, 19, 15, 11]

        Input 2:
            A = [2, 24, 22, 19]

        Output 2:
            [2, 19, 24, 22]

        */

        // CODE

        // Custom comparator function
        bool compare(int a, int b) {
            // Extract tens place digit
            int tensA = (a / 10) % 10;
            int tensB = (b / 10) % 10;

            // First, sort by tens place digit in increasing order
            if (tensA != tensB) {
                return tensA < tensB;
            }

            // If tens place digits are the same, sort by value in decreasing order
            return a > b;
        }

        vector<int> Solution::solve(vector<int> &A) {

            // Sort the array using the custom comparator
            sort(A.begin(), A.end(), compare);

            return A;
        }
## Sorting Extra ##
// Searching
## Types of Search
    // 1. Linear Search
        int linearSearch(int arr[], int n, int target) {
            for (int i = 0; i < n; i++) {
                if (arr[i] == target) {
                    return i; // Return the index if found
                }
            }
            return -1; // Not found
        }
    // 2. Binary Search
        int binarySearch(int arr[], int n, int target) {
            int left = 0, right = n - 1;
            while (left <= right) {
                int mid = left + (right - left) / 2; // To avoid overflow

                if (arr[mid] == target) {
                    return mid; // Return the index if found
                }
                if (arr[mid] < target) {
                    left = mid + 1; // Target is in the right half
                } else {
                    right = mid - 1; // Target is in the left half
                }
            }
            return -1; // Not found
        }
    // 3. Interpolation Search
        int interpolationSearch(int arr[], int n, int target) {
            int left = 0, right = n - 1;

            while (left <= right && target >= arr[left] && target <= arr[right]) {
                if (left == right) {
                    if (arr[left] == target) return left;
                    return -1; // Not found
                }

                // Position formula
                int pos = left + ((double)(right - left) / (arr[right] - arr[left]) * (target - arr[left]));

                if (arr[pos] == target) {
                    return pos; // Found
                }
                if (arr[pos] < target) {
                    left = pos + 1;
                } else {
                    right = pos - 1;
                }
            }
            return -1; // Not found
        }
## Binary Search on Array ##
    // Binary Search on Array
        int N = A.size();
        int L = 0;
        int R = N-1;
        while(L<=R){
            int mid = (L + (R-L)/2);
            if(A[mid] == target){
                return M;
            }else if( A[mid] < target){
                L = mid +1;
            }else{
                R = mid -1;
            }
        }

    // First Occurance of a Number
        int N = A.size();
        int L = 0;
        int R = N-1;
        while(L<=R){
            int mid = (L + (R-L)/2);
            if(A[mid] == target && (A[mid-1] != target || mid == 0)){
                return mid;
            }else if( A[mid] < target){
                L = mid+1;            
            }else{
                R = mid -1;
            }
        }

    // Last Occurance of a Number
        int N = A.size();
        int L = 0;
        int R = N-1;

        while(L<=R){
            int mid = (L + (R-L)/ 2);
            if(A[mid] == target && (mid == N-1 || A[mid+1]!=target)){
                return mid;
            }else if(A[mid] > target){
                R = mid -1;
            }else{
                L= mid +1;
            }
        }

    // Find Unique Element in Unsorted Array
        int N = A.size();
        int L = 0;
        int R = N-1;

        while(L<=R){
            int mid = (L + (R-L)/ 2);
            if((A[mid] != A[mid+1] || mid == N-1) && (A[mid] != A[mid-1] || mid == 0)){
                return A[mid];
            }else if(A[mid] == A[mid+1]){
                if(mid%2 == 0){ 
                    L = mid+1;
                }else{
                    R = mid-1
                }  
            }else{
                if(mid%2 == 0){
                    R = mid - 1;
                }else{
                    L = mid + 1;
                }
            }
        }

    // Find a peak element
        int N = A.size();
        int L = 0;
        int R = N-1;

        while(L<=R){
            int mid = (L + (R-L)/ 2);

            if(
                (A[mid] > A[mid-1] || mid == 0) && 
                (A[mid] > A[mid+1] || mid == N-1)
            ){
                return A[mid];
            }else if(mid < N - 1 && A[mid] < A[mid + 1]){
                L = mid+1;
            }else{
                R = mid -1;
            }
        }

        return A[L];
    // Find Local Minima in an array
        int N = A.size();
        int L = 0;
        int R = N-1;

        while(L<=R){
            int mid = (L + (R-L)/ 2);

            if(
                (A[mid] < A[mid-1] || mid == 0) && 
                (A[mid] < A[mid+1] || mid == N-1)
            ){
                return A[mid];
            }else if(mid < N - 1 && A[mid] < A[mid + 1]){
                L = mid+1;
            }else{
                R = mid -1;
            }
        }

        return A[L];
    // Q1. Sorted Insert Position
        /*
        Q.1 -> You are given a sorted array A of size N and a target value B.
        Your task is to find the index (0-based indexing) of the target value in the array.
        If the target value is present, return its index.
        If the target value is not found, return the index of least element greater than equal to B.
        If the target value is not found and least number greater than equal to target is also not present, return the length of array (i.e. the position where target can be placed)
        Your solution should have a time complexity of O(log(N)).

        Note :
            

        Problem Constraints
            1 <= N <= 105
            1 <= A[i] <= 105
            1 <= B <= 105

        Input Format
            The first argument is an integer array A of size N.
            The second argument is an integer B.

        Output Format
            Return an integer denoting the index of target value.

        Input 1:
            A = [1, 3, 5, 6]
            B = 5 

        Output 1:
            2

        Input 2:
            A = [1, 4, 9]
            B = 3

        Output 2:
            1

        */

        // CODE
        int Solution::searchInsert(vector<int> &A, int B) {

            int left = 0, right = A.size() - 1;
            
            while (left <= right) {
                int mid = left + (right - left) / 2;
                
                if (A[mid] == B) {
                    return mid;
                } else if (A[mid] < B) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }
            
            return left;
        }
    // Q2. Search for a Range
        /*
        Q.2 -> Given a sorted array of integers A (0-indexed) of size N, find the left most and the right most index of a given integer B in the array A.

        Return an array of size 2, such that 
                First element = Left most index of B in A
                Second element = Right most index of B in A.
        If B is not found in A, return [-1, -1].

        Note : Your algorithm's runtime complexity must be in the order of O(log n).

        Problem Constraints
            1 <= N <= 106
            1 <= A[i], B <= 109

        Input Format
            The first argument given is the integer array A.
            The second argument given is the integer B.

        Output Format
            Return the left most and right most index (0-based) of B in A as a 2-element array. If B is not found in A, return [-1, -1].

        Input 1:
            A = [5, 7, 7, 8, 8, 10]
            B = 8

        Output 1:
            [3, 4]

        Input 2:
            A = [5, 17, 100, 111]
            B = 3

        Output 2:
            [-1, -1]

        */

        // CODE
        vector<int> Solution::searchRange(const vector<int> &A, int B) {
            vector<int> result(2, -1);
                int left = 0, right = A.size() - 1;

                // Find leftmost index of B
                while (left <= right) {
                    int mid = left + (right - left) / 2;
                    if (A[mid] == B) {
                        result[0] = mid;
                        right = mid - 1;  // Keep searching in the left half
                    } else if (A[mid] < B) {
                        left = mid + 1;
                    } else {
                        right = mid - 1;
                    }
                }

                left = 0;
                right = A.size() - 1;

                // Find rightmost index of B
                while (left <= right) {
                    int mid = left + (right - left) / 2;
                    if (A[mid] == B) {
                        result[1] = mid;
                        left = mid + 1;  // Keep searching in the right half
                    } else if (A[mid] < B) {
                        left = mid + 1;
                    } else {
                        right = mid - 1;
                    }
                }

                return result;
        }
    // Q3. Find a peak element
        /*
        Q.3 -> Given an array of integers A, find and return the peak element in it.
        An array element is considered a peak if it is not smaller than its neighbors. For corner elements, we need to consider only one neighbor.

        Note :
            It is guaranteed that the array contains only a single peak element.
            Users are expected to solve this in O(log(N)) time. The array may contain duplicate elements.

        Problem Constraints
            1 <= |A| <= 100000
            1 <= A[i] <= 109

        Input Format
            The only argument given is the integer array A.

        Output Format
            Return the peak element.

        Input 1:
            A = [1, 2, 3, 4, 5]

        Output 1:
            5

        Input 2:
            A = [5, 17, 100, 11]

        Output 2:
            100

        */

        // CODE
        int Solution::solve(vector<int> &A) {

            int left = 0, right = A.size() - 1;

            while (left < right) {
                int mid = left + (right - left) / 2;

                if (A[mid] > A[mid + 1]) {
                    // Peak is in the left half (including mid)
                    right = mid;
                } else {
                    // Peak is in the right half (excluding mid)
                    left = mid + 1;
                }
            }

            // Left and right will converge to the peak element
            return A[left];
        }
    // Q4. Single Element in Sorted Array
        /*
        Q.4 -> Given a sorted array of integers A where every element appears twice except for one element which appears once, find and return this single element that appears only once.
        Elements which are appearing twice are adjacent to each other.

        NOTE: Users are expected to solve this in O(log(N)) time.

        Problem Constraints
            1 <= |A| <= 100000
            1 <= A[i] <= 10^9

        Input Format
            The only argument given is the integer array A.  

        Output Format
            Return the single element that appears only once.

        Input 1:
            A = [1, 1, 7]

        Output 1:
            7

        Input 2:
            A = [2, 3, 3]

        Output 2:
            2

        */

        // CODE
        int Solution::solve(vector<int> &A) {
            int N = A.size();
            int L = 0;
            int R = N-1;

            while(L<=R){
                int mid = (L + (R-L)/ 2);
                if((A[mid] != A[mid+1] || mid == N-1) && (A[mid] != A[mid-1] || mid == 0)){
                    return A[mid];
                }else if(A[mid] == A[mid+1]){
                    if(mid%2 == 0){ 
                        L = mid+1;
                    }else{
                        R = mid-1;
                    }  
                }else{
                    if(mid%2 == 0){
                        R = mid - 1;
                    }else{
                        L = mid + 1;
                    }
                }
            }

        }
    // Q5. Matrix Search
        /*
        Q.5 -> Given a matrix of integers A of size N x M and an integer B. Write an efficient algorithm that searches for integer B in matrix A.
        This matrix A has the following properties:
        Integers in each row are sorted from left to right.
        The first integer of each row is greater than or equal to the last integer of the previous row.
        Return 1 if B is present in A, else return 0.

        NOTE: Rows are numbered from top to bottom, and columns are from left to right.

        Problem Constraints
            1 <= N, M <= 1000
            1 <= A[i][j], B <= 10^6

        Input Format
            The first argument given is the integer matrix A.
            The second argument given is the integer B.

        Output Format
            Return 1 if B is present in A else, return 0.

        Input 1:
            A = [ 
                [1,   3,  5,  7]
                [10, 11, 16, 20]
                [23, 30, 34, 50]  
                ]
            B = 3

        Output 1:
            1

        Input 2:
            A = [   
                [5, 17, 100, 111]
                [119, 120, 127, 131]    
                ]
            B = 3

        Output 2:
            0

        */

        // CODE
        int Solution::searchMatrix(vector<vector<int> > &A, int B) {
            int N = A.size();
            if (N == 0) return 0;
            int M = A[0].size();
            if (M == 0) return 0;

            int left = 0, right = N * M - 1;

            while (left <= right) {
                int mid = left + (right - left) / 2;
                int midValue = A[mid / M][mid % M];

                if (midValue == B) {
                    return 1;
                } else if (midValue < B) {
                    left = mid + 1;
                } else {
                    right = mid - 1;
                }
            }

            return 0;
        }
    // Q1. Minimum Difference
        /*
        Q.1 -> You are given a 2-D matrix C of size A  B.
        You need to build a new 1-D array of size A by taking one element from each row of the 2-D matrix in such a way that the cost of the newly built array is minimized.
        The cost of an array is the minimum possible value of the absolute difference between any two adjacent elements of the array.
        So if the newly built array is X, the element picked from row 1 will become X[1], element picked from row 2 will become X[2], and so on.
        Determine the minimum cost of the newly built array.

        Note :
            

        Problem Constraints
            2 <= A <= 1000
            2 <= B <= 1000
            1 <= C[i][j] <= 10^6

        Input Format
            The first argument is an integer A denoting number of rows in the 2-D array.
            The second argument is an integer B denoting number of columns in the 2-D array.
            The third argument is a 2-D array C of size A x B.

        Output Format
            Return an integer denoting the minimum cost of the newly build array.

        Input 1:
            A = 2
            B = 2
            C = [ [8, 4]
                [6, 8] ]

        Output 1:
            0

        Input 2:
            A = 3
            B = 2
            C = [ [7, 3]
                [2, 1]
                [4, 9] ]

        Output 2:
            1

        */

        // CODE
            int findLowerBound(const vector<int>& row, int target) {
                auto it = lower_bound(row.begin(), row.end(), target);
                if (it == row.end()) return numeric_limits<int>::max(); // No element found
                return *it;
            }

            int findUpperBound(const vector<int>& row, int target) {
                auto it = upper_bound(row.begin(), row.end(), target);
                if (it == row.begin()) return numeric_limits<int>::min(); // No element found
                return *(--it);
            }


            int Solution::solve(int A, int B, vector<vector<int> > &C) {
                // Sort each row
                for (auto& row : C) {
                    sort(row.begin(), row.end());
                }
                
                // int ans = numeric_limits<int>::max();
                int ans = INT_MAX;
                
                // Process each row except the last one
                for (int i = 0; i < A - 1; ++i) {
                    const vector<int>& currentRow = C[i];
                    const vector<int>& nextRow = C[i + 1];
                    
                    for (int j = 0; j < B; ++j) {
                        int currentElement = currentRow[j];
                        
                        // Find the smallest element in the next row >= currentElement
                        int a = findLowerBound(nextRow, currentElement);
                        
                        // Find the largest element in the next row < currentElement
                        int b = findUpperBound(nextRow, currentElement);
                        
                        // Update the minimum difference
                        if (a != numeric_limits<int>::max()) {
                            ans = min(ans, a - currentElement);
                        }
                        if (b != numeric_limits<int>::min()) {
                            ans = min(ans, currentElement - b);
                        }
                    }
                }
                
                return ans;
            }
    // Q2. Maximum height of staircase
        /*
        Q.2 -> Given an integer A representing the number of square blocks. The height of each square block is 1. The task is to create a staircase of max-height using these blocks.
        The first stair would require only one block, and the second stair would require two blocks, and so on.
        Find and return the maximum height of the staircase.

        Note :
            

        Problem Constraints
            0 <= A <= 10^9

        Input Format
            The only argument given is integer A.

        Output Format
            Return the maximum height of the staircase using these blocks.

        Input 1:
            A = 10

        Output 1:
            4

        Input 2:
            A = 20

        Output 2:
            5

        */

        // CODE
        int Solution::solve(int A) {
            int left = 0, right = A, result = 0;

                while (left <= right) {
                    int mid = left + (right - left) / 2;
                    long long sum = (long long)mid * (mid + 1) / 2;

                    if (sum == A) {
                        return mid;
                    } else if (sum < A) {
                        result = mid; // mid can be a possible answer
                        left = mid + 1;
                    } else {
                        right = mid - 1;
                    }
                }

                return result;
        }

## Binary Search Problems ## 
    // Search in rotated sorted array
    // find median of two sorted arrays
        double findMedianSortedArrays(const vector<int>& A, const vector<int>& B) {
            int n1 = A.size();
            int n2 = B.size();
            
            // Ensure A is the smaller array to optimize binary search
            if (n1 > n2) {
                return findMedianSortedArrays(B, A);
            }
            
            int low = 0, high = n1;
            
            while (low <= high) {
                // to make whole Left half 
                // Select partitionA element form a
                // Select partitionB element form b
                // partitionA + partitionB = (n1 + n2) / 2
                int partitionA = (low + high) / 2;
                int partitionB = ( n1 + n2 + 1) / 2 - partitionA;

                // Edge cases where partition is at the boundaries
                // 1. find max of left half partitionA
                // 2. find min of reight half partitionA Rest elements
                int maxLeftA = (partitionA == 0) ? INT_MIN : A[partitionA - 1]; 
                int minRightA = (partitionA == n1) ? INT_MAX : A[partitionA];
                
                // 3. find max of left half partitionB
                // 4. find min of reight half partitionB Rest elements
                int maxLeftB = (partitionB == 0) ? INT_MIN : B[partitionB - 1];
                int minRightB = (partitionB == n2) ? INT_MAX : B[partitionB];
                
                // check Correct partition
                // 1. if maxLeftA <= minRightB
                // 2. if maxLeftB <= minRightA
                if (maxLeftA <= minRightB && maxLeftB <= minRightA) {
                    // If the total number of elements is odd
                    if ((n1 + n2) % 2 == 1) {
                        return max(maxLeftA, maxLeftB);
                    } 
                    // If the total number of elements is even
                    else {
                        return (max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2.0;
                    }
                }
                // Move towards the left half
                // PARTITION A IS GRATER 
                else if (maxLeftA > minRightB) {
                    high = partitionA - 1;
                }
                // Move towards the right half
                // PARTITION B IS GRATER 
                else {
                    low = partitionA + 1;
                }
            }
            
            // If we reach here, the arrays are not sorted or input is invalid
            throw invalid_argument("Input arrays are not sorted");
        }
    // Q1. Rotated Sorted Array Search
        /*
        Q.1 -> Given a sorted array of integers A of size N and an integer B, 
        where array A is rotated at some pivot unknown beforehand.
        For example, the array [0, 1, 2, 4, 5, 6, 7] might become [4, 5, 6, 7, 0, 1, 2].
        Your task is to search for the target value B in the array. If found, return its index; otherwise, return -1.
        You can assume that no duplicates exist in the array.

        NOTE: You are expected to solve this problem with a time complexity of O(log(N)).

        Problem Constraints
            1 <= N <= 1000000
            1 <= A[i] <= 109
            All elements in A are Distinct.

        Input Format
            The First argument given is the integer array A.
            The Second argument given is the integer B.

        Output Format
            Return index of B in array A, otherwise return -1

        Input 1:
            A = [4, 5, 6, 7, 0, 1, 2, 3]
            B = 4 

        Output 1:
            0

        Input 2:
            A : [ 9, 10, 3, 5, 6, 8 ]
            B : 5

        Output 2:
            3

        */

        // CODE
        int Solution::search(const vector<int> &A, int B) {

            int N = A.size();
            int left = 0;
            int right = A.size() - 1;
            
            while (left <= right) {
                int mid = left + (right - left) / 2;
                
                if (A[mid] == B) {
                    return mid;
                }
                //cout<< mid << '|';
                if(A[0] < A[N-1]){
                    if(A[mid] < B){
                        left = mid+1; 
                    }else{
                        right = mid-1;
                    }
                }else{

                //cout<< "L:"<<left<< "R:"<< right<< "mid:" <<mid << "first half";
                    if(B >= A[0]){ // first half
                        if(A[mid] > A[0]){ // I AM IN FIRST HALF
                            if(A[mid] < B){
                                left = mid+1; 
                            }else{
                                right = mid-1;
                            }
                        }else{ // NEED TO GO IN FIRST HALF
                            right= mid-1;
                        }
                    }else{ //second half
                        if(A[mid] <= A[0]){ // I AM IN SECOND HALF
                            if(A[mid] < B){
                                left = mid+1; 
                            }else{
                                right = mid-1;
                            }
                        }else{ // NEED TO GO IN SECOND HALF
                            left = mid+1;
                        }
                    }
                }
            
            }
            
            return -1; // Target value B not found in the array
        }
    // Q2. Median of Array
        /*
        Q.2 -> There are two sorted arrays A and B of sizes N and M respectively.
        Find the median of the two sorted arrays ( The median of the array formed by merging both the arrays ).

        NOTE:
            The overall run time complexity should be O(log(m+n)).
            IF the number of elements in the merged array is even, then the median is the average of (n/2)th and (n/2+1)th element. For example, if the array is [1 2 3 4], the median is (2 + 3) / 2.0 = 2.5.

        Problem Constraints
            1 <= N + M <= 2*106

        Input Format
            The first argument is an integer array A of size N.
            The second argument is an integer array B of size M.

        Output Format
            Return a decimal value denoting the median of two sorted arrays.

        Input 1:
            A = [1, 4, 5]
            B = [2, 3]

        Output 1:
            3.0
            
        Input 2:
            A = [1, 2, 3]
            B = [4]

        Output 2:
            2.5

        */

        // CODE
        double Solution::findMedianSortedArrays(const vector<int> &A, const vector<int> &B) {
            
            int n = A.size();
            int m = B.size();

            // Ensure that A is the smaller array
            if (n > m) {
                return findMedianSortedArrays(B, A);
            }

            int left = 0, right = n;
            while (left <= right) {
                int partitionA = (left + right) / 2;
                int partitionB = (n + m + 1) / 2 - partitionA;

                int maxLeftA = (partitionA == 0) ? INT_MIN : A[partitionA - 1];
                int minRightA = (partitionA == n) ? INT_MAX : A[partitionA];

                int maxLeftB = (partitionB == 0) ? INT_MIN : B[partitionB - 1];
                int minRightB = (partitionB == m) ? INT_MAX : B[partitionB];

                if (maxLeftA <= minRightB && maxLeftB <= minRightA) {
                    if ((n + m) % 2 == 0) {
                        return (double)(max(maxLeftA, maxLeftB) + min(minRightA, minRightB)) / 2;
                    } else {
                        return (double)max(maxLeftA, maxLeftB);
                    }
                } else if (maxLeftA > minRightB) {
                    right = partitionA - 1;
                } else {
                    left = partitionA + 1;
                }
            }

            return 0.0;  // This line should never be reached, given valid input
        }
    // Q3. Ath Magical Number
        /*
        Q.3 -> You are given three positive integers, A, B, and C.
        Any positive integer is magical if divisible by either B or C.
        Return the Ath smallest magical number. Since the answer may be very large, return modulo 109 + 7.

        Note: Ensure to prevent integer overflow while calculating.

        Problem Constraints
            1 <= A <= 10^9
            2 <= B, C <= 40000

        Input Format
            The first argument given is an integer A.
            The second argument given is an integer B.
            The third argument given is an integer C.

        Output Format
            Return the Ath smallest magical number. Since the answer may be very large, return modulo 109 + 7.

        Input 1:
            A = 1
            B = 2
            C = 3

        Output 1:
            2

        Input 2:
            A = 4
            B = 2
            C = 3

        Output 2:
            6   

        */

        // CODE
        const int MOD = 1e9 + 7;

        int countMagicalNumbers(long long x, int B, int C, int lcmBC) {
            return x / B + x / C - x / lcmBC;
        }

        int gcd(int a, int b) {
            return b == 0 ? a : gcd(b, a % b);
        }

        int lcm(int a, int b) {
            return (a / gcd(a, b)) * b;
        }

        int Solution::solve(int A, int B, int C) {
            long long low = 1;
            long long high = (long long) A * min(B, C);
            
            int lcmBC = lcm(B, C);

            while (low < high) {
                long long mid = low + (high - low) / 2;
                if (countMagicalNumbers(mid, B, C, lcmBC) < A) {
                    low = mid + 1;
                } else {
                    high = mid;
                }
            }

            return low % MOD;
        }
    // Q4. Square Root of Integer
        /*
        Q.4 -> Given an integer A. Compute and return the square root of A.
        If A is not a perfect square, return floor(sqrt(A)).

        NOTE: 
        The value of A*A can cross the range of Integer.
        Do not use the sqrt function from the standard library. 
        Users are expected to solve this in O(log(A)) time.

        Problem Constraints
            0 <= A <= 10^9

        Input Format
            The first and only argument given is the integer A.  

        Output Format
            Return floor(sqrt(A))

        Input 1:
            11

        Output 1:
            3

        Input 2:
            9

        Output 2:
            3

        */

        // CODE
        int Solution::sqrt(int A) {
            if (A == 0 || A == 1) {
                return A;
            }
            
            long long left = 1, right = A, ans = 0;
            
            while (left <= right) {
                long long mid = left + (right - left) / 2;
                
                if (mid * mid == A) {
                    return mid;
                } else if (mid * mid < A) {
                    left = mid + 1;
                    ans = mid;  // this mid might be our answer
                } else {
                    right = mid - 1;
                }
            }
            
            return ans;
        }
    // Q1. ADD OR NOT
        /*
        Q.1 -> Given an array of integers A of size N and an integer B.
        In a single operation, any one element of the array can be increased by 1. You are allowed to do at most B such operations.
        Find the number with the maximum number of occurrences and return an array C of size 2, where C[0] is the number of occurrences, and C[1] is the number with maximum occurrence.
        If there are several such numbers, your task is to find the minimum one.

        Note :

        Problem Constraints
            1 <= N <= 10^5
            -10^9 <= A[i] <= 10^9
            0 <= B <= 10^9
            
        Input Format
            The first argument given is the integer array A.
            The second argument given is the integer B.
            
        Output Format
            Return an array C of size 2, where C[0] is number of occurence and C[1] is the number with maximum occurence.

        Input 1:
            A = [3, 1, 2, 2, 1]
            B = 3

        Output 1:
            [4, 2]

        Input 2:
            A = [5, 5, 5]
            B = 3

        Output 2:
            [3, 5]

        */

        // CODE
        bool check(vector<int> &A, int B, long int mid, int i, vector<long int> &pre) {
            // Check if it is possible to make `mid` elements equal to `A[i]`
            if ((A[i] * mid) - (pre[i + 1] - pre[i - mid + 1]) <= B)
                return true;
            return false;    
        }

        vector<int> Solution::solve(vector<int> &A, int B) {
            sort(A.begin(), A.end()); // Sort the array
            
            vector<int> ans(2, -1); // To store the result [count, number]
            vector<long int> pre(A.size() + 1, 0); // Prefix sum array
            
            // Build prefix sum array
            for (int i = 0; i < A.size(); i++) {
                pre[i + 1] = pre[i] + A[i];    
            }

            // Iterate through the sorted array
            for (int i = 0; i < A.size(); i++) {
                int l = 1; // Minimum count to check
                int j = i + 1; // Maximum count to check
                long int maxi = 0; // To store the maximum count found

                while (l <= j) {
                    long int mid = (l + j) / 2; // Mid count to check
                    if (check(A, B, mid, i, pre)) {
                        maxi = mid; // If possible, store the mid count
                        l = mid + 1; // Try for a larger mid
                    } else {
                        j = mid - 1; // Try smaller mid
                    }
                }

                // Update result if we found a larger count
                if (maxi > ans[0]) {
                    ans[1] = A[i]; // Store the number
                    ans[0] = maxi; // Store the maximum count
                }
            }
            return ans; // Return the result
        }
    // Q2. Find Smallest Again
        /*
        Q.2 -> Given an integer array A of size N.
        If we store the sum of each triplet of the array A in a new list, then find the Bth smallest element among the list.

        NOTE: A triplet consists of three elements from the array. Let's say if A[i], A[j], A[k] are the elements of the triplet then i < j < k.

        Problem Constraints
            3 <= N <= 500
            1 <= A[i] <= 10^8
            1 <= B <= (N*(N-1)*(N-2))/6

        Input Format
            The first argument is an integer array A.
            The second argument is an integer B.    

        Output Format
            Return an integer denoting the Bth element of the list.

        Input 1:
            A = [2, 4, 3, 2]
            B = 3

        Output 1:
            9

        Input 2:
            A = [1, 5, 7, 3, 2]
            B = 9

        Output 2:
            14

        */

        // CODE
        int countTripletsLessThanOrEqualTo(vector<int>& A, int N, int target) {
            int count = 0;

            // Iterate over each element A[i] and use two pointers to find valid triplets
            for (int i = 0; i < N - 2; ++i) {
                int j = i + 1;
                int k = N - 1;

                while (j < k) {
                    int sum = A[i] + A[j] + A[k];

                    if (sum <= target) {
                        // All triplets (i, j, j+1, ..., k) have sum <= target
                        count += (k - j);
                        ++j;  // Move the left pointer to try the next triplet
                    } else {
                        --k;  // Move the right pointer to decrease the sum
                    }
                }
            }

            return count;
        }

        int Solution::solve(vector<int>& A, int B) {
            int N = A.size();
            sort(A.begin(), A.end());

            // Find the minimum and maximum possible triplet sums
            int minSum = A[0] + A[1] + A[2];
            int maxSum = A[N-1] + A[N-2] + A[N-3];

            // Perform binary search on the possible range of triplet sums
            int low = minSum, high = maxSum, result = -1;

            while (low <= high) {
                int mid = low + (high - low) / 2;

                // Count how many triplets have a sum <= mid
                int count = countTripletsLessThanOrEqualTo(A, N, mid);

                if (count >= B) {
                    // If we have at least B triplets, mid could be our answer
                    result = mid;
                    high = mid - 1;  // Try to find a smaller valid triplet sum
                } else {
                    // Otherwise, we need to look for larger sums
                    low = mid + 1;
                }
            }

            return result;
        }
    // Q3. Matrix Median
        /*
        Q.3 -> Given a matrix of integers A of size N x M in which each row is sorted.
        Find and return the overall median of matrix A.

        NOTE: No extra memory is allowed.
        NOTE: Rows are numbered from top to bottom and columns are numbered from left to right.

        Problem Constraints
            1 <= N, M <= 10^5
            1 <= N*M <= 10^6
            1 <= A[i] <= 10^9
            N*M is odd

        Input Format
            The first and only argument given is the integer matrix A.

        Output Format
            Return the overall median of matrix A.

        Input 1:
            A = [   [1, 3, 5],
                [2, 6, 9],
                [3, 6, 9]   ] 

        Output 1:
            5

        Input 2:
            A = [   [5, 17, 100]    ]

        Output 2:
            17

        */

        // CODE
        int countLessEqual(const vector<vector<int>> &A, int value) {
            int count = 0;
            int N = A.size();
            int M = A[0].size();
            
            // Count numbers less than or equal to value
            for (int i = 0; i < N; ++i) {
                int lo = 0, hi = M - 1;
                
                while (lo <= hi) {
                    int mid = lo + (hi - lo) / 2;
                    if (A[i][mid] <= value) {
                        lo = mid + 1;
                    } else {
                        hi = mid - 1;
                    }
                }
                
                count += lo;
            }
            
            return count;
        }


        int Solution::findMedian(vector<vector<int> > &A) {
            int N = A.size();
            int M = A[0].size();
            
            int low = INT_MAX;
            int high = INT_MIN;
            
            // Find the minimum and maximum values in the matrix
            for (int i = 0; i < N; ++i) {
                low = min(low, A[i][0]);
                high = max(high, A[i][M - 1]);
            }
            
            int medianPos = (N * M + 1) / 2;  // Position of the median in a 1-based index
            
            // Binary search on the value range
            while (low < high) {
                int mid = low + (high - low) / 2;
                
                if (countLessEqual(A, mid) < medianPos) {
                    low = mid + 1;
                } else {
                    high = mid;
                }
            }
            
            return low;
        }

## Binary Search on Answer ##
    // Q1. Aggressive cows
        /*
        Q.1 -> Farmer John has built a new long barn with N stalls. Given an array of integers A of size N where each element of the array represents the location of the stall and an integer B which represents the number of cows.
        His cows don't like this barn layout and become aggressive towards each other once put into a stall. To prevent the cows from hurting each other, John wants to assign the cows to the stalls, such that the minimum distance between any two of them is as large as possible. What is the largest minimum distance?

        Note :
            

        Problem Constraints
            2 <= N <= 100000
            0 <= A[i] <= 10^9
            2 <= B <= N

        Input Format
            The first argument given is the integer array A.
            The second argument given is the integer B. 

        Output Format
            Return the largest minimum distance possible among the cows.

        Input 1:
            A = [1, 2, 3, 4, 5]
            B = 3

        Output 1:
            2

        Input 2:
            A = [1, 2]
            B = 2

        Output 2:
            1

        */

        // CODE

        int Solution::solve(vector<int> &A, int B) {
            // Sort the stall positions
            sort(A.begin(), A.end());
            
            int low = 1;
            int high = A.back() - A[0];
            int result = 0;
            
            // Binary search on the possible distances
            while (low <= high) {
                int mid = low + (high - low) / 2;
                
                // Check if it is possible to place all cows with at least 'mid' distance
                int last_position = A[0];
                int count = 1;  // Placing the first cow in the first stall
                
                for (int i = 1; i < A.size(); i++) {
                    if (A[i] - last_position >= mid) {
                        // Place the next cow here
                        count++;
                        last_position = A[i];
                    }
                    if (count == B) break;  // If all cows are placed
                }
                
                if (count >= B) {
                    result = mid;  // Update result if it's possible to place all cows
                    low = mid + 1;  // Try for a larger distance
                } else {
                    high = mid - 1;  // Try for a smaller distance
                }
            }
            
            return result;
        }
    // Q2. Painter's Partition Problem
        /*
        Q.2 -> Given 2 integers A and B and an array of integers C of size N. Element C[i] represents the length of ith board.
        You have to paint all N boards [C0, C1, C2, C3  CN-1]. There are A painters available and each of them takes B units of time to paint 1 unit of the board.
        Calculate and return the minimum time required to paint all boards under the constraints that any painter will only paint contiguous sections of the board.

        NOTE:
            1. 2 painters cannot share a board to paint. That is to say, a board cannot be painted partially by one painter, and partially by another.
            2. A painter will only paint contiguous boards. This means a configuration where painter 1 paints boards 1 and 3 but not 2 is invalid.
            Return the ans % 10000003.

        Problem Constraints
            1 <= A <= 1000
            1 <= B <= 10^6
            1 <= N <= 10^5
            1 <= C[i] <= 10^6

        Input Format
            The first argument given is the integer A.
            The second argument given is the integer B.
            The third argument given is the integer array C. 

        Output Format
            Return minimum time required to paint all boards under the constraints that any painter will only paint contiguous sections of board % 10000003.

        Input 1:
            A = 2
            B = 5
            C = [1, 10]

        Output 1:
            50

        Input 2:
            A = 10
            B = 1
            C = [1, 8, 11, 3]

        Output 2:
            11

        */

        // CODE
        const int MOD = 10000003; // Use const for MOD

        bool isPossible(int A, vector<int> &C, long long time) {
            long long sum = 0;
            int painters = 1;

            for (int i = 0; i < C.size(); i++) {
                sum += C[i];
                if (sum > time) {
                    sum = C[i];
                    painters++;
                    if (painters > A) {
                        return false;
                    }
                }
            }

            return true;
        }

        int Solution::paint(int A, int B, vector<int> &C) {
            int n = C.size();
            long long maxElement = *max_element(C.begin(), C.end());

            // Calculate the sum of all elements in C
            long long sum = 0;
            for (int i = 0; i < n; i++) {
                sum += C[i];
            }

            // Binary search to find the minimum time required
            long long lo = maxElement;
            long long hi = sum;
            long long answer = 0;

            while (lo <= hi) {
                long long mid = (lo + hi) / 2;

                if (isPossible(A, C, mid)) {
                    answer = mid;
                    hi = mid - 1;
                } else {
                    lo = mid + 1;
                }
            }

            return (int)((answer * B) % MOD);
        }
    // Q3. Special Integer
        /*
        Q.3 -> Given an array of integers A and an integer B, find and return the maximum value K such that there is no subarray in A of size K with the sum of elements greater than B.

        Note :
            

        Problem Constraints
            1 <= |A| <= 100000
            1 <= A[i] <= 10^9
            1 <= B <= 10^9

        Input Format
            The first argument given is the integer array A.
            The second argument given is integer B.

        Output Format
            Return the maximum value of K (sub array length).

        Input 1:
            A = [1, 2, 3, 4, 5]
            B = 10

        Output 1:
            2

        Input 2:
            A = [5, 17, 100, 11]
            B = 130

        Output 2:
            3

        */

        // CODE
        bool canHaveSubarrayOfSizeK(vector<int> &A, int n, int K, int B) {
            long long sum = 0;
            for (int i = 0; i < K; i++) {
                sum += A[i];
            }
            
            if (sum > B) return false;
            
            for (int i = K; i < n; i++) {
                sum += A[i] - A[i - K];
                if (sum > B) return false;
            }
            
            return true;
        }

        int Solution::solve(vector<int> &A, int B) {
            int n = A.size();
            int low = 1, high = n;
            int result = 0;
            
            while (low <= high) {
                int mid = low + (high - low) / 2;
                
                if (canHaveSubarrayOfSizeK(A, n, mid, B)) {
                    result = mid;
                    low = mid + 1;  // Try to find a larger K
                } else {
                    high = mid - 1;  // Try to find a smaller K
                }
            }
            
            return result;
        }
    // Q1. Allocate Books
        /*
        Q.1 -> Given an array of integers A of size N and an integer B.
        The College library has N books. The ith book has A[i] number of pages.
        You have to allocate books to B number of students so that the maximum number of pages allocated to a student is minimum.
        A book will be allocated to exactly one student.
        Each student has to be allocated at least one book.
        Allotment should be in contiguous order, for example: A student cannot be allocated book 1 and book 3, skipping book 2.
        Calculate and return that minimum possible number.

        NOTE: Return -1 if a valid assignment is not possible

        Problem Constraints
            1 <= N <= 105
            1 <= A[i], B <= 105

        Input Format
            The first argument given is the integer array A.
            The second argument given is the integer B.

        Output Format
            Return that minimum possible number.

        Input 1:
            A = [12, 34, 67, 90]
            B = 2

        Output 1:
            113

        Input 2:
            A = [12, 15, 78] 
            B = 4

        Output 2:
            -1

        */

        // CODE
        bool isFeasible(const vector<int>& A, int B, int maxPages) {
            int studentCount = 1;  // Start with one student
            int currentSum = 0;

            for (int pages : A) {
                // If adding this book exceeds maxPages, allocate to the next student
                if (currentSum + pages > maxPages) {
                    studentCount++;
                    currentSum = pages;  // Start new student with this book

                    if (studentCount > B) {
                        return false;  // More students needed than allowed
                    }
                } else {
                    currentSum += pages;  // Add pages to current student
                }
            }

            return true;  // Feasible to allocate books with maxPages
        }

        int Solution::books(vector<int> &A, int B) {
            int N = A.size();

            // Edge case: If there are fewer books than students, it's impossible
            if (N < B) return -1;

            // Compute the sum of all pages manually
            int totalSum = 0;
            int maxPages = A[0];
            for (int pages : A) {
                totalSum += pages;
                if (pages > maxPages) {
                    maxPages = pages;  // Find the maximum number of pages in a single book
                }
            }

            int low = maxPages;  // The largest single book's pages
            int high = totalSum; // The sum of all pages

            int result = high;  // Initialize result with the highest possible value

            while (low <= high) {
                int mid = low + (high - low) / 2;

                // Check if it's possible to allocate books with maxPages = mid
                if (isFeasible(A, B, mid)) {
                    result = mid;  // Mid is feasible, try to find a smaller maximum
                    high = mid - 1;
                } else {
                    low = mid + 1;  // Mid is too small, increase it
                }
            }

            return result;
        }

## Searching Extra ## 
    // Recursive Binary Search
        int recursiveBinarySearch(const vector<int>& arr, int target, int left, int right) {
            // Base case: target not found
            if (left > right) {
                return -1;
            }

            // Calculate the middle index
            int mid = left + (right - left) / 2;

            // Check if the middle element is the target
            if (arr[mid] == target) {
                return mid;
            }
            // If target is smaller than mid element, search in the left half
            else if (arr[mid] > target) {
                return recursiveBinarySearch(arr, target, left, mid - 1);
            }
            // If target is larger than mid element, search in the right half
            else {
                return recursiveBinarySearch(arr, target, mid + 1, right);
            }
        }
    // Lower Bound And Upper Bound
        int lowerBound(const vector<int>& arr, int target) {
            int left = 0;
            int right = arr.size();
            
            while (left < right) {
                int mid = left + (right - left) / 2;
                
                // Move TO the Left if the middle element is greater than or equal to target
                if (arr[mid] >= target) {
                    right = mid; // Go Left
                } else {
                    left = mid + 1;
                }
            }
            return left;
        }
    // Floor and Ceil of X in an array
        int findFloor(int arr[], int n, int x) {
            int low = 0, high = n - 1;
            int ans = -1;

            while (low <= high) {
                int mid = (low + high) / 2;
                // maybe an answer
                if (arr[mid] <= x) {
                    ans = arr[mid];
                    //look for smaller index on the left
                    low = mid + 1;
                }
                else {
                    high = mid - 1; // look on the right
                }
            }
            return ans;
        }

        int findCeil(int arr[], int n, int x) {
            int low = 0, high = n - 1;
            int ans = -1;

            while (low <= high) {
                int mid = (low + high) / 2;
                // maybe an answer
                if (arr[mid] >= x) {
                    ans = arr[mid];
                    //look for smaller index on the left
                    high = mid - 1;
                }
                else {
                    low = mid + 1; // look on the right
                }
            }
            return ans;
        }
    
    // Search in Rotated Sorted Array with Duplicate
        bool searchInARotatedSortedArrayII(vector<int>&arr, int k) {
            int n = arr.size(); // size of the array.
            int low = 0, high = n - 1;
            while (low <= high) {
                int mid = (low + high) / 2;

                //if mid points the target
                if (arr[mid] == k) return true;

                //Edge case:
                if (arr[low] == arr[mid] && arr[mid] == arr[high]) {
                    low = low + 1;
                    high = high - 1;
                    continue;
                }

                //if left part is sorted:
                if (arr[low] <= arr[mid]) {
                    if (arr[low] <= k && k <= arr[mid]) {
                        //element exists:
                        high = mid - 1;
                    }
                    else {
                        //element does not exist:
                        low = mid + 1;
                    }
                }
                else { //if right part is sorted:
                    if (arr[mid] <= k && k <= arr[high]) {
                        //element exists:
                        low = mid + 1;
                    }
                    else {
                        //element does not exist:
                        high = mid - 1;
                    }
                }
            }
            return false;
        }

    // Minimum in Rotated Sorted Array
        int findMin(vector<int>& arr) {
            int low = 0, high = arr.size() - 1;
            int ans = INT_MAX;
            while (low <= high) {
                int mid = (low + high) / 2;
                //search space is already sorted
                //then arr[low] will always be
                //the minimum in that search space:
                if (arr[low] <= arr[high]) {
                    ans = min(ans, arr[low]);
                    break;
                }

                //if left part is sorted:
                if (arr[low] <= arr[mid]) {
                    // keep the minimum:
                    ans = min(ans, arr[low]);

                    // Eliminate left half:
                    low = mid + 1;
                }
                else { //if right part is sorted:

                    // keep the minimum:
                    ans = min(ans, arr[mid]);

                    // Eliminate right half:
                    high = mid - 1;
                }
            }
            return ans;
        }
    // Find How many time Array has been Rotated
        int findMin(vector<int>& arr) {
            int low = 0, high = arr.size() - 1;
            int ans = INT_MAX;
            while (low <= high) {
                int mid = (low + high) / 2;
                //search space is already sorted
                //then arr[low] will always be
                //the minimum in that search space:
                if (arr[low] <= arr[high]) {
                    ans = min(ans, arr[low]);
                    break;
                }

                //if left part is sorted:
                if (arr[low] <= arr[mid]) {
                    // keep the minimum:
                    ans = min(ans, arr[low]);

                    // Eliminate left half:
                    low = mid + 1;
                }
                else { //if right part is sorted:

                    // keep the minimum:
                    ans = min(ans, arr[mid]);

                    // Eliminate right half:
                    high = mid - 1;
                }
            }
            return ans;
        }
    // Find the Nth root of an Integer
        int func(int mid, int n, int m) {
            long long ans = 1;
            for (int i = 1; i <= n; i++) {
                ans = ans * mid;
                if (ans > m) return 2;
            }
            if (ans == m) return 1;
            return 0;
        }

        int NthRoot(int n, int m) {
            //Use Binary search on the answer space:
            int low = 1, high = m;
            while (low <= high) {
                int mid = (low + high) / 2;
                int midN = func(mid, n, m);
                if (midN == 1) {
                    return mid;
                }
                else if (midN == 0) low = mid + 1;
                else high = mid - 1;
            }
            return -1;
        }
    // Koko Eating Bananas
        int findMax(vector<int> &v) {
            int maxi = INT_MIN;
            int n = v.size();
            //find the maximum:
            for (int i = 0; i < n; i++) {
                maxi = max(maxi, v[i]);
            }
            return maxi;
        }

        int calculateTotalHours(vector<int> &v, int hourly) {
            int totalH = 0;
            int n = v.size();
            //find total hours:
            for (int i = 0; i < n; i++) {
                totalH += ceil((double)(v[i]) / (double)(hourly));
            }
            return totalH;
        }

        int minimumRateToEatBananas(vector<int> v, int h) {
            int low = 1, high = findMax(v);

            //apply binary search:
            while (low <= high) {
                int mid = (low + high) / 2;
                int totalH = calculateTotalHours(v, mid);
                if (totalH <= h) {
                    high = mid - 1;
                }
                else {
                    low = mid + 1;
                }
            }
            return low;
        }
    // Minimum days to make M bouquets
        bool possible(vector<int> &arr, int day, int m, int k) {
            int n = arr.size(); //size of the array
            int cnt = 0;
            int noOfB = 0;
            // count the number of bouquets:
            for (int i = 0; i < n; i++) {
                if (arr[i] <= day) {
                    cnt++;
                }
                else {
                    noOfB += (cnt / k);
                    cnt = 0;
                }
            }
            noOfB += (cnt / k);
            return noOfB >= m;
        }
        int roseGarden(vector<int> arr, int k, int m) {
            long long val = m * 1ll * k * 1ll;
            int n = arr.size(); //size of the array
            if (val > n) return -1; //impossible case.
            //find maximum and minimum:
            int mini = INT_MAX, maxi = INT_MIN;
            for (int i = 0; i < n; i++) {
                mini = min(mini, arr[i]);
                maxi = max(maxi, arr[i]);
            }

            //apply binary search:
            int low = mini, high = maxi;
            while (low <= high) {
                int mid = (low + high) / 2;
                if (possible(arr, mid, m, k)) {
                    high = mid - 1;
                }
                else low = mid + 1;
            }
            return low;
        }
    // Find the Smallest Divisor Given a Threshold
        int sumByD(vector<int> &arr, int div) {
            int n = arr.size(); //size of array
            //Find the summation of division values:
            int sum = 0;
            for (int i = 0; i < n; i++) {
                sum += ceil((double)(arr[i]) / (double)(div));
            }
            return sum;
        }

        int smallestDivisor(vector<int>& arr, int limit) {
            int n = arr.size();
            if (n > limit) return -1;
            int low = 1, high = *max_element(arr.begin(), arr.end());

            //Apply binary search:
            while (low <= high) {
                int mid = (low + high) / 2;
                if (sumByD(arr, mid) <= limit) {
                    high = mid - 1;
                }
                else {
                    low = mid + 1;
                }
            }
            return low;
        }

    // Capacity to Ship Packages within D Days
        int findDays(vector<int> &weights, int cap) {
            int days = 1; //First day.
            int load = 0;
            int n = weights.size(); //size of array.
            for (int i = 0; i < n; i++) {
                if (load + weights[i] > cap) {
                    days += 1; //move to next day
                    load = weights[i]; //load the weight.
                }
                else {
                    //load the weight on the same day.
                    load += weights[i];
                }
            }
            return days;
        }

        int leastWeightCapacity(vector<int> &weights, int d) {
            //Find the maximum and the summation:
            int low = *max_element(weights.begin(), weights.end());
            int high = accumulate(weights.begin(), weights.end(), 0);
            while (low <= high) {
                int mid = (low + high) / 2;
                int numberOfDays = findDays(weights, mid);
                if (numberOfDays <= d) {
                    //eliminate right half
                    high = mid - 1;
                }
                else {
                    //eliminate left half
                    low = mid + 1;
                }
            }
            return low;
        }
    // Kth Missing Positive Number
        int missingK(vector < int > vec, int n, int k) {
            int low = 0, high = n - 1;
            while (low <= high) {
                int mid = (low + high) / 2;
                int missing = vec[mid] - (mid + 1);
                if (missing < k) {
                    low = mid + 1;
                }
                else {
                    high = mid - 1;
                }
            }
            return k + high + 1;
        }

    // Split array - Largest Sum
        int countPartitions(vector<int> &a, int maxSum) {
            int n = a.size(); //size of array.
            int partitions = 1;
            long long subarraySum = 0;
            for (int i = 0; i < n; i++) {
                if (subarraySum + a[i] <= maxSum) {
                    //insert element to current subarray
                    subarraySum += a[i];
                }
                else {
                    //insert element to next subarray
                    partitions++;
                    subarraySum = a[i];
                }
            }
            return partitions;
        }

        int largestSubarraySumMinimized(vector<int> &a, int k) {
            int low = *max_element(a.begin(), a.end());
            int high = accumulate(a.begin(), a.end(), 0);
            //Apply binary search:
            while (low <= high) {
                int mid = (low + high) / 2;
                int partitions = countPartitions(a, mid);
                if (partitions > k) {
                    low = mid + 1;
                }
                else {
                    high = mid - 1;
                }
            }
            return low;
        }
    // Minimize Max Distance to Gas Station
        int numberOfGasStationsRequired(long double dist, vector<int> &arr) {
            int n = arr.size(); // size of the array
            int cnt = 0;
            for (int i = 1; i < n; i++) {
                int numberInBetween = ((arr[i] - arr[i - 1]) / dist);
                if ((arr[i] - arr[i - 1]) == (dist * numberInBetween)) {
                    numberInBetween--;
                }
                cnt += numberInBetween;
            }
            return cnt;
        }
        long double minimiseMaxDistance(vector<int> &arr, int k) {
            int n = arr.size(); // size of the array
            long double low = 0;
            long double high = 0;

            //Find the maximum distance:
            for (int i = 0; i < n - 1; i++) {
                high = max(high, (long double)(arr[i + 1] - arr[i]));
            }

            //Apply Binary search:
            long double diff = 1e-6 ;
            while (high - low > diff) {
                long double mid = (low + high) / (2.0);
                int cnt = numberOfGasStationsRequired(mid, arr);
                if (cnt > k) {
                    low = mid;
                }
                else {
                    high = mid;
                }
            }
            return high;
        }
    // Median of 2 sorted arrays
        double median(vector<int>& a, vector<int>& b) {
            int n1 = a.size(), n2 = b.size();
            //if n1 is bigger swap the arrays:
            if (n1 > n2) return median(b, a);

            int n = n1 + n2; //total length
            int left = (n1 + n2 + 1) / 2; //length of left half
            //apply binary search:
            int low = 0, high = n1;
            while (low <= high) {
                int mid1 = (low + high) >> 1;
                int mid2 = left - mid1;
                //calculate l1, l2, r1 and r2;
                int l1 = INT_MIN, l2 = INT_MIN;
                int r1 = INT_MAX, r2 = INT_MAX;
                if (mid1 < n1) r1 = a[mid1];
                if (mid2 < n2) r2 = b[mid2];
                if (mid1 - 1 >= 0) l1 = a[mid1 - 1];
                if (mid2 - 1 >= 0) l2 = b[mid2 - 1];

                if (l1 <= r2 && l2 <= r1) {
                    if (n % 2 == 1) return max(l1, l2);
                    else return ((double)(max(l1, l2) + min(r1, r2))) / 2.0;
                }

                //eliminate the halves:
                else if (l1 > r2) high = mid1 - 1;
                else low = mid1 + 1;
            }
            return 0; //dummy statement
        }
    // Kth element of 2 sorted arrays
        int kthElement(vector<int> &a, vector<int>& b, int m, int n, int k) {
            if (m > n) return kthElement(b, a, n, m, k);

            int left = k; //length of left half

            //apply binary search:
            int low = max(0, k - n), high = min(k, m);
            while (low <= high) {
                int mid1 = (low + high) >> 1;
                int mid2 = left - mid1;
                //calculate l1, l2, r1 and r2;
                int l1 = INT_MIN, l2 = INT_MIN;
                int r1 = INT_MAX, r2 = INT_MAX;
                if (mid1 < m) r1 = a[mid1];
                if (mid2 < n) r2 = b[mid2];
                if (mid1 - 1 >= 0) l1 = a[mid1 - 1];
                if (mid2 - 1 >= 0) l2 = b[mid2 - 1];

                if (l1 <= r2 && l2 <= r1) {
                    return max(l1, l2);
                }

                //eliminate the halves:
                else if (l1 > r2) high = mid1 - 1;
                else low = mid1 + 1;
            }
            return 0; //dummy statement

        }
    // Find the row with maximum number of 1's
        int lowerBound(vector<int> arr, int n, int x) {
            int low = 0, high = n - 1;
            int ans = n;

            while (low <= high) {
                int mid = (low + high) / 2;
                // maybe an answer
                if (arr[mid] >= x) {
                    ans = mid;
                    //look for smaller index on the left
                    high = mid - 1;
                }
                else {
                    low = mid + 1; // look on the right
                }
            }
            return ans;
        }
        int rowWithMax1s(vector<vector<int>> &matrix, int n, int m) {
            int cnt_max = 0;
            int index = -1;

            //traverse the rows:
            for (int i = 0; i < n; i++) {
                // get the number of 1's:
                int cnt_ones = m - lowerBound(matrix[i], m, 1);
                if (cnt_ones > cnt_max) {
                    cnt_max = cnt_ones;
                    index = i;
                }
            }
            return index;
        }
    // Search in a 2 D matrix
        bool searchMatrix(vector<vector<int>>& matrix, int target) {
            int n = matrix.size();
            int m = matrix[0].size();

            //apply binary search:
            int low = 0, high = n * m - 1;
            while (low <= high) {
                int mid = (low + high) / 2;
                int row = mid / m, col = mid % m;
                if (matrix[row][col] == target) return true;
                else if (matrix[row][col] < target) low = mid + 1;
                else high = mid - 1;
            }
            return false;
        }
    // Search in a row and column wise sorted matrix
        bool searchElement(vector<vector<int>>& matrix, int target) {
            int n = matrix.size();
            int m = matrix[0].size();
            int row = 0, col = m - 1;

            //traverse the matrix from (0, m-1):
            while (row < n && col >= 0) {
                if (matrix[row][col] == target) return true;
                else if (matrix[row][col] < target) row++;
                else col--;
            }
            return false;
        }
    // Find Peak Element (2D Matrix)
        // Helper function to find the maximum element in a given column
        int getMaxInColumn(const vector<vector<int>>& matrix, int midCol, int& maxRow) {
            int maxValue = matrix[0][midCol];
            maxRow = 0;

            for (int row = 1; row < matrix.size(); ++row) {
                if (matrix[row][midCol] > maxValue) {
                    maxValue = matrix[row][midCol];
                    maxRow = row;
                }
            }

            return maxValue;
        }

        // Function to find a peak element in a 2D matrix
        pair<int, int> findPeak2D(const vector<vector<int>>& matrix) {
            int rows = matrix.size();
            int cols = matrix[0].size();
            int left = 0, right = cols - 1;

            while (left <= right) {
                int midCol = (left + right) / 2;
                int maxRow;
                int maxValue = getMaxInColumn(matrix, midCol, maxRow);

                bool leftIsBigger = (midCol > 0 && matrix[maxRow][midCol - 1] > maxValue);
                bool rightIsBigger = (midCol < cols - 1 && matrix[maxRow][midCol + 1] > maxValue);

                // If the maximum element in the middle column is a peak
                if (!leftIsBigger && !rightIsBigger) {
                    return {maxRow, midCol};
                }

                // Move to the side with a bigger neighbor
                if (leftIsBigger) {
                    right = midCol - 1;
                } else {
                    left = midCol + 1;
                }
            }

            return {-1, -1}; // Return -1, -1 if no peak is found (edge case)
        }

    // Matrix Median
        int upperBound(vector<int> &arr, int x, int n) {
            int low = 0, high = n - 1;
            int ans = n;

            while (low <= high) {
                int mid = (low + high) / 2;
                // maybe an answer
                if (arr[mid] > x) {
                    ans = mid;
                    //look for smaller index on the left
                    high = mid - 1;
                }
                else {
                    low = mid + 1; // look on the right
                }
            }
            return ans;
        }

        int countSmallEqual(vector<vector<int>> &matrix, int m, int n, int x) {
            int cnt = 0;
            for (int i = 0; i < m; i++) {
                cnt += upperBound(matrix[i], x, n);
            }
            return cnt;
        }

        int median(vector<vector<int>> &matrix, int m, int n) {
            int low = INT_MAX, high = INT_MIN;

            //point low and high to right elements:
            for (int i = 0; i < m; i++) {
                low = min(low, matrix[i][0]);
                high = max(high, matrix[i][n - 1]);
            }

            int req = (n * m) / 2;
            while (low <= high) {
                int mid = (low + high) / 2;
                int smallEqual = countSmallEqual(matrix, m, n, mid);
                if (smallEqual <= req) low = mid + 1;
                else high = mid - 1;
            }
            return low;
        }
// Linked LIst
## Introduction & Basic Problems ##
    // Structure
        class node {
            int data;
            Node* next;
            // Constructor to initialize the node with data and next pointer
            Node(int value) {
                data = value;
                next = nullptr;
            }
        }  

        struct ListNode {
            int val;
            ListNode *next;

            // Constructor
            ListNode(int x) : val(x), next(NULL) {}
        };
    // Traversals
        ListNode* temp = head;
        while (temp != NULL) {
            cout << temp->val << " -> ";
            temp = temp->next;
        }
        cout << "NULL" << endl;
    // Access the Kth element in linked list
        if (head == nullptr) 
            return -1;  // If the list is empty, return -1

        ListNode* temp = head;  // Start from the head node
        
        // Traverse the list to find the k-th node
        for (int i = 1; i < k; i++) {
            temp = temp->next;  // Move to the next node
            if (temp == nullptr) 
                return -1;  // If we reach the end before k, return -1
        }
        return temp->val;
    // Search in Linked List
    // insertion in linked list in Kth index
    // Deletion in Linked List
    // Delete first Occurance of element
    // Delete all Occurance of element
    // Delete all Duplicate elements
        ListNode* deleteDuplicates(ListNode* head) {
            if (!head) return head;

            ListNode* curr = head;
            while (curr->next) {
                if (curr->val == curr->next->val) {
                    ListNode* temp = curr->next;
                    curr->next = curr->next->next;
                    delete temp;
                } else {
                    curr = curr->next;
                }
            }
            return head;
        }
    // Reverse the linked list
    // Check the linked list is palindrome or not
    // Q1. Print Linked List
        /*
        Q.1 -> You are given A which is the head of a linked list. Print the linked list in space separated manner.

        Note : The last node value must also be succeeded by a space and after printing the entire list you should print a new line

        Problem Constraints
            1 <= size of linked list <= 10^5
            1 <= value of nodes <= 10^9

        Input Format
            The first argument A is the head of a linked list.  

        Output Format
            You dont need to return anything

        Input 1:
            A = 1 -> 2 -> 3

        Output 1:
            1 2 3

        Input 2:
            A = 4 -> 3 -> 2 -> 1

        Output 2:
            4 3 2 1

        */

        // CODE
        /**
        * Definition for singly-linked list.
        * struct ListNode {
        *     int val;
        *     ListNode *next;
        *     ListNode(int x) : val(x), next(NULL) {}
        * };
        */
        void Solution::solve(ListNode* A) {

            ListNode *temp = A;

            while(temp != NULL){
                cout<< temp->val << " ";
                temp = temp->next;
            }

            cout<<"\n";

            return;
        }
    // Q2. Insert in Linked List
        /*
        Q.2 -> You are given A which is the head of a linked list. Also given is the value B and position C. Complete the function that should insert a new node with the said value at the given position.

        Note : In case the position is more than length of linked list, simply insert the new node at the tail only.
        In case the pos is 0, simply insert the new node at head only.
        Follow 0-based indexing for the node numbering.
            

        Problem Constraints
            0 <= size of linked list <= 10^5
            1 <= value of nodes <= 10^9
            1 <= B <= 10^9
            0 <= C <= 10^5

        Input Format
            The first argument A is the head of a linked list.
            The second argument B is an integer which denotes the value of the new node
            The third argument C is an integer which denotes the position of the new node

        Output Format
            Return the head of the linked list

        Input 1:
            A = 1 -> 2
            B = 3
            C = 0

        Output 1:
            A = 1 -> 2
            B = 3
            C = 1

        Input 2:
            3 -> 1 -> 2

        Output 2:
            1 -> 3 -> 2

        */

        // CODE
        /**
        * Definition for singly-linked list.
        * struct ListNode {
        *     int val;
        *     ListNode *next;
        *     ListNode(int x) : val(x), next(NULL) {}
        * };
        */
        ListNode* Solution::solve(ListNode* A, int B, int C) {

            ListNode *new_node = new ListNode(B);

            if(A == NULL){
                return new_node;
            }
            if (C == 0){
                new_node->next = A;
                A = new_node;
                return A;
            }

            ListNode *temp = A;
            int count = 0;
            while(temp->next != NULL){
            count++;
            if( count  == C-1){
                    temp = temp->next;
                    break;
            }else{
                    temp = temp->next;
            }
            }

            new_node->next = temp->next;
            temp->next = new_node;

            return A;

        }
    // Q3. Delete in Linked List
        /*
        Q.3 -> You are given the head of a linked list A and an integer B. Delete the B-th node from the linked list.

        Note : Follow 0-based indexing for the node numbering.

        Problem Constraints
            1 <= size of linked list <= 10^5
            1 <= value of nodes <= 10^9
            0 <= B < size of linked list

        Input Format
            The first argument A is the head of a linked list.
            The second arguement B is an integer.   

        Output Format
            Return the head of the linked list after deletion

        Input 1:
            A = 1 -> 2 -> 3
            B = 1

        Output 1:
            1 -> 3

        Input 2:
            A = 4 -> 3 -> 2 -> 1
            B = 0

        Output 2:
            3 -> 2 -> 1

        */

        // CODE
        /**
        * Definition for singly-linked list.
        * struct ListNode {
        *     int val;
        *     ListNode *next;
        *     ListNode(int x) : val(x), next(NULL) {}
        * };
        */

        ListNode* Solution::solve(ListNode* A, int B) {
            
            if(A == NULL){
                return NULL;
            }

            if (B == 0){
                A = A->next;
                return A;
            }

            ListNode *temp =  A;
            
            long count = 0;
            while(temp->next != NULL){
                count ++;
                if (count == B){
                    temp->next =  temp->next->next;
                    break;
                }
                temp = temp->next;

            }

            return A;
        }
    // Q4. Reverse Linked List
        /*
        Q.4 -> You are given a singly linked list having head node A. You have to reverse the linked list and return the head node of that reversed list.

        NOTE: You have to do it in-place and in one-pass.

        Problem Constraints
            1 <= Length of linked list <= 10^5
            Value of each node is within the range of a 32-bit integer.

        Input Format
            First and only argument is a linked-list node A.

        Output Format
            Return a linked-list node denoting the head of the reversed linked list.

        Input 1:
            A = 1 -> 2 -> 3 -> 4 -> 5 -> NULL 

        Output 1:
            5 -> 4 -> 3 -> 2 -> 1 -> NULL 

        Input 2:
            A = 3 -> NULL 

        Output 2:
            3 -> NULL 

        */

        // CODE
        /**
        * Definition for singly-linked list.
        * struct ListNode {
        *     int val;
        *     ListNode *next;
        *     ListNode(int x) : val(x), next(NULL) {}
        * };
        */
        ListNode* Solution::reverseList(ListNode* A) {

            ListNode *cur = A;
            ListNode *prev = NULL;

            while(cur != NULL){
                ListNode *next = cur->next;
                cur->next = prev;
                prev = cur;
                cur = next;
            }

            return prev;
        }
    // Q5. Palindrome List
        /*
        Q.5 -> Given a singly linked list A, determine if it's a palindrome. Return 1 or 0, denoting if it's a palindrome or not, respectively.

        Note :

        Problem Constraints
            1 <= |A| <= 10^5

        Input Format
            The first and the only argument of input contains a pointer to the head of the given linked list.

        Output Format
            Return 0, if the linked list is not a palindrome.
            Return 1, if the linked list is a palindrome.

        Input 1:
            A = [1, 2, 2, 1]

        Output 1:
            1 

        Input 2:
            A = [1, 3, 2]

        Output 2:
            0

        */

        // CODE
        /**
        * Definition for singly-linked list.
        * struct ListNode {
        *     int val;
        *     ListNode *next;
        *     ListNode(int x) : val(x), next(NULL) {}
        * };
        */
        int Solution::lPalin(ListNode* A) {
            if (A == NULL || A->next == NULL) {
                return 1;
            }

            // Step 1: Find the middle of the linked list
            ListNode *slow = A, *fast = A;
            while (fast != NULL && fast->next != NULL) {
                slow = slow->next;
                fast = fast->next->next;
            }

            // Step 2: Reverse the second half of the linked list
            ListNode *prev = NULL, *current = slow, *next;
            while (current != NULL) {
                next = current->next;
                current->next = prev;
                prev = current;
                current = next;
            }

            // Step 3: Compare the first half and the reversed second half
            ListNode *firstHalf = A, *secondHalf = prev;
            while (secondHalf != NULL) {
                if (firstHalf->val != secondHalf->val) {
                    return 0;
                }
                firstHalf = firstHalf->next;
                secondHalf = secondHalf->next;
            }

            return 1;
        }
    // Q1. Remove Nth Node from List End
        /*
        Q.1 -> Given a linked list A, remove the B-th node from the end of the list and return its head.
        For example, given linked list: 1->2->3->4->5, and B = 2.
        After removing the second node from the end, the linked list becomes 1->2->3->5.

        NOTE: If B is greater than the size of the list, remove the first node of the list.
                Try doing it using constant additional space.

        Problem Constraints
        

        Input Format
            The first argument of input contains a pointer to the head of the linked list. The second argument of input contains the integer B.

        Output Format
            Return the head of the linked list after deleting the B-th element from the end.

        Input 1:
            A = 1->2->3->4->5
            B = 2

        Output 1:
            1->2->3->5

        Input 2:
            A = 1
            B = 1

        Output 2:
            Null

        */

        // CODE
        /**
        * Definition for singly-linked list.
        * struct ListNode {
        *     int val;
        *     ListNode *next;
        *     ListNode(int x) : val(x), next(NULL) {}
        * };
        */
        ListNode* Solution::removeNthFromEnd(ListNode* A, int B) {
            
            ListNode *temp = A;

            // finding length
            int N = 0;
            while(temp != NULL){
                N++;
                temp = temp->next;
            }

            // deleting Nth node from end
            if(A == NULL){
                return NULL;
            }

            if (N-B == 0 || B > N){
                A = A->next;
                return A;
            }

            ListNode *temp2 = A;
            int count = 0;
            
            while(temp2->next != NULL){
                count ++;
                if (count == N-B){
                    temp2->next =  temp2->next->next;
                    break;
                }
                temp2 = temp2->next;

            }

            return A;
        }
    // Q2. Remove Duplicates from Sorted List
        /*
        Q.2 -> Given a sorted linked list, delete all duplicates such that each element appears only once.

        Note :

        Problem Constraints
            0 <= length of linked list <= 10^6

        Input Format
            First argument is the head pointer of the linked list.  

        Output Format
            Return the head pointer of the linked list after removing all duplicates.

        Input 1:
            1->1->2

        Output 1:
            1->2

        Input 2:
            1->1->2->3->3

        Output 2:
            1->2->3

        */

        // CODE
        /**
        * Definition for singly-linked list.
        * struct ListNode {
        *     int val;
        *     ListNode *next;
        *     ListNode(int x) : val(x), next(NULL) {}
        * };
        */
        ListNode* Solution::deleteDuplicates(ListNode* A) {

            if(A == NULL){
                return NULL;
            }

            ListNode *temp =  A;

            while(temp->next != NULL){

                if (temp->next->val == temp->val) {
                    // Skip duplicates
                    while (temp->next != NULL && temp->next->val == temp->val) {
                        temp->next = temp->next->next;
                    }
                } else {
                    temp = temp->next;
                }

            }

            return A;
        }
    // Q3. Reverse Link List II
        /*
        Q.3 -> Reverse a linked list A from position B to C.

        NOTE: Do it in-place and in one-pass.

        Problem Constraints
            1 <= |A| <= 10^6
            1 <= B <= C <= |A|



        Input Format
            The first argument contains a pointer to the head of the given linked list, A.
            The second arugment contains an integer, B.
            The third argument contains an integer C.

        Output Format
            Return a pointer to the head of the modified linked list.

        Input 1:
            A = 1 -> 2 -> 3 -> 4 -> 5
            B = 2
            C = 4


        Output 1:
            1 -> 4 -> 3 -> 2 -> 5

        Input 2:
            A = 1 -> 2 -> 3 -> 4 -> 5
            B = 1
            C = 5

        Output 2:
            5 -> 4 -> 3 -> 2 -> 1

        */

        // CODE
        /**
        * Definition for singly-linked list.
        * struct ListNode {
        *     int val;
        *     ListNode *next;
        *     ListNode(int x) : val(x), next(NULL) {}
        * };
        */
        ListNode* Solution::reverseBetween(ListNode* A, int B, int C) {

            if (A == NULL || B == C) {
                return A;
            }

            // Create a dummy node to handle edge cases (like B = 1)
            ListNode* dummy = new ListNode(0);
            dummy->next = A;
            
            // Step 1: Navigate to the node before position B
            ListNode* preB = dummy;
            for (int i = 1; i < B; ++i) {
                preB = preB->next;
            }

            // Step 2: Reverse the sublist from B to C
            ListNode* start = preB->next; // Node at position B
            ListNode* then = start->next; // Node at position B+1

            for (int i = 0; i < C - B; ++i) {
                start->next = then->next; // Remove `then` from the sublist
                then->next = preB->next;  // Insert `then` right after `preB`
                preB->next = then;        // Reconnect `preB` to `then`
                then = start->next;       // Move `then` forward
            }

            // Return the modified list
            return dummy->next;

        }
    // Q4. K reverse linked list
        /*
        Q.4 -> Given a singly linked list A and an integer B, reverse the nodes of the list B at a time and return the modified linked list.

        Note :
            

        Problem Constraints
            1 <= |A| <= 10^3
            B always divides A

        Input Format
            The first argument of input contains a pointer to the head of the linked list.
            The second arugment of input contains the integer, B.
            
        Output Format
            Return a pointer to the head of the modified linked list.

        Input 1:
            A = [1, 2, 3, 4, 5, 6]
            B = 2

        Output 1:
            [2, 1, 4, 3, 6, 5]

        Input 2:
            A = [1, 2, 3, 4, 5, 6]
            B = 3

        Output 2:
            [3, 2, 1, 6, 5, 4]

        */

        // CODE
        /**
        * Definition for singly-linked list.
        * struct ListNode {
        *     int val;
        *     ListNode *next;
        *     ListNode(int x) : val(x), next(NULL) {}
        * };
        */
        ListNode* Solution::reverseList(ListNode* A, int B) {
            if (A == NULL || B == 1) {
                return A;  // No need to reverse if the list is empty or B is 1
            }

            // Step 1: Count total number of nodes in the list
            ListNode* temp = A;
            int count = 0;
            while (temp != NULL) {
                count++;
                temp = temp->next;
            }

            // Step 2: Set up dummy node and pointers
            ListNode* dummy = new ListNode(0);
            dummy->next = A;
            ListNode* pre = dummy;
            ListNode* curr;
            ListNode* nex;

            // Step 3: Reverse in groups of B nodes
            while (count >= B) {
                curr = pre->next;  // The first node of the group
                nex = curr->next;  // The second node of the group
                
                // Reverse B nodes
                for (int i = 1; i < B; i++) {
                    curr->next = nex->next; // Remove `nex` from its position
                    nex->next = pre->next;  // Insert `nex` at the start of the group
                    pre->next = nex;        // Reconnect pre to the new head of the reversed group
                    nex = curr->next;       // Move `nex` forward
                }
                
                // Move pre to the end of the reversed group
                pre = curr;
                count -= B;
            }

            // Step 4: Return the new head
            return dummy->next;
        }
    // Q5. Longest Palindromic List
        /*

        Q.5 ->Given a linked list of integers. Find and return the length of the longest palindrome list that exists in that linked list.
        A palindrome list is a list that reads the same backward and forward.
        Expected memory complexity : O(1) 

        Note :
            

        Problem Constraints
            1 <= length of the linked list <= 2000
            1 <= Node value <= 100

        Input Format
            The only argument given is head pointer of the linked list.

        Output Format
            Return the length of the longest palindrome list.

        Input 1:
            2 -> 3 -> 3 -> 3

        Output 1:
            3

        Input 2:
            2 -> 1 -> 2 -> 1 ->  2 -> 2 -> 1 -> 3 -> 2 -> 2


        Output 2:
            5

        */

        // CODE
        /**
        * Definition for singly-linked list.
        * struct ListNode {
        *     int val;
        *     ListNode *next;
        *     ListNode(int x) : val(x), next(NULL) {}
        * };
        */

        // Function to calculate max palindrome length
        int countPalindrome(ListNode* left, ListNode* right) {
            int length = 0;
            while (left != NULL && right != NULL && left->val == right->val) {
                // Each matching pair adds two to the palindrome length
                length += 2;
                left = left->next;
                right = right->next;
            }
            return length;
        }

        int Solution::solve(ListNode* A) {
            if (A == NULL) return 0;

            int maxLength = 1;  // At least one node is always a palindrome by itself
            ListNode *prev = NULL, *curr = A;

            // Traverse the linked list
            while (curr != NULL) {
                ListNode* next = curr->next;
                
                // Reverse the current node's link to the previous node
                curr->next = prev;

                // Check for odd-length palindromes (centered at curr)
                if (prev != NULL) {
                    int oddLength = 1 + countPalindrome(prev, next);
                    maxLength = max(maxLength, oddLength);
                }

                // Check for even-length palindromes (centered between prev and curr)
                if (next != NULL) {
                    int evenLength = countPalindrome(curr, next);
                    maxLength = max(maxLength, evenLength);
                }

                // Move to the next node in the list
                prev = curr;
                curr = next;
            }

            return maxLength;
        }
    
## Sorting and Detecting Loop ##
    // Q1. Sort List
        /*
        Q.1 -> Sort a linked list, A in O(n log n) time.

        Note :
            

        Problem Constraints
            0 <= |A| = 105

        Input Format
            The first and the only arugment of input contains a pointer to the head of the linked list, A.

        Output Format
            Return a pointer to the head of the sorted linked list.

        Input 1:
            A = [3, 4, 2, 8]

        Output 1:
            [2, 3, 4, 8]

        Input 2:
            A = [1]

        Output 2:
            [1]

        */

        // CODE
        /**
        * Definition for singly-linked list.
        * struct ListNode {
        *     int val;
        *     ListNode *next;
        *     ListNode(int x) : val(x), next(NULL) {}
        * };
        */

        ListNode* merge(ListNode* l1, ListNode* l2) {
            // Base case for merging
            if (!l1) return l2;
            if (!l2) return l1;

            // Dummy node to form the merged list
            ListNode* dummy = new ListNode(0);
            ListNode* current = dummy;

            // Merge process
            while (l1 && l2) {
                if (l1->val < l2->val) {
                    current->next = l1;
                    l1 = l1->next;
                } else {
                    current->next = l2;
                    l2 = l2->next;
                }
                current = current->next;
            }

            // Append remaining nodes
            if (l1) current->next = l1;
            if (l2) current->next = l2;

            return dummy->next; // Return the merged sorted list
        }

        // Function to find the middle of the linked list
        ListNode* getMiddle(ListNode* head) {
            if (!head) return NULL;

            ListNode* slow = head;
            ListNode* fast = head;

            while (fast->next && fast->next->next) {
                slow = slow->next;
                fast = fast->next->next;
            }

            return slow; // Slow will be at the middle
        }

        ListNode* Solution::sortList(ListNode* A) {
            // Base case: If the list is empty or has only one element, it's sorted
            if (!A || !A->next) return A;

            // Step 1: Split the list into two halves
            ListNode* middle = getMiddle(A);
            ListNode* nextOfMiddle = middle->next;
            middle->next = NULL; // Break the list

            // Step 2: Recursively sort both halves
            ListNode* left = sortList(A);
            ListNode* right = sortList(nextOfMiddle);

            // Step 3: Merge the two sorted halves
            return merge(left, right);
        }
    // Q2. Merge Two Sorted Lists
        /*
        Q.2 -> 
        Merge two sorted linked lists, A and B, and return it as a new list.
        The new list should be made by splicing together the nodes of the first two lists and should also be sorted.

        Note :
            

        Problem Constraints
            0 <= |A|, |B| <= 10^5

        Input Format
            The first argument of input contains a pointer to the head of linked list A.
            The second argument of input contains a pointer to the head of linked list B.

        Output Format
            Return a pointer to the head of the merged linked list.

        Input 1:
            A = 5 -> 8 -> 20
            B = 4 -> 11 -> 15

        Output 1:
            4 -> 5 -> 8 -> 11 -> 15 -> 20

        Input 2:
            A = 1 -> 2 -> 3
            B = Null

        Output 2:
            1 -> 2 -> 3

        */

        // CODE
        /**
        * Definition for singly-linked list.
        * struct ListNode {
        *     int val;
        *     ListNode *next;
        *     ListNode(int x) : val(x), next(NULL) {}
        * };
        */
        ListNode* Solution::mergeTwoLists(ListNode* A, ListNode* B) {
            // If either list is empty, return the other list
            if (!A) return B;
            if (!B) return A;

            // Create a dummy node to form the new merged list
            ListNode* dummy = new ListNode(0);
            ListNode* current = dummy;

            // Traverse both lists and merge them
            while (A && B) {
                if (A->val < B->val) {
                    current->next = A;  // Append node from list A
                    A = A->next;  // Move to the next node in A
                } else {
                    current->next = B;  // Append node from list B
                    B = B->next;  // Move to the next node in B
                }
                current = current->next;  // Move to the next position in the merged list
            }

            // If one list is exhausted, append the other list
            if (A) current->next = A;
            if (B) current->next = B;

            // Return the merged list starting from the next of dummy node
            return dummy->next;
        }
    // Q3. Remove Loop from Linked List
        /*
        Q.3 -> 
        You are using Google Maps to help you find your way around a new place. But, you get lost and end up walking in a circle. Google Maps has a way to keep track of where you've been with the help of special sensors.These sensors notice that you're walking in a loop, and now, Google wants to create a new feature to help you figure out exactly where you started going in circles.
        Here's how we can describe the challenge in simpler terms: You have a Linked List A that shows each step of your journey, like a chain of events. Some of these steps have accidentally led you back to a place you've already been, making you walk in a loop. The goal is to find out the exact point where you first started walking in this loop, and then you want to break the loop by not going in the circle just before this point.

        Note :

        Problem Constraints
            1 <= number of nodes <= 1000

        Input Format
            The first of the input contains a LinkedList, where the first number is the number of nodes N, and the next N nodes are the node value of the linked list.
            The second line of the input contains an integer which denotes the position of node where cycle starts.

        Output Format
            return the head of the updated linked list.

        Input 1:
        
        1 -> 2
        ^    |
        | - - 

        Output 1:
            1 -> 2 -> NULL

        Input 2:
        3 -> 2 -> 4 -> 5 -> 6
                ^         |
                |         |    
                - - - - - -

        Output 2:
            3 -> 2 -> 4 -> 5 -> 6 -> NULL

        */

        // CODE
        /**
        * Definition for singly-linked list.
        * struct ListNode {
        *     int val;
        *     ListNode *next;
        *     ListNode(int x) : val(x), next(NULL) {}
        * };
        */
        ListNode* Solution::solve(ListNode* A) {
            if (!A || !A->next) return A;  // If the list is empty or has only one node, return the list as is

            ListNode* slow = A;
            ListNode* fast = A;

            // Step 1: Detect the cycle using the Floyds Cycle Detection Algorithm
            while (fast && fast->next) {
                slow = slow->next;
                fast = fast->next->next;
                
                if (slow == fast) {  // Cycle detected
                    break;
                }
            }

            // If no cycle is found, return the head as is
            if (slow != fast) return A;

            // Step 2: Find the start of the cycle
            slow = A;  // Move slow pointer back to the head
            while (slow != fast) {
                slow = slow->next;
                fast = fast->next;
            }

            // 'slow' now points to the start of the cycle

            // Step 3: Remove the cycle
            ListNode* cycleStart = slow;
            ListNode* temp = cycleStart;
            while (temp->next != cycleStart) {
                temp = temp->next;
            }

            // Break the cycle
            temp->next = NULL;

            return A;  // Return the head of the updated list
        }
    // Q4. Middle element of linked list
        /*
        Q.4 -> 
        Given a linked list of integers, find and return the middle element of the linked list.
        NOTE: If there are N nodes in the linked list and N is even then return the (N/2 + 1)th element.

        Note :

        Problem Constraints
            1 <= length of the linked list <= 100000
            1 <= Node value <= 109   

        Input Format
            The only argument given head pointer of linked list.    

        Output Format
            Return the middle element of the linked list.

        Input 1:
            1 -> 2 -> 3 -> 4 -> 5

        Output 1:
            3

        Input 2:
            1 -> 5 -> 6 -> 2 -> 3 -> 4

        Output 2:
            2

        */

        // CODE
        /**
        * Definition for singly-linked list.
        * struct ListNode {
        *     int val;
        *     ListNode *next;
        *     ListNode(int x) : val(x), next(NULL) {}
        * };
        */
        int Solution::solve(ListNode* A) {
            // Initialize slow and fast pointers to the head of the list
            ListNode* slow = A;
            ListNode* fast = A;

            // Traverse the list with slow and fast pointers
            while (fast != NULL && fast->next != NULL) {
                slow = slow->next;         // Move slow by one step
                fast = fast->next->next;   // Move fast by two steps
            }

            // When the loop ends, slow will be at the middle
            return slow->val;
        }
    // Q1. Swap List Nodes in pairs
        /*
        Q.1 -> Given a linked list A, swap every two adjacent nodes and return its head.
        NOTE: Your algorithm should use only constant space. You may not modify the values in the list; only nodes themselves can be changed.

        Problem Constraints
            1 <= |A| <= 106

        Input Format
            The first and the only argument of input contains a pointer to the head of the given linked list.

        Output Format
            Return a pointer to the head of the modified linked list.

        Input 1:
            A = 1 -> 2 -> 3 -> 4

        Output 1:
            2 -> 1 -> 4 -> 3

        Input 2:
            A = 7 -> 2 -> 1

        Output 2:
            2 -> 7 -> 1

        */

        // CODE
        /**
        * Definition for singly-linked list.
        * struct ListNode {
        *     int val;
        *     ListNode *next;
        *     ListNode(int x) : val(x), next(NULL) {}
        * };
        */
        ListNode * Solution::swapPairs(ListNode * head) {
            // Base case: If the list has no node or only one node, return head
            if (!head || !head->next) return head;
            
            // Initialize a dummy node to handle the head swap
            ListNode* dummy = new ListNode(0);
            dummy->next = head;
            
            // prev points to the node before the current pair
            ListNode* prev = dummy;
            
            while (head && head->next) {
                // Identify the two nodes to be swapped
                ListNode* first = head;
                ListNode* second = head->next;
                
                // Perform the swap
                first->next = second->next;
                second->next = first;
                prev->next = second;
                
                // Move the pointers forward
                prev = first;  // The first node becomes the previous for the next pair
                head = first->next;  // Move to the next pair
            }
            
            // Return the new head, which is next of dummy node
            return dummy->next;
        }
    // Q2. Reorder List
        /*
        Q.2 -> 
        Given a singly linked list A

        A: A0  A1    An-1  An 
        reorder it to:

        A0  An  A1  An-1  A2  An-2   
        You must do this in-place without altering the nodes' values.

        Problem Constraints
            1 <= |A| <= 106

        Input Format
            The first and the only argument of input contains a pointer to the head of the linked list A.

        Output Format
            Return a pointer to the head of the modified linked list.

        Input 1:
            A = [1, 2, 3, 4, 5] 

        Output 1:
            [1, 5, 2, 4, 3]

        Input 2:   
            A = [1, 2, 3, 4] 

        Output 2:
            [1, 4, 2, 3]

        */

        // CODE
        /**
        * Definition for singly-linked list.
        * struct ListNode {
        *     int val;
        *     ListNode *next;
        *     ListNode(int x) : val(x), next(NULL) {}
        * };
        */

        ListNode* reverse(ListNode* head) {
            if (head->next == NULL) return head;

            ListNode* temp = head;
            ListNode* prev = NULL;

            while (temp != NULL) {
                ListNode* nxt = temp->next;
                temp->next = prev;
                prev = temp;
                temp = nxt;
            }
            return prev;
        }

        ListNode* Solution::reorderList(ListNode* A) {
            if (A->next == NULL || A->next->next == NULL) {
                return A;
            }

            // Step 1: Use slow and fast pointers to find the middle of the list
            ListNode* slow = A;
            ListNode* fast = A;

            while (fast->next != NULL && fast->next->next != NULL) {
                slow = slow->next;
                fast = fast->next->next;
            }

            // Step 2: Reverse the second half of the list
            ListNode* head2 = reverse(slow->next);

            // Step 3: Make the end of the first half point to NULL
            slow->next = NULL;

            ListNode* head1 = A;

            // Step 4: Merge the two halves
            ListNode* finalHead = new ListNode(-1); // Dummy node
            finalHead->next = A;
            ListNode* node = finalHead;
            bool flag = true;

            while (head2 != NULL) {
                if (flag) {
                    node->next = head1;
                    node = head1;
                    head1 = head1->next;
                    flag = false;
                } else {
                    node->next = head2;
                    node = head2;
                    head2 = head2->next;
                    flag = true;
                }
            }

            // If there are remaining nodes in the first half, attach them
            if (head1 != NULL) {
                node->next = head1;
            }

            return finalHead->next;
        }
    // Q3. Add Two Numbers as Lists
        /*
        Q.3 -> You are given two linked lists, A and B, representing two non-negative numbers.
        The digits are stored in reverse order, and each of their nodes contains a single digit.
        Add the two numbers and return it as a linked list.

        Problem Constraints
            1 <= |A|, |B| <= 105   

        Input Format
            The first argument of input contains a pointer to the head of linked list A.
            The second argument of input contains a pointer to the head of linked list B.

        Output Format
            Return a pointer to the head of the required linked list.

        Input 1:
            A = [2, 4, 3]
            B = [5, 6, 4]

        Output 1:
            [7, 0, 8]

        Input 2:
            A = [9, 9]
            B = [1]

        Output 2:
            [0, 0, 1]

        */

        // CODE
        /**
        * Definition for singly-linked list.
        * struct ListNode {
        *     int val;
        *     ListNode *next;
        *     ListNode(int x) : val(x), next(NULL) {}
        * };
        */
        ListNode* Solution::addTwoNumbers(ListNode* A, ListNode* B) {
            ListNode* dummy = new ListNode(-1);  // Dummy node to simplify the result list
            ListNode* curr = dummy;  // Pointer to build the new list
            int sum = 0, carry = 0;
            int x = 0, y = 0;

            // Loop until all nodes in both lists and any carry are processed
            while (A || B || carry) {
                x = A ? A->val : 0;  // Value from list A (0 if A is null)
                y = B ? B->val : 0;  // Value from list B (0 if B is null)
                sum = carry + x + y; // Calculate the sum

                carry = sum / 10;     // Calculate carry for the next iteration
                curr->next = new ListNode(sum % 10);  // Create a new node for the result
                curr = curr->next;    // Move to the next node in the result list

                if (A) A = A->next;   // Move to the next node in list A
                if (B) B = B->next;   // Move to the next node in list B
            }

            return dummy->next; // Return the next node of the dummy (head of the result list)
        }

## Problems & Doubly Linked List ##
    // Q1. Intersection of Linked Lists
        /*

        Q.1 -> 
        Write a program to find the node at which the intersection of two singly linked lists, A and B, begins. For example, the following two linked lists:

        A:          a1  a2
                        
                            c1  c2  c3
                        
        B:     b1  b2  b3

        NOTE:
        If the two linked lists have no intersection at all, return null.
        The linked lists must retain their original structure after the function returns.
        You may assume there are no cycles anywhere in the entire linked structure.
        Your code should preferably run in O(n) time and use only O(1) memory.
        The custom input to be given is different than the one explained in the examples. Please be careful.

        Problem Constraints
            0 <= |A|, |B| <= 106

        Input Format
            The first argument of input contains a pointer to the head of the linked list A.
            The second argument of input contains a pointer to the head of the linked list B.

        Output Format
            Return a pointer to the node after which the linked list is intersecting.

        Input 1:
            A = [1, 2, 3, 4, 5]
            B = [6, 3, 4, 5]

        Output 1:
            [3, 4, 5]

        Input 2:
            A = [1, 2, 3]
            B = [4, 5]

        Output 2:
            []

        */

        // CODE
        #include "solution.h"
        /**
        * Definition for singly-linked list.
        * struct ListNode {
        *     int val;
        *     ListNode *next;
        *     ListNode(int x) : val(x), next(NULL) {}
        * };
        */
        ListNode* Solution::getIntersectionNode(ListNode* A, ListNode* B) {
            if (A == nullptr || B == nullptr) return nullptr;
            
            ListNode* pA = A;
            ListNode* pB = B;
            
            // Traverse both lists
            while (pA != pB) {
                // Move to the next node in A, or if at the end, jump to the head of B
                pA = (pA == nullptr) ? B : pA->next;
                // Move to the next node in B, or if at the end, jump to the head of A
                pB = (pB == nullptr) ? A : pB->next;
            }
            
            // Either both are null (no intersection), or both are at the intersection point
            return pA;
        }
    // Q2. LRU Cache
        /*
        Q.2 -> 
        Design and implement a data structure for Least Recently Used (LRU) cache. It should support the following operations: get and set.

        get(key) - Get the value (will always be positive) of the key if the key exists in the cache, otherwise return -1.
        set(key, value) - Set or insert the value if the key is not already present. When the cache reaches its capacity, it should invalidate the least recently used item before inserting the new item.
        The LRUCache will be initialized with an integer corresponding to its capacity. Capacity indicates the maximum number of unique keys it can hold at a time.

        Definition of "least recently used" : An access to an item is defined as a get or a set operation of the item. "Least recently used" item is the one with the oldest access time.

        NOTE: If you are using any global variables, make sure to clear them in the constructor.

        Example :

        Input : 
                capacity = 2
                set(1, 10)
                set(5, 12)
                get(5)        returns 12
                get(1)        returns 10
                get(10)       returns -1
                set(6, 14)    this pushes out key = 5 as LRU is full. 
                get(5)        returns -1 
        Expected Output
        Enter your input as per the following guideline:
        There are 1 lines in the input

        Line 1 ( Corresponds to arg 1 ) : The line starts with a pair of number numOperations, capacity. capacity is the number your constructor is initialized with. 
        Then numOperation operations follow. 
        Each operation is either : 
        * G  : This corresponds to a function call get()
        * S   : This corresponds to a function call set(num1, num2)
        Note that the function calls are made in order.  


        */

        // CODE
        class Node {
            public:
                int key;
                int val;
                Node * prev;
                Node * next;
                Node(int key, int val) {
                    this -> key = key;
                    this -> val = val;
                    this -> prev = NULL;
                    this -> next = NULL;
                }
        };

        Node * head;
        Node * tail;
        int N;
        int MAX;
        map < int, Node * > mp;

        void remove_from_between(Node *x) {
            Node *temp = x->prev;
            temp->next = x->next;
            x->next->prev = temp;
        }

        void insert_at_end(Node* x) {
            Node *temp = tail->prev;
            x->next = tail;
            x->prev = temp;
            temp->next = x;
            tail->prev = x;
        }

        Node* remove_from_front() {
            Node *temp = head->next;
            remove_from_between(temp);
            return temp;
        }

        LRUCache::LRUCache(int capacity) {
            head = new Node(0, 0);
            tail = new Node(0, 0);
            head->next = tail;
            tail->prev = head;
            MAX = capacity;
            N = 0;
            mp.clear();
        }

        int LRUCache::get(int key) {
            if(mp.find(key) != mp.end()) {
                remove_from_between(mp[key]);
                insert_at_end(mp[key]);
                return mp[key]->val;
            }
            
            return -1;
        }

        void LRUCache::set(int key, int value) {
            //check if key exists or not
            
            if(mp.find(key) != mp.end()){
                remove_from_between(mp[key]);
                mp[key]->val = value;
                insert_at_end(mp[key]);
            }
            
            else { //key doesn't exist
                Node *newNode = new Node(key, value);
                mp.insert({key, newNode});
            
                if(MAX == N) {
                    Node *t = remove_from_front();
                    mp.erase(t->key);
                    insert_at_end(newNode);
                }
                else {
                    N++;
                    insert_at_end(newNode);
                }
            }
        }
    // Q3. Palindrome List
        /*
        Q.3 -> 
        Given a singly linked list A, determine if it's a palindrome. Return 1 or 0, denoting if it's a palindrome or not, respectively.

        Note :

        Problem Constraints
            1 <= |A| <= 105

        Input Format
            The first and the only argument of input contains a pointer to the head of the given linked list.

        Output Format
            Return 0, if the linked list is not a palindrome.
            Return 1, if the linked list is a palindrome.

        Input 1:
            A = [1, 2, 2, 1]

        Output 1:
            1

        Input 2:
            A = [1, 3, 2]


        Output 2:
            0

        */

        // CODE
        /**
        * Definition for singly-linked list.
        * struct ListNode {
        *     int val;
        *     ListNode *next;
        *     ListNode(int x) : val(x), next(NULL) {}
        * };
        */

        ListNode* reverseList(ListNode* head) {
            ListNode* prev = NULL;
            ListNode* curr = head;
            while (curr != NULL) {
                ListNode* nextNode = curr->next;
                curr->next = prev;
                prev = curr;
                curr = nextNode;
            }
            return prev;
        }

        int Solution::lPalin(ListNode* A) {
            if (A == NULL || A->next == NULL) {
                return 1; // A list with 0 or 1 node is a palindrome
            }
            
            // Step 1: Find the middle of the list
            ListNode* slow = A;
            ListNode* fast = A;
            
            while (fast != NULL && fast->next != NULL) {
                slow = slow->next;
                fast = fast->next->next;
            }
            
            // Step 2: Reverse the second half of the list
            ListNode* secondHalf = reverseList(slow);
            ListNode* firstHalf = A;
            
            // Step 3: Compare the first half and the reversed second half
            ListNode* tempSecondHalf = secondHalf;
            while (tempSecondHalf != NULL) {
                if (firstHalf->val != tempSecondHalf->val) {
                    return 0; // The list is not a palindrome
                }
                firstHalf = firstHalf->next;
                tempSecondHalf = tempSecondHalf->next;
            }
            
            // Step 4 (Optional): Restore the original list structure by reversing the second half back
            // reverseList(secondHalf);
            
            return 1; // The list is a palindrome
        }
    // Q1. Partition List
        /*
        Q.1 -> 
        Given a linked list A and a value B, partition it such that all nodes less than B come before nodes greater than or equal to B.
        You should preserve the original relative order of the nodes in each of the two partitions.

        Note :
            

        Problem Constraints
            1 <= |A| <= 106
            1 <= A[i], B <= 109

        Input Format
            The first argument of input contains a pointer to the head to the given linked list.
            The second argument of input contains an integer, B.   

        Output Format
            Return a pointer to the head of the modified linked list.

        Input 1:
            A = [1, 4, 3, 2, 5, 2]
            B = 3

        Output 1:
            [1, 2, 2, 4, 3, 5]

        Input 2:
            A = [1, 2, 3, 1, 3]
            B = 2

        Output 2:
            [1, 1, 2, 3, 3]

        */

        // CODE
        /**
        * Definition for singly-linked list.
        * struct ListNode {
        *     int val;
        *     ListNode *next;
        *     ListNode(int x) : val(x), next(NULL) {}
        * };
        */
        ListNode* Solution::partition(ListNode* A, int B) {
            // Initialize two dummy heads
            ListNode* lessHead = new ListNode(0);  // Dummy head for nodes less than B
            ListNode* greaterHead = new ListNode(0);  // Dummy head for nodes greater or equal to B
            
            ListNode* less = lessHead;  // Pointer for the 'less than B' list
            ListNode* greater = greaterHead;  // Pointer for the 'greater or equal to B' list
            
            ListNode* current = A;  // Start from the head of the input list
            
            // Traverse the list
            while (current != nullptr) {
                if (current->val < B) {
                    less->next = current;  // Add to the 'less' list
                    less = less->next;
                } else {
                    greater->next = current;  // Add to the 'greater' list
                    greater = greater->next;
                }
                current = current->next;  // Move to the next node
            }
            
            // Connect the two partitions
            greater->next = nullptr;  // End the 'greater' list
            less->next = greaterHead->next;  // Connect 'less' list to 'greater' list
            
            // Return the head of the new list
            ListNode* partitionedHead = lessHead->next;
            
            // Clean up dummy nodes
            delete lessHead;
            delete greaterHead;
            
            return partitionedHead;
        }
    // Q2. Longest Palindromic List
        /*
        Q.2 -> 
        Given a linked list of integers. Find and return the length of the longest palindrome list that exists in that linked list.
        A palindrome list is a list that reads the same backward and forward.
        Expected memory complexity : O(1)

        Note :
            

        Problem Constraints
            1 <= length of the linked list <= 2000
            1 <= Node value <= 100   

        Input Format
            The only argument given is head pointer of the linked list.

        Output Format
            Return the length of the longest palindrome list.

        Input 1:
            2 -> 3 -> 3 -> 3

        Output 1:
            3

        Input 2:
            2 -> 1 -> 2 -> 1 ->  2 -> 2 -> 1 -> 3 -> 2 -> 2

        Output 2:
            5

        */

        // CODE
        /**
        * Definition for singly-linked list.
        * struct ListNode {
        *     int val;
        *     ListNode *next;
        *     ListNode(int x) : val(x), next(NULL) {}
        * };
        */

        int palindromeLength(ListNode* it1, ListNode* it2) {
            int ans = 0;
            while (it1 != NULL && it2 != NULL && it1->val == it2->val) {
                ans += 2;
                it1 = it1->next;
                it2 = it2->next;
            }
            return ans;
        }

        int Solution::solve(ListNode* A) {
            // Base case: if the list is empty or has only one node
            if (A == NULL || A->next == NULL) {
                return (A == NULL) ? 0 : 1;
            }

            ListNode* temp = A;
            ListNode* prev = NULL;
            int ans = 0;

            // Traverse the list and reverse the first half while checking for palindromes
            while (temp->next != NULL) {
                ListNode* nxt = temp->next;
                ListNode* nxtnxt = temp->next->next;

                // Reverse the current node
                temp->next = prev;

                // Check for even-length palindromes
                int ans1 = palindromeLength(temp, nxt);

                // Check for odd-length palindromes
                int ans2 = 1 + palindromeLength(temp, nxtnxt);

                // Update the maximum palindrome length found
                ans = max(ans, max(ans1, ans2));

                // Continue reversing and moving forward
                prev = temp;
                temp = nxt;
            }

            return ans;
        }
    // Q3. Flatten a linked list
        /*
        Q.3 -> 
        Given a linked list where every node represents a linked list and contains two pointers of its type:
        Pointer to next node in the main list (right pointer)
        Pointer to a linked list where this node is head (down pointer). All linked lists are sorted.
        You are asked to flatten the linked list into a single list. Use down pointer to link nodes of the flattened list. The flattened linked list should also be sorted.

        Note :
            

        Problem Constraints
            1 <= Total nodes in the list <= 100000
            1 <= Value of node <= 109   

        Input Format
            The only argument given is head pointer of the doubly linked list.

        Output Format
            Return the head pointer of the Flattened list.

        Input 1:
        3 -> 4 -> 20 -> 20 ->30
        |    |    |     |    |
        7    11   22    20   31
        |               |    |
        7               28   39
        |               |
        8               39

        Output 1:
        3 -> 4 -> 7 -> 7 -> 8 -> 11 -> 20 -> 20 -> 20 -> 22 -> 28 -> 30 -> 31 -> 39 -> 39 

        Input 2:
        2 -> 4 
        |    |       
        7    11    
        |            
        7

        Output 2:
        2 -> 4 -> 7 -> 7 -> 11

        */

        // CODE
        /*
        struct ListNode {
            int val;
            ListNode *right,*down;
            ListNode(int x) {
                val = x;
                right = down = NULL;
            }
        };
        */

        // Helper function to merge two sorted linked lists using down pointers
        ListNode* mergeTwoLists(ListNode* a, ListNode* b) {
            if (a == NULL) return b;
            if (b == NULL) return a;

            ListNode* result;
            if (a->val < b->val) {
                result = a;
                result->down = mergeTwoLists(a->down, b);
            } else {
                result = b;
                result->down = mergeTwoLists(a, b->down);
            }
            return result;
        }

        ListNode* flatten (ListNode* root) {
            if (root == NULL || root->right == NULL) {
                return root;
            }

            // Recursively flatten the right list
            root->right = flatten(root->right);

            // Merge the current list (root->down) with the flattened right list
            root = mergeTwoLists(root, root->right);

            return root;
        }
## Linked List Extra ##
// Stacks & Queues
## Stack Required Syntax ##
    // Create a stack of integers
        stack<int> s;
    // Push elements onto the stack
        s.push(10);  // Stack: [10]
        s.push(20);  // Stack: [10, 20]
        s.push(30);  // Stack: [10, 20, 30]
    // Access the top element
        cout << "Top element: " << s.top() << endl;  // Output: 30
    // Pop the top element (removes 30)
        s.pop();  // Stack: [10, 20]
    // Check the size of the stack
        cout << "Stack size: " << s.size() << endl;  // Output: 2
    // Check if the stack is empty
        if (s.empty()) {
            cout << "Stack is empty" << endl;
        } else {
            cout << "Stack is not empty" << endl;  // Output: Stack is not empty
        }

## Implementation & Basic Problems ##
    // Implementation of Stack using Array
        class Stack {
        public:
            vector<int> arr; // Vector to hold stack elements
            void push(int value) {
                arr.push_back(value); // Add value to the end of the vector
            }

            bool isEmpty() {
                return arr.empty(); // Check if the vector is empty
            }

            void pop() {
                if (isEmpty()) {
                    cout << "Stack Underflow! Cannot pop from an empty stack." << endl;
                } else {
                    cout << "Popped " << arr.back() << " from the stack." << endl; // Get the last element
                    arr.pop_back(); // Remove the last element
                }
            }

            int top() {
                if (isEmpty()) {
                    cout << "Stack is empty." << endl;
                    return -1; // Return -1 if stack is empty
                } else {
                    return arr.back(); // Return the last element
                }
            }
        
            int size() {
                return arr.size(); // Return the number of elements in the vector
            }
        };
        
    // Implementation of Stack using Linked List
        struct Node {
            int data;        // Data to store in the node
            Node* next;     // Pointer to the next node in the stack

            Node(int value) : data(value), next(nullptr) {} // Constructor
        };

        class Stack {
        private:
            Node* top; // Pointer to the top node of the stack
            int size = 0;
        public:
            // Constructor to initialize the stack
            Stack() : top(nullptr) {}

            // Destructor to clean up the stack
            ~Stack() {
                while (!isEmpty()) {
                    pop(); // Pop all elements
                }
            }

            void push(int value) {
                Node* newNode = new Node(value); // Create a new node
                newNode->next = top; // Point new node to current top
                top = newNode; // Update top to new node
                size++;
            }

            bool isEmpty() {
                return top == nullptr; // Check if top is nullptr
            }

            void pop() {
                if (isEmpty()) {
                    cout << "Stack Underflow! Cannot pop from an empty stack." << endl;
                } else {
                    Node* temp = top; // Get the current top node
                    cout << "Popped " << top->data << " from the stack." << endl; // Output top data
                    top = top->next; // Update top to the next node
                    delete temp; // Free memory of the popped node
                    size--;
                }
            }

            int top() {
                if (isEmpty()) {
                    cout << "Stack is empty." << endl;
                    return -1; // Return -1 if stack is empty
                } else {
                    return top->data; // Return data of the top node
                }
            }

            int size() {
                return size; // Return total count
            }
        };
    // Q1. Passing game
        /*
        Q.1 -> There is a football event going on in your city. In this event, you are given A passes and players having ids between 1 and 106.
        Initially, some player with a given id had the ball in his possession. You have to make a program to display the id of the player who possessed the ball after exactly A passes.
        There are two kinds of passes:
        1) ID
        2) 0
        For the first kind of pass, the player in possession of the ball passes the ball "forward" to the player with id = ID.
        For the second kind of pass, the player in possession of the ball passes the ball back to the player who had forwarded the ball to him.
        In the second kind of pass "0" just means Back Pass.
        Return the ID of the player who currently possesses the ball.

        Note :
            

        Problem Constraints
            1 <= A <= 100000
            1 <= B <= 100000

        |C| = A

        Input Format
            The first argument of the input contains the number A.
            The second argument of the input contains the number B ( id of the player possessing the ball in the very beginning).
            The third argument is an array C of size A having (ID/0). 

        Output Format
            Return the "ID" of the player who possesses the ball after A passes.

        Input 1:
            A = 10
            B = 23
            C = [86, 63, 60, 0, 47, 0, 99, 9, 0, 0]

        Output 1:
            63

        Input 2:
            A = 1
            B = 1
            C = [2]

        Output 2:
            2

        Example Explanation
            Initially, Player having  id = 23  posses ball. 
            After pass  1,  Player having  id = 86  posses ball. 
            After pass  2,  Player having  id = 63  posses ball. 
            After pass  3,  Player having  id = 60  posses ball. 
            After pass  4,  Player having  id = 63  posses ball. 
            After pass  5,  Player having  id = 47  posses ball. 
            After pass  6,  Player having  id = 63  posses ball. 
            After pass  7,  Player having  id = 99  posses ball. 
            After pass  8,  Player having  id = 9   posses ball. 
            After pass  9,  Player having  id = 99  posses ball. 
            After pass  10, Player having  id = 63   posses ball.
        */

        // CODE
        int Solution::solve(int A, int B, vector<int> &C) {

            std::stack<int> s;
            s.push(B);
            for (int i=0; i<A; i++){
                
                if(C[i] == 0){
                    s.pop();
                }else{
                    s.push(C[i]);
                }
            }

            return s.top();
        }
    // Q2. Balanced Paranthesis
        /*
        Q.2 -> Given an expression string A, examine whether the pairs and the orders of {,}, (,), [,] are correct in A.
            Refer to the examples for more clarity.

        Note :
            
        Problem Constraints
            1 <= |A| <= 100

        Input Format
            The first and the only argument of input contains the string A having the parenthesis sequence.   

        Output Format
            Return 0 if the parenthesis sequence is not balanced.
            Return 1 if the parenthesis sequence is balanced.

        Input 1:
            A = {([])}

        Output 1:
            1

        Input 2:
            A = (){

        Output 2:
            0

        Input 3:
            A = ()[] 

        Output 3:
            1

        */

        // CODE
        int Solution::solve(string A) {

            stack<char> s;
            for (int i=0; i<A.size(); i++){
                if(A[i] == ')'){
                    if(!s.empty() && s.top() == '('){
                        s.pop();
                    }else{
                        return 0;
                    }
                }else if(A[i] == ']'){
                    if(!s.empty() && s.top() == '['){
                        s.pop();
                    }else{
                        return 0;
                    }
                }else if(A[i] == '}'){
                    if(!s.empty() && s.top() == '{'){
                        s.pop();
                    }else{
                        return 0;
                    }
                }else{
                    s.push(A[i]);
                }
            }

            if(s.empty()){
                return 1;
            }else{
                return 0;
            }
        }
    // Q3. Double Character Trouble
        /*
        Q.3 -> You have a string, denoted as A.
        To transform the string, you should perform the following operation repeatedly:
        Identify the first occurrence of consecutive identical pairs of characters within the string.
        Remove this pair of identical characters from the string.
        Repeat steps 1 and 2 until there are no more consecutive identical pairs of characters.
        The final result will be the transformed string.

        Note :

        Problem Constraints
            1 <= |A| <= 100000

        Input Format
            First and only argument is string A.    

        Output Format
            Return the final string.

        Input 1:
            A = "abccbc"

        Output 1:
            "ac"

        Input 2:
            A = "ab"

        Output 2:
            "ab"

        */

        // CODE
        string Solution::solve(string A) {
            stack<char> s;
            for (int i = 0; i < A.size(); i++) {
                if (!s.empty() && s.top() == A[i]) {
                    s.pop();
                } else {
                    s.push(A[i]);
                }
            }

            // Efficiently build the result by appending characters and then reversing
            string result;
            result.reserve(s.size());
            while (!s.empty()) {
                result.push_back(s.top());
                s.pop();
            }

            // Reverse the string to get the correct order
            reverse(result.begin(), result.end());

            return result;
        }
    // Q4. Evaluate Expression
        /*
        Q.4 ->An arithmetic expression is given by a string array A of size N. Evaluate the value of an arithmetic expression in Reverse Polish Notation.
        Valid operators are +, -, *, /. Each string may be an integer or an operator.

        Note: Reverse Polish Notation is equivalent to Postfix Expression, where operators are written after their operands. 

        Problem Constraints
            1 <= N <= 105

        Input Format
            The only argument given is string array A.

        Output Format
            Return the value of arithmetic expression formed using reverse Polish Notation.

        Input 1:
            A =   ["2", "1", "+", "3", "*"]

        Output 1:
            9

        Input 2:
            A = ["4", "13", "5", "/", "+"]

        Output 2:
            6

        */

        // CODE
        int Solution::evalRPN(vector<string> &A) {

            std::stack<int> s;

            for (const auto &token : A) {
                if (token == "+" || token == "-" || token == "*" || token == "/") {
                    // Pop the top two elements for the operation
                    int b = s.top(); s.pop();
                    int a = s.top(); s.pop();

                    // Apply the operator and push the result back onto the stack
                    if (token == "+") {
                        s.push(a + b);
                    } else if (token == "-") {
                        s.push(a - b);
                    } else if (token == "*") {
                        s.push(a * b);
                    } else if (token == "/") {
                        if (b == 0) throw std::runtime_error("Division by zero");
                        s.push(a / b);
                    }
                } else {
                    // If the token is a number, push it onto the stack
                    s.push(std::stoi(token));
                }
            }

            // The final result will be the only element in the stack
            return s.top();
            
        }
    // Q5. Infix to Postfix
        /*
        Q.5 -> Given string A denoting an infix expression. Convert the infix expression into a postfix expression.
        String A consists of ^, /, *, +, -, (, ) and lowercase English alphabets where lowercase English alphabets are operands and ^, /, *, +, - are operators.
        Find and return the postfix expression of A.

        NOTE:
            ^ has the highest precedence.
            / and * have equal precedence but greater than + and -.
            + and - have equal precedence and lowest precedence among given operators.

        Problem Constraints
            1 <= length of the string <= 500000

        Input Format
            The only argument given is string A.  

        Output Format
            Return a string denoting the postfix conversion of A.

        Input 1:
            A = "x^y/(a*z)+b"

        Output 1:
            "xy^az* /b+"

        Input 2:
            A = "a+b*(c^d-e)^(f+g*h)-i"

        Output 2:
            "abcd^e-fgh*+^*+i-"

        */

        // CODE
        string Solution::solve(string A) {

            string ans;
            stack<char> s;
            map<char, int> mp;
            mp['^'] = 3; // Exponentiation
            mp['*'] = 2; // Multiplication
            mp['/'] = 2; // Division
            mp['+'] = 1; // Addition
            mp['-'] = 1; // Subtraction
            mp['('] = 0; // Left parenthesis
            mp[')'] = 0; // Right parenthesis

            for (char c : A) {
                // Operand condition
                if (mp.count(c) == 0) {
                    ans += c;
                }
                // Left parenthesis
                else if (c == '(') {
                    s.push(c);
                }
                // Right parenthesis
                else if (c == ')') {
                    while (!s.empty() && s.top() != '(') {
                        ans += s.top();
                        s.pop();
                    }
                    s.pop(); // Pop the '('
                }
                // Operator condition
                else {
                    while (!s.empty() && mp[s.top()] >= mp[c]) {
                        ans += s.top();
                        s.pop();
                    }
                    s.push(c);
                }
            }

            // Pop all remaining operators in the stack
            while (!s.empty()) {
                ans += s.top();
                s.pop();
            }

            return ans;
        }
    // Q1. Min Stack
        /*
        Q.1 -> Design a stack that supports push, pop, top, and retrieve the minimum element in constant time.
        push(x) -- Push element x onto stack.
        pop() -- Removes the element on top of the stack.
        top() -- Get the top element.
        getMin() -- Retrieve the minimum element in the stack.

        NOTE:
            All the operations have to be constant time operations.
            getMin() should return -1 if the stack is empty.
            pop() should return nothing if the stack is empty.
            top() should return -1 if the stack is empty.

        Problem Constraints
            1 <= Number of Function calls <= 10^7

        Input Format
            Functions will be called by the checker code automatically.   

        Output Format
            Each function should return the values as defined by the problem statement.

        Input 1:
            push(1)
            push(2)
            push(-2)
            getMin()
            pop()
            getMin()
            top()

        Output 1:
            -2 1 2
            
        Input 2:
            getMin()
            pop()
            top()

        Output 2:
            -1 -1

        */

        // CODE
        stack<int>s;
        int min_ele;

        MinStack::MinStack() {
            min_ele = INT_MAX;
            while(!s.empty()) s.pop();
        }

        void MinStack::push(int x) {
            if(s.empty()){
                s.push(x);
                min_ele = x;
            }else{
                if(x<min_ele){
                    s.push(2*x-min_ele);
                    min_ele = x;
                }else{
                    s.push(x);
                }
            }
        }

        void MinStack::pop() {
            if(s.empty()){
                return;
            } 
            int top = s.top();
            if(top < min_ele){
                int last_min = 2*min_ele- top;
                min_ele = last_min;
                s.pop();
                return;
            }else{
                s.pop();
                return;
            }
        }

        int MinStack::top() {
            if(s.empty()){
                return -1;
            }
            int top = s.top();
            if(top < min_ele){
                return min_ele;
            }else{
                return top;
            }
        }

        int MinStack::getMin() {
            if(s.empty()){
                return -1;
            }
            return min_ele;
        }
    // Q2. Redundant Braces
        /*
        Q.2 -> Given a string A denoting an expression. It contains the following operators '+', '-', '*', '/'.
        Check whether A has redundant braces or not.

        NOTE: A will be always a valid expression and will not contain any white spaces.

        Problem Constraints
            1 <= |A| <= 10^5

        Input Format
            The only argument given is string A.    

        Output Format
            Return 1 if A has redundant braces else, return 0.

        Input 1:
            A = "((a+b))"

        Output 1:
            1

        Input 2:
            A = "(a+(a+b))"

        Output 2:
            0

        */

        // CODE
        int Solution::braces(string A) {
            stack<char> st;  // Stack to keep track of characters

            for (char ch : A) {
                
                if (ch == ')') {
                    bool hasOperator = false;

                    // Pop elements until we find the corresponding '('
                    while (!st.empty() && st.top() != '(') {
                        if (st.top() == '+' || st.top() == '-' || st.top() == '*' || st.top() == '/') {
                            hasOperator = true;
                        }
                        st.pop();
                    }

                    // Pop the '('
                    if (!st.empty()) st.pop();

                    // If no operator was found between the braces, they are redundant
                    if (!hasOperator) {
                        return 1;
                    }
                } else {
                    // Push all characters onto the stack
                    st.push(ch);
                }
            }

            // If no redundant braces were found
            return 0;
        }
    // Q3. Check two bracket expressions
        /*
        Q.3 -> Given two strings A and B. Each string represents an expression consisting of lowercase English alphabets, '+', '-', '(' and ')'.
        The task is to compare them and check if they are similar. If they are identical, return 1 else, return 0.

        NOTE: It may be assumed that there are at most 26 operands from a to z, and every operand appears only once.

        Problem Constraints
            1 <= length of the each String <= 100

        Input Format
            The given arguments are string A and string B.

        Output Format
            Return 1 if they represent the same expression else return 0.

        Input 1:
            A = "-(a+b+c)"
            B = "-a-b-c"

        Output 1:
            1

        Input 2:
            A = "a-b-(c-d)"
            B = "a-b-c-d"

        Output 2:
            0

        */

        // CODE
        vector<int > check( string t){
            vector<int> res(26,0);
            stack<bool> s;  s.push(true);
            for(int i=0;i<t.size();i++){
                char c=t[i];
                if(c== '+' || c=='-') continue;
                else if( c =='(' && i>0){
                    if(t[i-1]=='-')     s.push(!s.top());
                    else                s.push(s.top());
                }else if( c>='a' && c<='z'){
                    if(i>0 && t[i-1]=='-')  res[c-'a']=s.top()? -1:1;
                    else                    res[c-'a']=s.top()? 1:-1;
                }else if(c==')')    s.pop();
            }return res;
        }

        int Solution::solve(string A, string B) {
            vector<int>vec1=check(A);
            vector<int>vec2=check(B);
            if(vec1 == vec2) return 1;
            return 0;
        }
## Nearest Smaller/Greater Element ##
    // Q1. Nearest Smaller Element
        /*
        Q.1 -> Given an array A, find the nearest smaller element G[i] for every element A[i] in the array such that the element has an index smaller than i.
        More formally,
        G[i] for an element A[i] = an element A[j] such that
        j is maximum possible AND
        j < i AND
        A[j] < A[i]
        Elements for which no smaller element exist, consider the next smaller element as -1.

        Note :

        Problem Constraints
            1 <= |A| <= 100000
            -10^9 <= A[i] <= 10^9

        Input Format
            The only argument given is integer array A.    

        Output Format
            Return the integar array G such that G[i] contains the nearest smaller number than A[i]. If no such element occurs G[i] should be -1.

        Input 1:
            A = [4, 5, 2, 10, 8]

        Output 1:
            [-1, 4, -1, 2, 2]

        Input 2:
            A = [3, 2, 1]

        Output 2:
            [-1, -1, -1]

        */

        // CODE
        vector<int> Solution::prevSmaller(vector<int> &A) {

            vector<int> result(A.size(), -1);  // Initialize result with -1
            stack<int> s;  // Stack to store indices of array elements

            for (int i = 0; i < A.size(); ++i) {
                // While stack is not empty and the element at stack top is not smaller than A[i]
                while (!s.empty() && A[s.top()] >= A[i]) {
                    s.pop();
                }
                
                // If stack is not empty, the top of the stack is the index of the nearest smaller element
                if (!s.empty()) {
                    result[i] = A[s.top()];
                }
                
                // Push the current index onto the stack
                s.push(i);
            }

            return result;
            
        }
    // Q2. Largest Rectangle in Histogram
        /*
        Q.2 -> Given an array of integers A.
        A represents a histogram i.e A[i] denotes the height of the ith histogram's bar. Width of each bar is 1.
        Find the area of the largest rectangle formed by the histogram.

        Note :

        Problem Constraints
            1 <= |A| <= 100000
            1 <= A[i] <= 10000

        Input Format
            The only argument given is the integer array A.

        Output Format
            Return the area of the largest rectangle in the histogram.

        Input 1:
            A = [2, 1, 5, 6, 2, 3]

        Output 1:
            10

        Input 2:
            A = [2]

        Output 2:
            2

        */

        // CODE
        int Solution::largestRectangleArea(vector<int> &A) {
            stack<int> s;  // Stack to store indices of histogram bars
            int maxArea = 0;
            int i = 0;
            
            while (i < A.size()) {
                // If this bar is higher than the bar at stack top, push it to the stack
                if (s.empty() || A[i] >= A[s.top()]) {
                    s.push(i++);
                } else {
                    // Calculate the area of the rectangle with the bar at the top of the stack as the smallest (height) bar
                    int height = A[s.top()];
                    s.pop();
                    // Width is i if the stack is empty, otherwise width is the difference between the current index and the index from the stack
                    int width = s.empty() ? i : i - s.top() - 1;
                    maxArea = max(maxArea, height * width);
                }
            }
            
            // Process the remaining bars in the stack
            while (!s.empty()) {
                int height = A[s.top()];
                s.pop();
                int width = s.empty() ? i : i - s.top() - 1;
                maxArea = max(maxArea, height * width);
            }
            
            return maxArea;
        }
    // Q3. MAX and MIN
        /*
        Q.3 -> Given an array of integers A.
        The value of an array is computed as the difference between the maximum element in the array and the minimum element in the array A.
        Calculate and return the sum of values of all possible subarrays of A modulo 10^9+7.

        Note :

        Problem Constraints
            1 <= |A| <= 100000
            1 <= A[i] <= 1000000

        Input Format
            The first and only argument given is the integer array A. 

        Output Format
            Return the sum of values of all possible subarrays of A modulo 10^9+7.

        Input 1:
            A = [1]

        Output 1:
            0

        Input 2:
            A = [4, 7, 3, 8]

        Output 2:
            26

        Explanation 2:

        value ( [4] ) = 4 - 4 = 0
        value ( [7] ) = 7 - 7 = 0
        value ( [3] ) = 3 - 3 = 0
        value ( [8] ) = 8 - 8 = 0
        value ( [4, 7] ) = 7 - 4 = 3
        value ( [7, 3] ) = 7 - 3 = 4
        value ( [3, 8] ) = 8 - 3 = 5
        value ( [4, 7, 3] ) = 7 - 3 = 4
        value ( [7, 3, 8] ) = 8 - 3 = 5
        value ( [4, 7, 3, 8] ) = 8 - 3 = 5
        sum of values % 10^9+7 = 26

        */

        // CODE
        const int MOD = 1000000007;

        // Function to find the next greater element for each element
        vector<int> findNextGreater(const vector<int>& A) {
            int n = A.size();
            vector<int> nextGreater(n, n);
            stack<int> s;
            
            for (int i = 0; i < n; ++i) {
                while (!s.empty() && A[s.top()] < A[i]) {
                    nextGreater[s.top()] = i;
                    s.pop();
                }
                s.push(i);
            }
            
            return nextGreater;
        }

        // Function to find the previous greater element for each element
        vector<int> findPrevGreater(const vector<int>& A) {
            int n = A.size();
            vector<int> prevGreater(n, -1);
            stack<int> s;
            
            for (int i = n - 1; i >= 0; --i) {
                while (!s.empty() && A[s.top()] <= A[i]) {
                    prevGreater[s.top()] = i;
                    s.pop();
                }
                s.push(i);
            }
            
            return prevGreater;
        }

        // Function to find the next smaller element for each element
        vector<int> findNextSmaller(const vector<int>& A) {
            int n = A.size();
            vector<int> nextSmaller(n, n);
            stack<int> s;
            
            for (int i = 0; i < n; ++i) {
                while (!s.empty() && A[s.top()] > A[i]) {
                    nextSmaller[s.top()] = i;
                    s.pop();
                }
                s.push(i);
            }
            
            return nextSmaller;
        }

        // Function to find the previous smaller element for each element
        vector<int> findPrevSmaller(const vector<int>& A) {
            int n = A.size();
            vector<int> prevSmaller(n, -1);
            stack<int> s;
            
            for (int i = n - 1; i >= 0; --i) {
                while (!s.empty() && A[s.top()] >= A[i]) {
                    prevSmaller[s.top()] = i;
                    s.pop();
                }
                s.push(i);
            }
            
            return prevSmaller;
        }

        int Solution::solve(vector<int> &A) {
            int n = A.size();
            
            vector<int> nextGreater = findNextGreater(A);
            vector<int> prevGreater = findPrevGreater(A);
            vector<int> nextSmaller = findNextSmaller(A);
            vector<int> prevSmaller = findPrevSmaller(A);
            
            long long totalSum = 0;
            
            for (int i = 0; i < n; ++i) {
                long long maxContribution = (long long)(i - prevGreater[i]) * (nextGreater[i] - i) % MOD;
                long long minContribution = (long long)(i - prevSmaller[i]) * (nextSmaller[i] - i) % MOD;
                totalSum = (totalSum + A[i] * maxContribution - A[i] * minContribution + MOD) % MOD;
            }
            
            return static_cast<int>(totalSum);
        }
    // Q4. Next Greater
        /*
        Q.4 -> Given an array A, find the next greater element G[i] for every element A[i] in the array.
        The next greater element for an element A[i] is the first greater element on the right side of A[i] in the array, A.

        More formally:

        G[i] for an element A[i] = an element A[j] such that 
            j is minimum possible AND 
            j > i AND
            A[j] > A[i]
        Elements for which no greater element exists, consider the next greater element as -1.

        Note :

        Problem Constraints
            1 <= |A| <= 10^5
            1 <= A[i] <= 10^7

        Input Format
            The first and the only argument of input contains the integer array, A.

        Output Format
            Return an integer array representing the next greater element for each index in A.

        Input 1:
            A = [4, 5, 2, 10] 

        Output 1:
            [5, 10, 10, -1] 

        Input 2:
            A = [3, 2, 1] 

        Output 2:
            [-1, -1, -1] 

        */

        // CODE
        vector<int> Solution::nextGreater(vector<int> &A) {

            int n = A.size();
            vector<int> result(n, -1);  // Initialize result with -1
            stack<int> s;  // Stack to store indices of array elements
            
            for (int i = 0; i < n; ++i) {
                // While stack is not empty and the current element is greater than the element corresponding to the index at the top of the stack
                while (!s.empty() && A[i] > A[s.top()]) {
                    result[s.top()] = A[i];  // Update the result for index at the top of the stack
                    s.pop();  // Remove the index from the stack
                }
                s.push(i);  // Push current index onto the stack
            }
            
            // Elements remaining in the stack do not have a next greater element
            while (!s.empty()) {
                result[s.top()] = -1;  // Set next greater element as -1
                s.pop();  // Remove the index from the stack
            }
            
            return result;
        }
    // Q1. Max Rectangle in Binary Matrix
        /*
        Q.1 -> Given a 2-D binary matrix A of size N x M filled with 0's and 1's, find the largest rectangle containing only ones and return its area.

        Note :
            

        Problem Constraints
            1 <= N, M <= 100

        Input Format
            The first argument is a 2-D binary array A. 

        Output Format
            Return an integer denoting the area of the largest rectangle containing only ones.

        Input 1:
            A = [
                    [1, 1, 1]
                    [0, 1, 1]
                    [1, 0, 0] 
                ]

        Output 1:
            4

        Input 2:
            A = [
                    [0, 1, 0]
                    [1, 1, 1]
                ]

        Output 2:
            3

        */

        // CODE
        // Helper function to find the largest rectangle area in a histogram
        int largestRectangleArea(const vector<int>& heights) {
            stack<int> st;
            int maxArea = 0;
            int index = 0;
            
            while (index < heights.size()) {
                if (st.empty() || heights[st.top()] <= heights[index]) {
                    st.push(index++);
                } else {
                    int topOfStack = st.top();
                    st.pop();
                    int area = heights[topOfStack] * (st.empty() ? index : index - st.top() - 1);
                    maxArea = max(maxArea, area);
                }
            }
            
            while (!st.empty()) {
                int topOfStack = st.top();
                st.pop();
                int area = heights[topOfStack] * (st.empty() ? index : index - st.top() - 1);
                maxArea = max(maxArea, area);
            }
            
            return maxArea;
        }


        int Solution::maximalRectangle(vector<vector<int> > &A) {
            if (A.empty() || A[0].empty()) return 0;
            
            int rows = A.size();
            int cols = A[0].size();
            vector<int> height(cols, 0);
            int maxRectangle = 0;
            
            for (int i = 0; i < rows; ++i) {
                for (int j = 0; j < cols; ++j) {
                    height[j] = (A[i][j] == 0) ? 0 : height[j] + 1;
                }
                maxRectangle = max(maxRectangle, largestRectangleArea(height));
            }
            
            return maxRectangle;
        }
    // Q2. Sort stack using another stack
        /*
        Q.2 -> Given a stack of integers A, sort it using another stack.
        Return the array of integers after sorting the stack using another stack.

        Note :
            

        Problem Constraints
            1 <= |A| <= 5000
            0 <= A[i] <= 109

        Input Format
            The only argument is a stack given as an integer array A.   

        Output Format
            Return the array of integers after sorting the stack using another stack.

        Input 1:
            A = [5, 4, 3, 2, 1]

        Output 1:
            [1, 2, 3, 4, 5]

        Input 2:
            A = [5, 17, 100, 11]

        Output 2:
            [5, 11, 17, 100]

        */

        // CODE
        vector<int> Solution::solve(vector<int> &A) {
            stack<int> inputStack, tempStack;
            vector<int> result;
            
            // Push all elements from the vector into the inputStack
            for (int num : A) {
                inputStack.push(num);
            }
            
            // Sort the stack using the tempStack
            while (!inputStack.empty()) {
                int current = inputStack.top();
                inputStack.pop();
                
                // Move elements from tempStack to inputStack if they are greater than the current element
                while (!tempStack.empty() && tempStack.top() > current) {
                    inputStack.push(tempStack.top());
                    tempStack.pop();
                }
                
                // Push the current element onto tempStack
                tempStack.push(current);
            }
            
            // Transfer sorted elements from tempStack to result vector (this will be in ascending order)
            while (!tempStack.empty()) {
                result.push_back(tempStack.top());
                tempStack.pop();
            }

            // Reverse the result vector to get ascending order
            reverse(result.begin(), result.end());
            
            return result;
        }
## Queue Required Syntax ##
    #include <queue> 
    // Create a queue of integers
        queue<int> q;
    // Enqueue (push) elements into the queue
        q.push(10); // Queue: [10]
        q.push(20); // Queue: [10, 20]
        q.push(30); // Queue: [10, 20, 30]
    // Access the front element
        cout << "Front element: " << q.front() << endl;  // Output: 10
    // Access the back element
        cout << "Back element: " << q.back() << endl;    // Output: 30
    // Dequeue (pop) the front element
        q.pop();  // Queue: [20, 30]
    // Check the size of the queue
        cout << "Queue size: " << q.size() << endl;  // Output: 2
    // Check if the queue is empty
        if (q.empty()) {
            cout << "Queue is empty" << endl;
        } else {
            cout << "Queue is not empty" << endl;  // Output: Queue is not empty
        }
## Implementation & Problems ##
    // Implementation of Queue using Arrays
        class Queue {
        private:
            int *arr;          // Array to store queue elements
            int front;         // Front pointer
            int rear;          // Rear pointer
            int capacity;      // Maximum capacity of the queue
            int currentSize;   // Current size of the queue

        public:
            // Constructor to initialize the queue
            Queue(int size) {
                arr = new int[size];
                capacity = size;
                front = 0;
                rear = -1;
                currentSize = 0;
            }

            // Destructor to free allocated memory
            ~Queue() {
                delete[] arr;
            }

            // Function to add an element to the queue (Enqueue operation)
            void enqueue(int element) {
                if (isFull()) {
                    cout << "Queue is full. Cannot enqueue " << element << endl;
                    return;
                }
                rear = (rear + 1) % capacity;  // Circular increment
                arr[rear] = element;
                currentSize++;
                cout << "Enqueued " << element << endl;
            }

            // Function to remove an element from the queue (Dequeue operation)
            void dequeue() {
                if (isEmpty()) {
                    cout << "Queue is empty. Cannot dequeue." << endl;
                    return;
                }
                cout << "Dequeued " << arr[front] << endl;
                front = (front + 1) % capacity;  // Circular increment
                currentSize--;
            }

            // Function to get the front element of the queue
            int getFront() {
                if (isEmpty()) {
                    cout << "Queue is empty." << endl;
                    return -1;
                }
                return arr[front];
            }

            // Function to check if the queue is empty
            bool isEmpty() {
                return (currentSize == 0);
            }

            // Function to check if the queue is full
            bool isFull() {
                return (currentSize == capacity);
            }

            // Function to get the size of the queue
            int size() {
                return currentSize;
            }
        };
    // Implementation of Queue using Vectors (Dequeue O(N))
        class Queue {
        private:
            vector<int> arr;  // Vector to store queue elements

        public:
            // Function to add an element to the queue (Enqueue operation)
            void enqueue(int element) {
                arr.push_back(element);
                cout << "Enqueued " << element << endl;
            }

            // Function to remove an element from the queue (Dequeue operation)
            void dequeue() {
                if (isEmpty()) {
                    cout << "Queue is empty. Cannot dequeue." << endl;
                    return;
                }
                cout << "Dequeued " << arr.front() << endl;
                arr.erase(arr.begin());  // Removes the first element
            }

            // Function to get the front element of the queue
            int getFront() {
                if (isEmpty()) {
                    cout << "Queue is empty." << endl;
                    return -1;
                }
                return arr.front();
            }

            // Function to check if the queue is empty
            bool isEmpty() {
                return arr.empty();
            }

            // Function to get the size of the queue
            int size() {
                return arr.size();
            }
        };
    // Implementation of Queue using Linked List
        struct Node {
            int data;
            Node* next;
            Node(int val) : data(val), next(nullptr) {}
        };

        class Queue {
        private:
            Node* front;  // Front pointer to the first element
            Node* rear;   // Rear pointer to the last element
            int currentSize;

        public:
            // Constructor to initialize an empty queue
            Queue() : front(nullptr), rear(nullptr), currentSize(0) {}

            // Function to add an element to the queue (Enqueue operation)
            void enqueue(int element) {
                Node* newNode = new Node(element);  // Create a new node
                if (rear == nullptr) {  // If queue is empty, front and rear both point to new node
                    front = rear = newNode;
                } else {
                    rear->next = newNode;  // Link the old rear to the new node
                    rear = newNode;        // Update the rear to point to the new node
                }
                currentSize++;
                cout << "Enqueued " << element << endl;
            }

            // Function to remove an element from the queue (Dequeue operation)
            void dequeue() {
                if (isEmpty()) {
                    cout << "Queue is empty. Cannot dequeue." << endl;
                    return;
                }
                Node* temp = front;      // Temporarily store the front node
                front = front->next;     // Move front to the next node
                if (front == nullptr) {  // If queue becomes empty, set rear to nullptr as well
                    rear = nullptr;
                }
                cout << "Dequeued " << temp->data << endl;
                delete temp;  // Free memory of dequeued node
                currentSize--;
            }

            // Function to get the front element of the queue
            int getFront() {
                if (isEmpty()) {
                    cout << "Queue is empty." << endl;
                    return -1;
                }
                return front->data;
            }

            // Function to get the rear element of the queue
            int getRear() {
                if (isEmpty()) {
                    cout << "Queue is empty." << endl;
                    return -1;
                }
                return rear->data;
            }

            // Function to check if the queue is empty
            bool isEmpty() {
                return front == nullptr;
            }

            // Function to get the size of the queue
            int size() {
                return currentSize;
            }

            // Destructor to free allocated memory
            ~Queue() {
                while (!isEmpty()) {
                    dequeue();
                }
            }
        };
    // Implementation of Queue using 2 Stacks
        class Queue {
        private:
            stack<int> stack1;  // Stack used for enqueue operations
            stack<int> stack2;  // Stack used for dequeue operations

            // Helper function to transfer elements from stack1 to stack2
            void transferStack1ToStack2() {
                while (!stack1.empty()) {
                    stack2.push(stack1.top());
                    stack1.pop();
                }
            }

        public:
            // Function to add an element to the queue (Enqueue operation)
            void enqueue(int element) {
                stack1.push(element);
                cout << "Enqueued " << element << endl;
            }

            // Function to remove an element from the queue (Dequeue operation)
            void dequeue() {
                if (isEmpty()) {
                    cout << "Queue is empty. Cannot dequeue." << endl;
                    return;
                }
                if (stack2.empty()) {  // Transfer only if stack2 is empty
                    transferStack1ToStack2();
                }
                cout << "Dequeued " << stack2.top() << endl;
                stack2.pop();
            }

            // Function to get the front element of the queue
            int getFront() {
                if (isEmpty()) {
                    cout << "Queue is empty." << endl;
                    return -1;
                }
                if (stack2.empty()) {
                    transferStack1ToStack2();
                }
                return stack2.top();
            }

            // Function to check if the queue is empty
            bool isEmpty() {
                return stack1.empty() && stack2.empty();
            }
        };
    // find the nth number using digits 1 & 2
        std::queue<std::string> q;
        q.push("1");
        q.push("2");

        std::string current;
        for (int i = 0; i < n; ++i) {
            current = q.front();
            q.pop();

            // Generate next numbers by appending "1" and "2"
            q.push(current + "1");
            q.push(current + "2");
        }

        return current;

    // Doubly ended Queue
        std::deque<int> dq;

        // Insert elements at both ends
        dq.push_back(1);    // Insert at back
        dq.push_front(2);   // Insert at front

        // Access front and back elements
        std::cout << "Front: " << dq.front() << std::endl;
        std::cout << "Back: " << dq.back() << std::endl;

        // Remove elements from both ends
        dq.pop_front();
        dq.pop_back();

        if (dq.empty()) {
            std::cout << "Deque is empty!" << std::endl;
        }

        return 0;
    // Sliding Window Maximum
        std::vector<int> slidingWindowMaximum(const std::vector<int>& nums, int k) {
            std::deque<int> dq;
            std::vector<int> result;

            for (int i = 0; i < nums.size(); ++i) {
                // Remove indices of elements not in the current window
                if (!dq.empty() && dq.front() == i - k) {
                    dq.pop_front();
                }

                // Remove elements smaller than the current element from the deque
                while (!dq.empty() && nums[dq.back()] <= nums[i]) {
                    dq.pop_back();
                }

                // Add the current element index
                dq.push_back(i);

                // Record the maximum for this window
                if (i >= k - 1) {
                    result.push_back(nums[dq.front()]);
                }
            }

            return result;
        }
    // Q1. Queue Using Stacks
        /*
        Q.1 -> Implement a First In First Out (FIFO) queue using stacks only.

        The implemented queue should support all the functions of a normal queue (push, peek, pop, and empty).

        Implement the UserQueue class:

        void push(int X) : Pushes element X to the back of the queue.
        int pop() : Removes the element from the front of the queue and returns it.
        int peek() : Returns the element at the front of the queue.
        boolean empty() : Returns true if the queue is empty, false otherwise.

        NOTES:
        You must use only standard operations of a stack, which means only push to top, peek/pop from top, size, and is empty operations are valid.
        Depending on your language, the stack may not be supported natively. You may simulate a stack using a list or deque (double-ended queue) as long as you use only a stack's standard operations.

        Problem Constraints
            1 <= X <= 109
            At most 1000 calls will be made to push, pop, peek, and empty function.
            All the calls to pop and peek are valid. i.e. pop and peek are called only when the queue is non-empty.

        Input 1:
            1) UserQueue()
            2) push(20)
            3) empty()
            4) peek()
            5) pop()
            6) empty()
            7) push(30)
            8) peek()
            9) push(40)
            10) peek()    

        Output 1:
            false
            20
            20
            true
            30
            30 

        Input 2:
            1) UserQueue()
            2) push(10)
            3) push(20)
            4) push(30)
            5) pop()
            6) pop()

        Output 2:
            10
            20

        */

        // CODE
        class UserQueue {
        public:    

            stack<int> stack1, stack2;


            /** Initialize your data structure here. */
            UserQueue() {
                
            }
            
            void moveStack1ToStack2() {
                while (!stack1.empty()) {
                    stack2.push(stack1.top());
                    stack1.pop();
                }
            } 
            

            /** Push element X to the back of queue. */
            void push(int X) {
                stack1.push(X);
            }
            
            /** Removes the element from in front of queue and returns that element. */
            int pop() {
                if (stack2.empty()) {
                    // Move elements from stack1 to stack2 to simulate queue dequeue
                    moveStack1ToStack2();
                }
                // Pop the top element from stack2, which is the front of the queue
                int front = stack2.top();
                stack2.pop();
                return front;
            }
            
            /** Get the front element of the queue. */
            int peek() {
                if (stack2.empty()) {
                    // Move elements from stack1 to stack2 if stack2 is empty
                    moveStack1ToStack2();
                }
                // The top of stack2 is the front of the queue
                return stack2.top();
            }
            
            /** Returns whether the queue is empty. */
            bool empty() {
                return stack1.empty() && stack2.empty();
            }
        };

        /**
        * Your UserQueue object will be instantiated and called as such:
        * UserQueue* obj = new UserQueue();
        * obj->push(X);
        * int param2 = obj->pop();
        * int param3 = obj->peek();
        * bool param4 = obj->empty();
        */
    // Q2. Perfect Numbers
        /*
        Q.2 -> Given an integer A, you have to find the Ath Perfect Number.
        A Perfect Number has the following properties:
        It comprises only 1 and 2.
        The number of digits in a Perfect number is even.
        It is a palindrome number.
        For example, 11, 22, 112211 are Perfect numbers, where 123, 121, 782, 1 are not.

        Note :
            

        Problem Constraints
            1 <= A <= 100000

        Input Format
            The only argument given is an integer A.

        Output Format
            Return a string that denotes the Ath Perfect Number.

        Input 1:
            A=2

        Output 1:
            22

        Input 2:
            A=3

        Output 2:
            111

        */

        // CODE
        string Solution::solve(int A) {

            queue<std::string> q;
            q.push("1");
            q.push("2");

            string firstHalf, perfectNumber;

            for (int i = 0; i < A; ++i) {
                firstHalf = q.front(); // Get the current first half
                q.pop();
                
                // Form the full perfect number by mirroring the first half
                perfectNumber = firstHalf + string(firstHalf.rbegin(), firstHalf.rend());

                // Generate the next numbers to be considered as the first half
                q.push(firstHalf + "1");
                q.push(firstHalf + "2");
            }

            return perfectNumber;
        }
    // Q3. Parking Ice Cream Truck
        /*
        Q.3 -> Imagine you're an ice cream truck driver in a beachside town. The beach is divided into several sections, and each section has varying numbers of beachgoers wanting ice cream given by the array of integers A.
        For simplicity, let's say the beach is divided into 8 sections. One day, you note down the number of potential customers in each section: [5, 12, 3, 4, 8, 10, 2, 7]. This means there are 5 people in the first section, 12 in the second, and so on.
        You can only stop your truck in B consecutive sections at a time because of parking restrictions. To maximize sales, you want to park where the most customers are clustered together.
        For all B consecutive sections, identify the busiest stretch to park your ice cream truck and serve the most customers. Return an array C, where C[i] is the busiest section in each of the B consecutive sections. Refer to the given example for clarity.

        NOTE: If B > length of the array, return 1 element with the max of the array.

        Problem Constraints
            1 <= |A|, B <= 10^6

        Input Format
            The first argument given is the integer array A.
            The second argument given is the integer B.

        Output Format
            Return an array C, where C[i] is the maximum value from A[i] to A[i+B-1].

        Input 1:
            A = [1, 3, -1, -3, 5, 3, 6, 7]
            B = 3

        Output 1:
            [3, 3, 5, 5, 6, 7]

        Input 2:
            A = [1, 2, 3, 4, 2, 7, 1, 3, 6]
            B = 6

        Output 2:
            [7, 7, 7, 7]

        */

        // CODE
        vector<int> Solution::slidingMaximum(const vector<int> &A, int B) {
            vector<int> result;
            deque<int> dq;
            
            for (int i = 0; i < A.size(); ++i) {
                // Remove elements not within the sliding window
                if (!dq.empty() && dq.front() == i - B) {
                    dq.pop_front();
                }
                
                // Remove elements from the deque that are smaller than the current element
                while (!dq.empty() && A[dq.back()] <= A[i]) {
                    dq.pop_back();
                }
                
                // Add current element index at the back of the deque
                dq.push_back(i);
                
                // The front of the deque is the maximum for the current window
                if (i >= B - 1) {
                    result.push_back(A[dq.front()]);
                }
            }
            
            return result;
        }
    // Q4. N integers containing only 1, 2 & 3
        /*
        Q.4 -> Given an integer, A. Find and Return first positive A integers in ascending order containing only digits 1, 2, and 3.

        NOTE: All the A integers will fit in 32-bit integers.

        Problem Constraints
            1 <= A <= 29500

        Input Format
            The only argument given is integer A 

        Output Format
            Return an integer array denoting the first positive A integers in ascending order containing only digits 1, 2 and 3.

        Input 1:
            A = 3

        Output 1:
            [1, 2, 3]

        Input 2:
            A = 7

        Output 2:
            [1, 2, 3, 11, 12, 13, 21]

        */

        // CODE
        vector<int> Solution::solve(int A) {

            std::vector<int> result;
            std::queue<int> q;

            // Start with the numbers "1", "2", and "3"
            q.push(1);
            q.push(2);
            q.push(3);

            while (result.size() < A) {
                // Get the front element from the queue
                int current = q.front();
                q.pop();

                // Convert the string to an integer and add it to the result
                result.push_back(current);

                // Generate the next numbers by appending "1", "2", and "3"
                q.push(current*10+1);
                q.push(current*10+2);
                q.push(current*10+3);
            
            }

            return result;
        }
    // Q1. Reversing Elements Of Queue
        /*
        Q.1 -> Given an array of integers A and an integer B, we need to reverse the order of the first B elements of the array, 
        leaving the other elements in the same relative order. 

        NOTE: You are required to the first insert elements into an auxiliary queue then perform Reversal of first B elements.

        Problem Constraints
            1 <= B <= length of the array <= 500000
            1 <= A[i] <= 100000

        Input Format
            The argument given is the integer array A and an integer B.

        Output Format
            Return an array of integer after reversing the first B elements of A using queue.

        Input 1:    
            A = [1, 2, 3, 4, 5]
            B = 3

        Output 1:
            [3, 2, 1, 4, 5]

        Input 2:
            A = [5, 17, 100, 11]
            B = 2

        Output 2:
            [17, 5, 100, 11]

        */

        // CODE
        vector<int> Solution::solve(vector<int> &A, int B) {

            queue<int> q;
            stack<int> s;
            vector<int> result;
            
            // Insert all elements into the queue
            for (int num : A) {
                q.push(num);
            }
            
            // Reverse the first B elements
            for (int i = 0; i < B; ++i) {
                s.push(q.front());
                q.pop();
            }
            
            // Add reversed elements to result
            while (!s.empty()) {
                result.push_back(s.top());
                s.pop();
            }
            
            // Add remaining elements to result
            while (!q.empty()) {
                result.push_back(q.front());
                q.pop();
            }
            
            return result;
        }
    // Q2. Sum of min and max
        /*
        Q.2 -> Given an array A of both positive and negative integers.
        Your task is to compute the sum of minimum and maximum elements of all sub-array of size B.

        NOTE: Since the answer can be very large, you are required to return the sum modulo 109 + 7.

        Problem Constraints
            1 <= size of array A <= 10^5
            -10^9 <= A[i] <= 10^9
            1 <= B <= size of array

        Input Format
            The first argument denotes the integer array A.
            The second argument denotes the value B

        Output Format
            Return an integer that denotes the required value.

        Input 1:
            A = [2, 5, -1, 7, -3, -1, -2]
            B = 4

        Output 1:
            18

        Input 2:
            A = [2, -1, 3]
            B = 2

        Output 2:
            3

        */

        // CODE
        vector<int> Subarray(vector<int> &A, int B, string op) {
            deque<int> dq;
            vector<int> ans;
            int n = A.size();
            
            for (int i = 0; i < B; i++) {
                if (op == "max") {
                    while (!dq.empty() && A[dq.back()] <= A[i]) {
                        dq.pop_back();
                    }
                } else {
                    while (!dq.empty() && A[dq.back()] >= A[i]) {
                        dq.pop_back();
                    }
                }
                dq.push_back(i);
            }
            
            ans.push_back(A[dq.front()]);
            
            for (int i = B; i < n; i++) {
                if (op == "max") {
                    while (!dq.empty() && A[dq.back()] <= A[i]) {
                        dq.pop_back();
                    }
                } else {
                    while (!dq.empty() && A[dq.back()] >= A[i]) {
                        dq.pop_back();
                    }
                }
                dq.push_back(i);
                
                if (dq.front() == i - B) {
                    dq.pop_front();
                }
                
                ans.push_back(A[dq.front()]);
            }
            
            return ans;
        }

        int Solution::solve(vector<int> &A, int B) {
            vector<int> maxSub = Subarray(A, B, "max");
            vector<int> minSub = Subarray(A, B, "min");
            int n = maxSub.size();
            int sum = 0;
            
            for (int i = 0; i < n; i++) {
                sum += (maxSub[i] + minSub[i] + 1000000007);
                sum %= 1000000007;
            }
            
            return sum;
        }
    // Q3. Unique Letter
        /*
        Q.3 -> Imagine you're a teacher. You ask students to call out a letter one by one. After each letter, you jot down the very first letter that's only been called out once. If all letters have been repeated, you write "#".

        Here's a scenario:

        A student says "a". It's the first letter. You write "a".
        Next, a student says "b", "a" is still unique, so you add "a". Now it's "aa".
        A student says "a" again. Now, "b" is the unique one. You add "b", making it "aab".
        A student says "b". All letters so far are repeated. You add "#". It becomes "aab#".
        A student says "c". "c" is unique. You add "c". The final is "aab#c".
        Your task? Given the sequence the students call out A, determine the string on the board.

        Note :

        Problem Constraints
            1 <= |A| <= 100000

        Input Format
            The only argument given is string A.  

        Output Format
            Return a string after processing the stream of lowercase alphabets A.

        Input 1:
            A = "abadbc"

        Output 1:
            "aabbdd"

        Input 2:
            A = "abcabc"

        Output 2:
            "aaabc#"

        */

        // CODE
        string Solution::solve(string A) {

            std::unordered_map<char, int> freq;
            std::queue<char> uniqueQueue;
            std::string result;

            for (char ch : A) {
                // Update frequency of the current character
                freq[ch]++;

                // Add character to queue if it's unique
                if (freq[ch] == 1) {
                    uniqueQueue.push(ch);
                }

                // Remove characters from queue that are no longer unique
                while (!uniqueQueue.empty() && freq[uniqueQueue.front()] > 1) {
                    uniqueQueue.pop();
                }

                // Append the result based on the queue
                if (uniqueQueue.empty()) {
                    result += '#';
                } else {
                    result += uniqueQueue.front();
                }
            }

            return result;
        }
## Stacks & Queues Extra ##
    // Implement Stack using Array
        class Stack {
            int size;
            int * arr;
            int top;
            public:
                Stack() {
                top = -1;
                size = 1000;
                arr = new int[size];
                }
            void push(int x) {
                top++;
                arr[top] = x;
            }
            int pop() {
                int x = arr[top];
                top--;
                return x;
            }
            int Top() {
                return arr[top];
            }
            int Size() {
                return top + 1;
            }
        };
    // Implement Queue Using Array
        class Queue {
        int * arr;
        int start, end, currSize, maxSize;
        public:
            Queue() {
            arr = new int[16];
            start = -1;
            end = -1;
            currSize = 0;
            }

        Queue(int maxSize) {
            ( * this).maxSize = maxSize;
            arr = new int[maxSize];
            start = -1;
            end = -1;
            currSize = 0;
        }
        void push(int newElement) {
            if (currSize == maxSize) {
            cout << "Queue is full\nExiting..." << endl;
            exit(1);
            }
            if (end == -1) {
            start = 0;
            end = 0;
            } else
            end = (end + 1) % maxSize;
            arr[end] = newElement;
            cout << "The element pushed is " << newElement << endl;
            currSize++;
        }
        int pop() {
            if (start == -1) {
            cout << "Queue Empty\nExiting..." << endl;
            }
            int popped = arr[start];
            if (currSize == 1) {
            start = -1;
            end = -1;
            } else
            start = (start + 1) % maxSize;
            currSize--;
            return popped;
        }
        int top() {
            if (start == -1) {
            cout << "Queue is Empty" << endl;
            exit(1);
            }
            return arr[start];
        }
        int size() {
            return currSize;
        }

        };
    // Implement stack using linked list
        struct stackNode {
            int data;
            stackNode * next;
            int size;
            stackNode(int d) {
                data = d;
                next = NULL;
            }
        };
        struct stack {
            stackNode * top;
            int size;
            stack() {
                top = NULL;
                size = 0;
            }
            void stackPush(int x) {
                stackNode * element = new stackNode(x);
                element -> next = top;
                top = element;
                cout << "Element pushed" << "\n";
                size++;
            }
            int stackPop() {
                if (top == NULL) {
                return -1;
                }
                int topData = top -> data;
                stackNode * temp = top;
                top = top -> next;
                delete temp;
                size--;
                return topData;
            }
            int stackSize() {
                return size;
            }
            bool stackIsEmpty() {
                return top == NULL;
            }
            int stackPeek() {
                if (top == NULL) return -1;
                return top -> data;
            }
            void printStack() {
                stackNode * current = top;
                while (current != NULL) {
                cout << current -> data << " ";
                current = current -> next;
                }
            }
        };
    // Implement Queue using linked list
        class QueueNode
        {
            public: 
                int val;
                QueueNode *next;
                QueueNode(int data)
                {
                val = data;
                next = nullptr;
                }
        };  
        QueueNode *Front = nullptr, *Rare = nullptr;

        class Queue
        {
            public:
                int size = 0;
                bool Empty();
                void Enqueue(int value);
                void Dequeue();
                int Peek();
        };  
        bool Queue ::  Empty()
        {
            return Front == nullptr;
        }  
        int Queue :: Peek()
        {
            if(Empty())  
            {  cout<<"Queue is Empty"<<endl;
                return -1;
            } 
            else 
            return Front->val;
        }   
        void Queue :: Enqueue(int value)
        {
            QueueNode *Temp;
            Temp = new QueueNode(value); 
            if (Temp == nullptr)  //When heap exhausted 
                cout << "Queue is Full" << endl;
            else
            {
                if (Front == nullptr)
                {
                    Front = Temp;
                    Rare = Temp;
                } 
                else
                {
                    Rare->next = Temp;
                    Rare = Temp;
                }
                cout<<value <<" Inserted into Queue "<<endl;
                size++;
            } 
        }      
        void Queue :: Dequeue() 
        {
            if (Front == nullptr) 
                cout << "Queue is Empty" << endl;
            else
            { 
                cout<<Front->val <<" Removed From Queue"<<endl;
                QueueNode *Temp = Front;
                Front = Front->next;
                delete Temp;
                size--;
            }  
        }   
    // Implement Stack using single Queue
        class Stack {
        queue < int > q;
        public:
            void Push(int x) {
            int s = q.size();
            q.push(x);
            for (int i = 0; i < s; i++) {

                q.push(q.front());
                q.pop();
            }
            }
        int Pop() {
            int n = q.front();
            q.pop();
            return n;
        }
        int Top() {
            return q.front();
        }
        int Size() {
            return q.size();
        }
        };
    // Implement Queue using Stack
        // Solution 1: Using two Stacks where push operation is O(N)
        struct Queue {
            stack < int > input, output;
            
            // Push elements in queue
            void Push(int data) {
                // Pop out all elements from the stack input
                while (!input.empty()) {
                output.push(input.top());
                input.pop();
                }
                // Insert the desired element in the stack input
                cout << "The element pushed is " << data << endl;
                input.push(data);
                // Pop out elements from the stack output and push them into the stack input
                while (!output.empty()) {
                input.push(output.top());
                output.pop();
                }
            }
            // Pop the element from the Queue
            int Pop() {
                if (input.empty()) {
                cout << "Stack is empty";
                exit(0);
                }
                int val = input.top();
                input.pop();
                return val;
            }
            // Return the Topmost element from the Queue
            int Top() {
                if (input.empty()) {
                cout << "Stack is empty";
                exit(0);
                }
                return input.top();
            }
            // Return the size of the Queue
            int size() {
                return input.size();
            }
        };
        // Solution 2: Using two Stacks where push operation is O(1)
        class MyQueue {
            public:
                stack < int > input, output;
            /** Initialize your data structure here. */
            MyQueue() {

            }

            /** Push element x to the back of queue. */
            void push(int x) {
                cout << "The element pushed is " << x << endl;
                input.push(x);
            }

            /** Removes the element from in front of queue and returns that element. */
            int pop() {
                // shift input to output 
                if (output.empty())
                while (input.size())
                    output.push(input.top()), input.pop();

                int x = output.top();
                output.pop();
                return x;
            }

            /** Get the front element. */
            int top() {
                // shift input to output 
                if (output.empty())
                while (input.size())
                    output.push(input.top()), input.pop();
                return output.top();
            }

            int size() {
                return (output.size() + input.size()); 
            }

        };
    // Implement Min Stack
        class MinStack {
            stack < long long > st;
            long long mini;
            public:
                /** initialize your data structure here. */
                MinStack() {
                while (st.empty() == false) st.pop();
                mini = INT_MAX;
                }

            void push(int value) {
                long long val = Long.valuevalue;
                if (st.empty()) {
                mini = val;
                st.push(val);
                } else {
                if (val < mini) {
                    st.push(2 *val*1LL - mini);
                    mini = val;
                } else {
                    st.push(val);
                }
                }
            }

            void pop() {
                if (st.empty()) return;
                long long el = st.top();
                st.pop();

                if (el < mini) {
                mini = 2 * mini - el;
                }
            }

            int top() {
                if (st.empty()) return -1;

                long long el = st.top();
                if (el < mini) return mini;
                return el;
            }

            int getMin() {
                return mini;
            }
        };
    // Infix to Postfix Conversion using Stack
        //Function to return precedence of operators
        int prec(char c) {
            if (c == '^')
                return 3;
            else if (c == '/' || c == '*')
                return 2;
            else if (c == '+' || c == '-')
                return 1;
            else
                return -1;
        }

        // The main function to convert infix expression
        //to postfix expression
        void infixToPostfix(string s) {

            stack < char > st; //For stack operations, we are using C++ built in stack
            string result;

            for (int i = 0; i < s.length(); i++) {
                char c = s[i];

                // If the scanned character is
                // an operand, add it to output string.
                if ((c >= 'a' && c <= 'z') || (c >= 'A' && c <= 'Z') || (c >= '0' && c <= '9'))
                result += c;

                // If the scanned character is an
                // (, push it to the stack.
                else if (c == '(')
                st.push('(');

                // If the scanned character is an ),
                // pop and to output string from the stack
                // until an ( is encountered.
                else if (c == ')') {
                    while (st.top() != '(') {
                        result += st.top();
                        st.pop();
                    }
                    st.pop();
                }

                //If an operator is scanned
                else {
                    while (!st.empty() && prec(s[i]) <= prec(st.top())) {
                        result += st.top();
                        st.pop();
                    }
                    st.push(c);
                }
            }

            // Pop all the remaining elements from the stack
            while (!st.empty()) {
                result += st.top();
                st.pop();
            }

            cout << "Prefix expression: " << result << endl;
        }
    // Infix to Prefix
        bool isOperator(char c) {
            return (!isalpha(c) && !isdigit(c));
        }

        int getPriority(char C) {
            if (C == '-' || C == '+')
                return 1;
            else if (C == '*' || C == '/')
                return 2;
            else if (C == '^')
                return 3;
            return 0;
        }

        string infixToPostfix(string infix) {
            infix = '(' + infix + ')';
            int l = infix.size();
            stack < char > char_stack;
            string output;

            for (int i = 0; i < l; i++) {

                // If the scanned character is an
                // operand, add it to output.
                if (isalpha(infix[i]) || isdigit(infix[i]))
                    output += infix[i];

                // If the scanned character is an
                // (, push it to the stack.
                else if (infix[i] == '(')
                    char_stack.push('(');

                // If the scanned character is an
                // ), pop and output from the stack
                // until an ( is encountered.
                else if (infix[i] == ')') {
                    while (char_stack.top() != '(') {
                        output += char_stack.top();
                        char_stack.pop();
                    }

                    // Remove '(' from the stack
                    char_stack.pop();
                }

                // Operator found
                else {
                    if (isOperator(char_stack.top())) {
                        if (infix[i] == '^') {
                            while (getPriority(infix[i]) <= getPriority(char_stack.top())) {
                                output += char_stack.top();
                                char_stack.pop();
                            }

                        } else {
                            while (getPriority(infix[i]) < getPriority(char_stack.top())) {
                                output += char_stack.top();
                                char_stack.pop();
                            }

                        }

                        // Push current Operator on stack
                        char_stack.push(infix[i]);
                    }
                }
            }
            while (!char_stack.empty()) {
                output += char_stack.top();
                char_stack.pop();
            }
            return output;
        }

        string infixToPrefix(string infix) {
            /* Reverse String
            * Replace ( with ) and vice versa
            * Get Postfix
            * Reverse Postfix  *  */
            int l = infix.size();

            // Reverse infix
            reverse(infix.begin(), infix.end());

            // Replace ( with ) and vice versa
            for (int i = 0; i < l; i++) {

                if (infix[i] == '(') {
                infix[i] = ')';
                i++;
                } else if (infix[i] == ')') {
                infix[i] = '(';
                i++;
                }
            }

            string prefix = infixToPostfix(infix);

            // Reverse postfix
            reverse(prefix.begin(), prefix.end());

            return prefix;
        }
    // Postfix to Infix
        // Function to check if a character is an operator
        bool isOperator(char ch) {
            return ch == '+' || ch == '-' || ch == '*' || ch == '/';
        }

        // Function to convert postfix to infix
        string postfixToInfix(const string& postfix) {
            stack<string> s;
            for (char ch : postfix) {
                if (isOperator(ch)) {
                    // Pop two operands from the stack
                    string operand1 = s.top(); s.pop();
                    string operand2 = s.top(); s.pop();
                    
                    // Create the new infix expression and push it to the stack
                    string newInfix = "(" + operand2 + ch + operand1 + ")";
                    s.push(newInfix);
                } else {
                    // If the character is an operand, push it to the stack
                    s.push(string(1, ch));
                }
            }

            // The final element in the stack is the resulting infix expression
            return s.top();
        }

    // Postfix to Prefix
        bool isOperator(char ch) {
            return ch == '+' || ch == '-' || ch == '*' || ch == '/';
        }

        // Function to convert postfix to prefix
        string postfixToPrefix(const string& postfix) {
            stack<string> s;
            
            for (char ch : postfix) {
                if (isOperator(ch)) {
                    // Pop two operands from the stack
                    string operand1 = s.top(); s.pop();
                    string operand2 = s.top(); s.pop();
                    
                    // Create the new prefix expression and push it to the stack
                    string newPrefix = ch + operand2 + operand1;
                    s.push(newPrefix);
                } else {
                    // If the character is an operand, push it to the stack
                    s.push(string(1, ch));
                }
            }
            
            // The final element in the stack is the resulting prefix expression
            return s.top();
        }

    // Prefix to Infix
        // Function to check if a character is an operator
        bool isOperator(char ch) {
            return ch == '+' || ch == '-' || ch == '*' || ch == '/';
        }
        // Function to convert prefix to infix
        string prefixToInfix(const string& prefix) {
            stack<string> s;
            
            // Traverse the prefix expression in reverse order
            for (int i = prefix.size() - 1; i >= 0; i--) {
                char ch = prefix[i];
                
                if (isOperator(ch)) {
                    // Pop two operands from the stack
                    string operand1 = s.top(); s.pop();
                    string operand2 = s.top(); s.pop();
                    
                    // Create the new infix expression and push it to the stack
                    string newInfix = "(" + operand1 + ch + operand2 + ")";
                    s.push(newInfix);
                } else {
                    // If the character is an operand, push it to the stack
                    s.push(string(1, ch));
                }
            }
            
            // The final element in the stack is the resulting infix expression
            return s.top();
        }

    // Prefix to Postfix
        // Function to check if a character is an operator
        bool isOperator(char ch) {
            return ch == '+' || ch == '-' || ch == '*' || ch == '/';
        }
        // Function to convert prefix to postfix
        string prefixToPostfix(const string& prefix) {
            stack<string> s;
            
            // Traverse the prefix expression in reverse order
            for (int i = prefix.size() - 1; i >= 0; i--) {
                char ch = prefix[i];
                
                if (isOperator(ch)) {
                    // Pop two operands from the stack
                    string operand1 = s.top(); s.pop();
                    string operand2 = s.top(); s.pop();
                    
                    // Create the new postfix expression and push it to the stack
                    string newPostfix = operand1 + operand2 + ch;
                    s.push(newPostfix);
                } else {
                    // If the character is an operand, push it to the stack
                    s.push(string(1, ch));
                }
            }
            
            // The final element in the stack is the resulting postfix expression
            return s.top();
        }

    // Next Greater Element (on Right)
        vector<int> nextGreaterElement(vector<int>& arr) {
            int n = arr.size();
            vector<int> ans(n, -1); // Initialize the answer vector with -1 (indicating no greater element)
            stack<int> s;           // Stack to keep track of elements
            
            // Traverse the array from right to left
            for (int i = n - 1; i >= 0; i--) {
                // Pop elements from the stack until we find one greater than the current element
                while (!s.empty() && s.top() <= arr[i]) {
                    s.pop();
                }

                // If stack is not empty, the top element is the next greater element
                if (!s.empty()) {
                    ans[i] = s.top();
                }

                // Push the current element onto the stack
                s.push(arr[i]);
            }

            return ans;
        }
    // Next Greater Element 2 (on Right But see Circularly)
        vector<int> nextGreaterElements(vector < int > & nums) {
            int n = nums.size();
            vector < int > nge(n, -1);
            stack < int > st;
            for (int i = 2 * n - 1; i >= 0; i--) {
                while (!st.empty() && st.top() <= nums[i % n]) {
                    st.pop();
                }

                if (i < n) {
                    if (!st.empty()) nge[i] = st.top();
                }
                st.push(nums[i % n]);
            }
            return nge;
        }
    // Next Smaller Element
        vector<int> nextSmallerElement(vector<int>& arr) {
            int n = arr.size();
            vector<int> ans(n, -1); // Initialize the answer vector with -1 (indicating no smaller element)
            stack<int> s;           // Stack to keep track of elements
            
            // Traverse the array from left to right
            for (int i = 0; i < n; i++) {
                // Pop elements from the stack until we find one smaller than the current element
                while (!s.empty() && s.top() >= arr[i]) {
                    s.pop();
                }

                // If stack is not empty, the top element is the next smaller element
                if (!s.empty()) {
                    ans[i] = s.top();
                }

                // Push the current element onto the stack
                s.push(arr[i]);
            }

            return ans;
        }
    // Trapping Rainwater
        int trap(vector < int > & height) {
            int n = height.size();
            int L = 0, R = n - 1;
            int total = 0;
            int Lmax = 0, Rmax = 0;
            while (L <= R) {
                if (height[L] <= height[R]) {
                    if (height[L] >= Lmax) {
                        Lmax = height[L];
                    } else {
                        total += Lmax - height[L];
                    }
                    L++;
                } else {
                    if (height[R] >= Rmax) {
                        Rmax = height[R];
                    } else {
                        total += Rmax - height[R];
                    }
                    R--;
                }
            }
            return total;
        }
    // Sum of subarray minimum
        int sumSubarrayMinimums(vector<int>& arr) {
            int n = arr.size();
            vector<int> nextSmaller(n, n);  // Array to store indices of the next smaller elements
            vector<int> prevSmaller(n, -1); // Array to store indices of the previous smaller or equal elements
            stack<int> s;

            // Calculate the next smaller elements
            for (int i = 0; i < n; i++) {
                while (!s.empty() && arr[s.top()] > arr[i]) {
                    nextSmaller[s.top()] = i;
                    s.pop();
                }
                s.push(i);
            }

            // Clear the stack for the next calculation
            while (!s.empty()) {
                s.pop();
            }

            // Calculate the previous smaller or equal elements
            for (int i = n - 1; i >= 0; i--) {
                while (!s.empty() && arr[s.top()] >= arr[i]) {
                    prevSmaller[s.top()] = i;
                    s.pop();
                }
                s.push(i);
            }

            // Calculate the sum of subarray minimums
            long long result = 0;
            const int MOD = 1e9 + 7;
            for (int i = 0; i < n; i++) {
                long long left = i - prevSmaller[i];    // Distance to the previous smaller or equal element
                long long right = nextSmaller[i] - i;   // Distance to the next smaller element
                result = (result + arr[i] * left * right) % MOD;
            }

            return (int)result;
        }
    // Sum of subarray ranges
        // Function to calculate sum of subarray minimums
        long long sumOfMin(const vector<int>& arr) {
            int n = arr.size();
            vector<int> nextSmaller(n, n);  // Next Smaller Element (NSE)
            vector<int> prevSmaller(n, -1); // Previous Smaller or Equal Element (PSE)
            stack<int> s;
            
            // Calculate Next Smaller Element (NSE)
            for (int i = 0; i < n; i++) {
                while (!s.empty() && arr[s.top()] > arr[i]) {
                    nextSmaller[s.top()] = i;
                    s.pop();
                }
                s.push(i);
            }
            
            // Calculate Previous Smaller or Equal Element (PSE)
            while (!s.empty()) s.pop();  // Clear stack
            for (int i = n - 1; i >= 0; i--) {
                while (!s.empty() && arr[s.top()] >= arr[i]) {
                    prevSmaller[s.top()] = i;
                    s.pop();
                }
                s.push(i);
            }
            
            long long result = 0;
            const int MOD = 1e9 + 7;
            for (int i = 0; i < n; i++) {
                long long left = i - prevSmaller[i];    // Distance to the previous smaller or equal element
                long long right = nextSmaller[i] - i;   // Distance to the next smaller element
                result = (result + arr[i] * left * right) % MOD;
            }

            return result;
        }

        // Function to calculate sum of subarray maximums
        long long sumOfMax(const vector<int>& arr) {
            int n = arr.size();
            vector<int> nextGreater(n, n);  // Next Greater Element (NGE)
            vector<int> prevGreater(n, -1); // Previous Greater or Equal Element (PGE)
            stack<int> s;
            
            // Calculate Next Greater Element (NGE)
            for (int i = 0; i < n; i++) {
                while (!s.empty() && arr[s.top()] < arr[i]) {
                    nextGreater[s.top()] = i;
                    s.pop();
                }
                s.push(i);
            }
            
            // Calculate Previous Greater or Equal Element (PGE)
            while (!s.empty()) s.pop();  // Clear stack
            for (int i = n - 1; i >= 0; i--) {
                while (!s.empty() && arr[s.top()] <= arr[i]) {
                    prevGreater[s.top()] = i;
                    s.pop();
                }
                s.push(i);
            }
            
            long long result = 0;
            const int MOD = 1e9 + 7;
            for (int i = 0; i < n; i++) {
                long long left = i - prevGreater[i];    // Distance to the previous greater or equal element
                long long right = nextGreater[i] - i;   // Distance to the next greater element
                result = (result + arr[i] * left * right) % MOD;
            }

            return result;
        }

        // Function to calculate sum of subarray ranges
        long long sumSubarrayRanges(vector<int>& arr) {
            long long min_sum = sumOfMin(arr);
            long long max_sum = sumOfMax(arr);
            return max_sum - min_sum;
        }
    // Asteroid Collision
        vector<int> asteroidCollision(vector<int>& asteroids) {
            stack<int> st;

            for (int ast : asteroids) {
                // Process collision
                bool destroyed = false;
                while (!st.empty() && st.top() > 0 && ast < 0) {
                    if (st.top() < -ast) {
                        // Stack's top asteroid is smaller, it gets destroyed
                        st.pop();
                        continue;
                    } else if (st.top() == -ast) {
                        // Both asteroids are of equal size, destroy both
                        st.pop();
                    }
                    // Current asteroid is either destroyed or both were equal in size
                    destroyed = true;
                    break;
                }
                if (!destroyed) {
                    // No collision, push current asteroid
                    st.push(ast);
                }
            }

            // Create result vector from the stack
            vector<int> result(st.size());
            for (int i = st.size() - 1; i >= 0; --i) {
                result[i] = st.top();
                st.pop();
            }

            return result;
        }
    // Largest rectangle in a histogram
        int largestRectangleArea(vector<int>& heights) {
            int n = heights.size();
            stack<int> st;
            int maxArea = 0;

            for (int i = 0; i <= n; ++i) {
                // Use a height of 0 when we are at the end of the histogram to force emptying the stack
                int h = (i == n) ? 0 : heights[i];
                while (!st.empty() && h < heights[st.top()]) {
                    int height = heights[st.top()];
                    st.pop();
                    int width = st.empty() ? i : i - st.top() - 1;
                    maxArea = max(maxArea, height * width);
                }
                st.push(i);
            }

            return maxArea;
        }
    // Maximal Rectangles
        int largestRectangleArea(vector<int>& heights) {
            stack<int> st;
            int maxArea = 0;
            int n = heights.size();

            for (int i = 0; i <= n; ++i) {
                int h = (i == n) ? 0 : heights[i];
                while (!st.empty() && h < heights[st.top()]) {
                    int height = heights[st.top()];
                    st.pop();
                    int width = st.empty() ? i : i - st.top() - 1;
                    maxArea = max(maxArea, height * width);
                }
                st.push(i);
            }

            return maxArea;
        }

        int maximalRectangle(vector<vector<char>>& matrix) {
            if (matrix.empty() || matrix[0].empty()) return 0;

            int maxArea = 0;
            int cols = matrix[0].size();
            vector<int> heights(cols, 0);

            for (const auto& row : matrix) {
                for (int j = 0; j < cols; ++j) {
                    // Update the height of the histogram based on the matrix row
                    heights[j] = (row[j] == '1') ? heights[j] + 1 : 0;
                }
                // Calculate the largest rectangle for the current histogram
                maxArea = max(maxArea, largestRectangleArea(heights));
            }

            return maxArea;
        }
    // Remove k Digits
        string removeKdigits(string num, int k) {
            // Edge case: if we need to remove all digits
            if (k == num.size()) return "0";

            stack<char> st;

            for (char digit : num) {
                // Remove elements from the stack if they are greater than the current digit
                // and we can still remove elements (k > 0)
                while (!st.empty() && k > 0 && st.top() > digit) {
                    st.pop();
                    k--;
                }
                // Push the current digit onto the stack
                st.push(digit);
            }

            // If there are still digits to remove, remove from the end
            while (k > 0 && !st.empty()) {
                st.pop();
                k--;
            }

            // Build the result from the stack
            string result = "";
            while (!st.empty()) {
                result = st.top() + result;  // Prepend characters to form the result
                st.pop();
            }

            // Remove leading zeros
            while (result.size() > 1 && result[0] == '0') {
                result.erase(result.begin());
            }

            return result.empty() ? "0" : result;
        }
    // Stock span problem
        vector<int> calculateSpan(vector<int>& prices) {
            int n = prices.size();
            vector<int> span(n); // Result vector to store spans
            stack<int> st;       // Stack to store indices

            for (int i = 0; i < n; ++i) {
                // Pop elements from the stack while the stack is not empty and
                // the current price is greater than the price at the top of the stack
                while (!st.empty() && prices[st.top()] <= prices[i]) {
                    st.pop();
                }

                // If the stack is empty, all elements to the left are smaller
                // Otherwise, calculate the span as the difference between indices
                span[i] = (st.empty()) ? (i + 1) : (i - st.top());

                // Push the current index onto the stack
                st.push(i);
            }

            return span;
        }
    // Sliding Window maximum
        vector<int> maxSlidingWindow(vector<int>& nums, int k) {
            vector<int> result;
            deque<int> dq; // Deque to store indices of elements

            for (int i = 0; i < nums.size(); ++i) {
                // Remove indices that are out of the current window
                if (!dq.empty() && dq.front() == i - k) {
                    dq.pop_front();
                }

                // Remove indices of elements smaller than the current element
                while (!dq.empty() && nums[dq.back()] <= nums[i]) {
                    dq.pop_back();
                }

                // Add the current index to the deque
                dq.push_back(i);

                // Add the maximum element of the current window to the result
                if (i >= k - 1) {
                    result.push_back(nums[dq.front()]);
                }
            }

            return result;
        }
    // The Celebrity Problem
        // Approach using Stack
            // Function to check if person 'a' knows person 'b'
            bool knows(vector<vector<int>>& M, int a, int b) {
                return M[a][b] == 1;
            }

            int findCelebrity(vector<vector<int>>& M, int n) {
                stack<int> st;

                // Push all people to the stack
                for (int i = 0; i < n; ++i) {
                    st.push(i);
                }

                // Find the potential celebrity
                while (st.size() > 1) {
                    int a = st.top();
                    st.pop();
                    int b = st.top();
                    st.pop();

                    // If 'a' knows 'b', 'a' cannot be the celebrity; push 'b'
                    if (knows(M, a, b)) {
                        st.push(b);
                    }
                    // If 'a' does not know 'b', 'b' cannot be the celebrity; push 'a'
                    else {
                        st.push(a);
                    }
                }

                // The potential candidate
                int candidate = st.top();

                // Verify if the candidate is a celebrity
                for (int i = 0; i < n; ++i) {
                    // Check if 'candidate' knows anyone or if there is anyone who does not know 'candidate'
                    if (i != candidate && (knows(M, candidate, i) || !knows(M, i, candidate))) {
                        return -1;
                    }
                }

                return candidate;
            }

        // Two pointer approach (top-bottom)
            // Function to check if person 'a' knows person 'b'
            bool knows(vector<vector<int>>& M, int a, int b) {
                return M[a][b] == 1;
            }

            int findCelebrity(vector<vector<int>>& M, int n) {
                int top = 0;
                int bottom = n - 1;

                // Identify the potential celebrity
                while (top < bottom) {
                    if (knows(M, top, bottom)) {
                        // If 'top' knows 'bottom', then 'top' cannot be the celebrity
                        top++;
                    } else {
                        // If 'top' does not know 'bottom', then 'bottom' cannot be the celebrity
                        bottom--;
                    }
                }

                // 'top' is the potential candidate
                int candidate = top;

                // Verify if the candidate is a celebrity
                for (int i = 0; i < n; ++i) {
                    // The candidate should not know anyone, and everyone except the candidate should know them
                    if (i != candidate && (knows(M, candidate, i) || !knows(M, i, candidate))) {
                        return -1;
                    }
                }

                return candidate;
            }
    // LRU cache (IMPORTANT)
        class LRUCache {
            public:
                class node {
                    public:
                        int key;
                    int val;
                    node * next;
                    node * prev;
                    node(int _key, int _val) {
                        key = _key;
                        val = _val;
                    }
                };

            node * head = new node(-1, -1);
            node * tail = new node(-1, -1);

            int cap;
            unordered_map < int, node * > m;

            LRUCache(int capacity) {
                cap = capacity;
                head -> next = tail;
                tail -> prev = head;
            }

            void addnode(node * newnode) {
                node * temp = head -> next;
                newnode -> next = temp;
                newnode -> prev = head;
                head -> next = newnode;
                temp -> prev = newnode;
            }

            void deletenode(node * delnode) {
                node * delprev = delnode -> prev;
                node * delnext = delnode -> next;
                delprev -> next = delnext;
                delnext -> prev = delprev;
            }

            int get(int key_) {
                if (m.find(key_) != m.end()) {
                    node * resnode = m[key_];
                    int res = resnode -> val;
                    m.erase(key_);
                    deletenode(resnode);
                    addnode(resnode);
                    m[key_] = head -> next;
                    return res;
                }

                return -1;
            }

            void put(int key_, int value) {
                if (m.find(key_) != m.end()) {
                    node * existingnode = m[key_];
                    m.erase(key_);
                    deletenode(existingnode);
                }
                if (m.size() == cap) {
                    m.erase(tail -> prev -> key);
                    deletenode(tail -> prev);
                }

                addnode(new node(key_, value));
                m[key_] = head -> next;
            }
        };
    // LFU cache
        // Node structure to hold key, value, and frequency
        struct Node {
            int key, value, frequency;
            Node(int k, int v) : key(k), value(v), frequency(1) {}
        };
        // Doubly Linked List class to maintain nodes of the same frequency
        class DoublyLinkedList {
        public:
            list<Node*> nodes;  // list to store nodes with same frequency
            void insertFirst(Node* node) {
                nodes.push_front(node);
            }

            void remove(Node* node) {
                nodes.remove(node);
            }

            Node* removeLast() {
                Node* lastNode = nodes.back();
                nodes.pop_back();
                return lastNode;
            }

            bool isEmpty() {
                return nodes.empty();
            }
        };
        class LFUCache {
        private:
            int Capacity, minFreq;
            unordered_map<int, Node*> map;  // key -> Node (key, value, frequency)
            unordered_map<int, DoublyLinkedList> freqList;  // frequency -> DoublyLinkedList of nodes

        public:
            LFUCache(int size) {
                Capacity = size;
                minFreq = 0;
            }

            int get(int key) {
                if (map.find(key) == map.end()) {
                    return -1;  // Key not found
                }
                Node* temp = map[key];
                updateFrequency(temp);
                return temp->value;
            }

            void put(int key, int value) {
                if (Capacity == 0) return;

                if (map.find(key) != map.end()) {
                    // Key exists, update value and frequency
                    Node* temp = map[key];
                    temp->value = value;
                    updateFrequency(temp);
                } else {
                    // Key does not exist
                    if (map.size() == Capacity) {
                        evictLFU();  // Evict the least frequently used element
                    }
                    Node* temp = new Node(key, value);
                    map[key] = temp;
                    updateFrequency(temp);
                }
            }

        private:
            // Update frequency of the node and move it to the appropriate frequency list
            void updateFrequency(Node* node) {
                int freq = node->frequency;
                // Remove the node from the current frequency list
                freqList[freq].remove(node);

                if (freqList[freq].isEmpty()) {
                    // If the list for the current frequency is empty, update minFreq
                    if (minFreq == freq) {
                        minFreq++;
                    }
                }

                node->frequency++;
                freqList[node->frequency].insertFirst(node);

                // Update the minimum frequency if necessary
                if (minFreq > node->frequency) {
                    minFreq = node->frequency;
                }
            }

            // Evict the least frequently used node
            void evictLFU() {
                Node* toEvict = freqList[minFreq].removeLast();
                map.erase(toEvict->key);  // Remove it from the map
                delete toEvict;  // Delete the node
            }
        };
// Trees
## Structure & Traversal ##
    ## Structure ##
        struct TreeNode {
            int val;
            TreeNode *left;
            TreeNode *right;
            TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        };
    ## Preorder Traversal ##
        // Recursion
            void preorder(TreeNode* node, vector<int>& result) {
                if (node == NULL) {
                    return;
                }
                result.push_back(node->val);
                preorder(node->left, result);
                preorder(node->right, result);
            }
        // Iterative
            void iterativePreorderTraversal(TreeNode* root) {
                if (root == nullptr) return;

                std::stack<TreeNode*> stack;
                stack.push(root);

                while (!stack.empty()) {
                    TreeNode* node = stack.top();
                    stack.pop();
                    
                    // Process the current node (e.g., print its value)
                    std::cout << node->val << " ";

                    // Push right child first so that left child is processed first. LEFT WILL COME ON TOP
                    if (node->right != nullptr) {
                        stack.push(node->right);
                    }
                    if (node->left != nullptr) {
                        stack.push(node->left);
                    }
                }
            }

    ## Inorder Traversal ##
        // RecursionN
            void inorder(TreeNode* node, vector<int>& result) {
                if (node == NULL) {
                    return;
                }
                inorder(node->left, result);
                result.push_back(node->val);
                inorder(node->right, result);
            }

        // Iterative
            void iterativeInorderTraversal(TreeNode* root) {
                std::stack<TreeNode*> stack;
                TreeNode* current = root;

                while (current != nullptr || !stack.empty()) {
                    // Reach the leftmost node of the current node
                    while (current != nullptr) {
                        stack.push(current);
                        current = current->left;
                    }

                    // Current must be null at this point, so we pop the top node
                    current = stack.top();
                    stack.pop();

                    // Process the current node (e.g., print its value)
                    std::cout << current->val << " ";

                    // Move to the right subtree
                    current = current->right;
                }
            }
    ## Postorder Traversal ##
        // RecursionN
            void postorder(TreeNode* node, vector<int>& result) {
                if (node == NULL) {
                    return;
                }
                postorder(node->left, result);
                postorder(node->right, result);
                result.push_back(node->val);
            }
    
        // Iterative
            void iterativePostorderTraversal(TreeNode* root) {
                if (!root) return;

                std::stack<TreeNode*> stack1, stack2;
                stack1.push(root);

                while (!stack1.empty()) {
                    TreeNode* node = stack1.top();
                    stack1.pop();
                    stack2.push(node);

                    // Push left and right children to stack1
                    if (node->left) stack1.push(node->left);
                    if (node->right) stack1.push(node->right);
                }

                // Process nodes in stack2, which are in postorder
                while (!stack2.empty()) {
                    std::cout << stack2.top()->val << " ";
                    stack2.pop();
                }
            }

    ## Build Binary Tree From Postorder and Inorder ##
        TreeNode* buildTreeHelper(vector<int>& inorder, vector<int>& postorder, int inStart, int inEnd, int& postIndex, unordered_map<int, int>& inMap) {
            // Base case: If no elements to construct the tree
            if (inStart > inEnd) {
                return NULL;
            }
            // The current root is the last element in postorder
            int rootVal = postorder[postIndex--];
            TreeNode* root = new TreeNode(rootVal);
            // Find the index of this root in inorder traversal
            int inIndex = inMap[rootVal];
            // Recursively build the right and left subtrees
            root->right = buildTreeHelper(inorder, postorder, inIndex + 1, inEnd, postIndex, inMap);
            root->left = buildTreeHelper(inorder, postorder, inStart, inIndex - 1, postIndex, inMap);
            return root;
        }
        TreeNode* Solution::buildTree(vector<int> &A, vector<int> &B) {
            // Map to store the index of each element in inorder traversal
            unordered_map<int, int> inMap;
            for (int i = 0; i < A.size(); i++) {
                inMap[A[i]] = i;
            }
            // Index to keep track of the current root in postorder traversal
            int postIndex = B.size() - 1;
            // Build and return the tree
            return buildTreeHelper(A, B, 0, A.size() - 1, postIndex, inMap);
        }
    ## Build Binary Tree From Preorder and Inorder ##
        TreeNode* buildTreeHelper(const std::vector<int>& preorder, int preStart, int preEnd, const std::vector<int>& inorder, int inStart, int inEnd, std::unordered_map<int, int>& inorderIndexMap) {
            if (preStart > preEnd || inStart > inEnd) return nullptr;

            int rootVal = preorder[preStart];
            TreeNode* root = new TreeNode(rootVal);

            int inRootIndex = inorderIndexMap[rootVal];
            int leftSubtreeSize = inRootIndex - inStart;

            root->left = buildTreeHelper(preorder, preStart + 1, preStart + leftSubtreeSize, inorder, inStart, inRootIndex - 1, inorderIndexMap);
            root->right = buildTreeHelper(preorder, preStart + leftSubtreeSize + 1, preEnd, inorder, inRootIndex + 1, inEnd, inorderIndexMap);

            return root;
        }
        TreeNode* buildTree(const std::vector<int>& preorder, const std::vector<int>& inorder) {
            std::unordered_map<int, int> inorderIndexMap;
            for (int i = 0; i < inorder.size(); ++i) {
                inorderIndexMap[inorder[i]] = i;
            }
            return buildTreeHelper(preorder, 0, preorder.size() - 1, inorder, 0, inorder.size() - 1, inorderIndexMap);
        }
    // Q1. Preorder Traversal
        /*
        Q.1 -> Given a binary tree, return the preorder traversal of its nodes values.

        Note :

        Problem Constraints
            1 <= number of nodes <= 105

        Input Format
            First and only argument is root node of the binary tree, A.  

        Output Format
            Return an integer array denoting the preorder traversal of the given binary tree.

        Input 1:
        1
            \
            2
            /
        3

        Output 1:
            [1, 2, 3]

        Input 2:
        1
        / \
        6   2
            /
        3

        Output 2:
            [1, 6, 2, 3]

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */

        void preorder(TreeNode* node, vector<int>& result) {
            if (node == NULL) {
                return;
            }
            
            // Visit the root node
            result.push_back(node->val);
            
            // Traverse the left subtree
            preorder(node->left, result);
            
            // Traverse the right subtree
            preorder(node->right, result);
        }

        vector<int> Solution::preorderTraversal(TreeNode* A) {
            vector<int> result;
            preorder(A, result);
            return result;
        }
    // Q2. Inorder Traversal
        /*
        Q.2 -> Given a binary tree, return the inorder traversal of its nodes' values.

        Note :

        Problem Constraints
            1 <= number of nodes <= 105

        Input Format
            First and only argument is root node of the binary tree, A. 

        Output Format
            Return an integer array denoting the inorder traversal of the given binary tree.


        Input 1:
        1
            \
            2
            /
        3

        Output 1:
            [1, 3, 2]

        Input 2:
        1
        / \
        6   2
            /
        3

        Output 2:
            [6, 1, 3, 2]

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */

        void inorder(TreeNode* node, vector<int>& result) {
            if (node == NULL) {
                return;
            }

            // Traverse the left subtree
            inorder(node->left, result);
            
            // Visit the root node
            result.push_back(node->val);
            
            // Traverse the right subtree
            inorder(node->right, result);
        }

        vector<int> Solution::inorderTraversal(TreeNode* A) {
            vector<int> result;
            inorder(A, result);
            return result;
        }
    // Q3. Binary Tree From Inorder And Postorder
        /*
        Q.3 -> Given the inorder and postorder traversal of a tree, construct the binary tree.

        NOTE: You may assume that duplicates do not exist in the tree.

        Problem Constraints
            1 <= number of nodes <= 10^5

        Input Format
            First argument is an integer array A denoting the inorder traversal of the tree.
            Second argument is an integer array B denoting the postorder traversal of the tree.

        Output Format
            Return the root node of the binary tree.

        Input 1:
            A = [2, 1, 3]
            B = [2, 3, 1]

        Output 1:
        1
        / \
        2   3

        Input 2:
            A = [6, 1, 3, 2]
            B = [6, 3, 2, 1]


        Output 2:
        1  
        / \
        6   2
            /
        3

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */


        TreeNode* buildTreeHelper(vector<int>& inorder, vector<int>& postorder, int inStart, int inEnd, int& postIndex, unordered_map<int, int>& inMap) {
            // Base case: If no elements to construct the tree
            if (inStart > inEnd) {
                return NULL;
            }

            // The current root is the last element in postorder
            int rootVal = postorder[postIndex--];
            TreeNode* root = new TreeNode(rootVal);

            // Find the index of this root in inorder traversal
            int inIndex = inMap[rootVal];

            // Recursively build the right and left subtrees
            root->right = buildTreeHelper(inorder, postorder, inIndex + 1, inEnd, postIndex, inMap);
            root->left = buildTreeHelper(inorder, postorder, inStart, inIndex - 1, postIndex, inMap);

            return root;
        }

        TreeNode* Solution::buildTree(vector<int> &A, vector<int> &B) {
            // Map to store the index of each element in inorder traversal
            unordered_map<int, int> inMap;
            for (int i = 0; i < A.size(); i++) {
                inMap[A[i]] = i;
            }

            // Index to keep track of the current root in postorder traversal
            int postIndex = B.size() - 1;

            // Build and return the tree
            return buildTreeHelper(A, B, 0, A.size() - 1, postIndex, inMap);
        }
    // Q1. Postorder Traversal
        /*
        Q.1 -> Given a binary tree, return the Postorder traversal of its nodes values.

        Note :

        Problem Constraints
            1 <= number of nodes <= 105

        Input Format
            First and only argument is root node of the binary tree, A.


        Output Format
            Return an integer array denoting the Postorder traversal of the given binary tree.

        Input 1:
        1
            \
            2
            /
        3

        Output 1:
            [3, 2, 1]

        Input 2:
        1
        / \
        6   2
            /
        3

        Output 2:
            [6, 3, 2, 1]

        */

        // CODE

        // --------------------------------------------------------------------------
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */
        vector<int> Solution::postorderTraversal(TreeNode* A) {
            vector<int> result;
            if (!A) return result;
            
            stack<TreeNode*> s1, s2;
            s1.push(A);
            
            while (!s1.empty()) {
                TreeNode* node = s1.top();
                s1.pop();
                s2.push(node);
                
                if (node->left) s1.push(node->left);
                if (node->right) s1.push(node->right);
            }
            
            while (!s2.empty()) {
                result.push_back(s2.top()->val);
                s2.pop();
            }
            
            return result;
        }
    // Q2. Binary Tree From Inorder And Preorder
        /*
        Q.2 -> Given preorder and inorder traversal of a tree, construct the binary tree.

        NOTE: You may assume that duplicates do not exist in the tree.

        Problem Constraints
            1 <= number of nodes <= 10^5

        Input Format
            First argument is an integer array A denoting the preorder traversal of the tree.
            Second argument is an integer array B denoting the inorder traversal of the tree.

        Output Format
            Return the root node of the binary tree.

        Input 1:
            A = [1, 2, 3]
            B = [2, 1, 3]

        Output 1:
        1
        / \
        2   3

        Input 2:
            A = [1, 6, 2, 3]
            B = [6, 1, 3, 2]

        Output 2:
        1  
        / \
        6   2
            /
        3

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */

        // Helper function to construct the tree recursively
        TreeNode* buildTreeHelper(const vector<int> &preorder, int preStart, int preEnd, 
                                const vector<int> &inorder, int inStart, int inEnd,
                                unordered_map<int, int> &inorderMap) {
            if (preStart > preEnd || inStart > inEnd) return NULL;

            int rootVal = preorder[preStart];
            TreeNode* root = new TreeNode(rootVal);
            int rootIndexInInorder = inorderMap[rootVal];

            int leftSize = rootIndexInInorder - inStart;

            root->left = buildTreeHelper(preorder, preStart + 1, preStart + leftSize, 
                                        inorder, inStart, rootIndexInInorder - 1, 
                                        inorderMap);
            root->right = buildTreeHelper(preorder, preStart + leftSize + 1, preEnd, 
                                        inorder, rootIndexInInorder + 1, inEnd, 
                                        inorderMap);
            return root;
        }

        TreeNode* Solution::buildTree(vector<int> &preorder, vector<int> &inorder) {
            unordered_map<int, int> inorderMap;
            for (int i = 0; i < inorder.size(); ++i) {
                inorderMap[inorder[i]] = i;
            }

            return buildTreeHelper(preorder, 0, preorder.size() - 1, 
                                inorder, 0, inorder.size() - 1, 
                                inorderMap);
        }


## Views & Types ##
    // Level Order Traversal (Left -> Right)
        vector<vector<int>> levelOrder(TreeNode* root) {
            vector<vector<int>> result;  // To store the final level order traversal result
            vector<int> level;           // To store nodes at each level
            
            if (!root) return result;    // If root is null, return an empty result
            
            queue<TreeNode*> q;          // Queue to manage the level order traversal
            q.push(root);                // Push the root node into the queue
            TreeNode* last = root;       // Track the last node of the current level
            TreeNode* first = root;      // Track the first node of the current level
            
            while (!q.empty()) {
                TreeNode* x = q.front(); // Get the front node from the queue
                q.pop();                 // Remove the front node from the queue
                level.push_back(x->val); // Add the node's value to the current level's result
                
                // If the node has a left child, push it into the queue
                if (x->left != nullptr) q.push(x->left);
                // If the node has a right child, push it into the queue
                if (x->right != nullptr) q.push(x->right);
                
                // If we have processed the last node of the current level
                if (x == last) {
                    result.push_back(level);  // Add the current level to the result
                    level.clear();            // Clear the current level data
                    if (!q.empty()) {         // If there are still nodes left to process
                        first = q.front();    // Set the first node of the next level
                        last = q.back();      // Set the last node of the next level
                    }
                }
            }
            
            return result;  // Return the result of level order traversal
        }

    
    // Right View
        vector<int> rightView(TreeNode* root) {
            vector<int> result;  // Result vector to store the right view nodes
            if (!root) return result;  // If root is null, return empty result

            queue<TreeNode*> q;  // Queue for level order traversal
            
            q.push(root);
            TreeNode* last = root;  // To track the last node of each level
            TreeNode* first = root; // To track the first node of each level

            while (!q.empty()) {
                TreeNode* x = q.front();
                q.pop();

                if (x->left != nullptr) q.push(x->left);
                if (x->right != nullptr) q.push(x->right);
                if (x == last && !q.empty()) {
                    result.push_back(x->val);  // Add the rightmost node to the result
                    first = q.front();         // Set the first node of the next level
                    last = q.back();           // Set the last node of the next level
                }
            }
            return result;
        }
    // Left View
        vector<int> leftView(TreeNode* root) {
            vector<int> result;  // Result vector to store the left view nodes
            if (!root) return result;  // If root is null, return empty result

            queue<TreeNode*> q;  // Queue for level order traversal
            q.push(root);
            TreeNode* last = root;  // To track the last node of each level
            TreeNode* first = root; // To track the first node of each level

            while (!q.empty()) {
                TreeNode* x = q.front();
                q.pop();

                if (x == first) {
                    result.push_back(x->val);  // Add the leftmost node to the result
                }

                if (x->left != nullptr) q.push(x->left);
                if (x->right != nullptr) q.push(x->right);

                if (x == last && !q.empty()) {
                    first = q.front();  // Set the first node of the next level
                    last = q.back();    // Set the last node of the next level
                }
            }
            
            return result;
        }
    // Vertical Order traversal
        vector<vector<int> > Solution::verticalOrderTraversal(TreeNode* A) {
            vector<vector<int>> result;
            if (!A) return result;

            // Map to store nodes at each vertical level
            map<int, vector<int>> nodes_map;

            // Queue to store nodes and their corresponding vertical levels
            queue<pair<TreeNode*, int>> q;
            q.push({A, 0});

            int min_vertical = 0, max_vertical = 0;

            // Perform level order traversal and populate the map
            while (!q.empty()) {
                auto front = q.front();
                q.pop();

                TreeNode* node = front.first;
                int vertical = front.second;

                nodes_map[vertical].push_back(node->val);

                // Update min and max vertical levels
                min_vertical = min(min_vertical, vertical);
                max_vertical = max(max_vertical, vertical);

                if (node->left) q.push({node->left, vertical - 1});
                if (node->right) q.push({node->right, vertical + 1});
            }

            // Iterate through vertical levels from min_vertical to max_vertical
            for (int vertical = min_vertical; vertical <= max_vertical; ++vertical) {
                result.push_back(nodes_map[vertical]);
            }

            return result;
        }
    // Top View
        vector<int> Solution::topView(TreeNode* A) {
            vector<int> result;
            if (!A) return result;

            map<int, int> top_view_map;
            queue<pair<TreeNode*, int>> q;
            q.push({A, 0});
            int min_vertical = 0, max_vertical = 0;

            while (!q.empty()) {
                auto front = q.front();
                q.pop();

                TreeNode* node = front.first;
                int vertical = front.second;

                if (!top_view_map.count(vertical)) { 
                    top_view_map[vertical] = node->val;
                }

                min_vertical = min(min_vertical, vertical);
                max_vertical = max(max_vertical, vertical);

                if (node->left) q.push({node->left, vertical - 1});
                if (node->right) q.push({node->right, vertical + 1});
            }

            for (int vertical = min_vertical; vertical <= max_vertical; ++vertical) {
                result.push_back(top_view_map[vertical]);
            }

            return result;
        }
    // Bottom View
        vector<int> bottomView(TreeNode* root) {
            vector<int> result;
            if (!root) return result; // If root is null, return empty result

            map<int, int> bottom_view_map;
            queue<pair<TreeNode*, int>> q;
            q.push({root, 0}); // Start with root at vertical level 0
            int min_vertical = 0, max_vertical = 0;

            while (!q.empty()) {
                auto front = q.front();
                q.pop();

                TreeNode* node = front.first;
                int vertical = front.second;

                bottom_view_map[vertical] = node->val;

                min_vertical = min(min_vertical, vertical);
                max_vertical = max(max_vertical, vertical);

                if (node->left) q.push({node->left, vertical - 1});
                if (node->right) q.push({node->right, vertical + 1});
            }

            for (int vertical = min_vertical; vertical <= max_vertical; ++vertical) {
                result.push_back(top_view_map[vertical]);
            }
            return result;
        }
    // Given a Perfect Binary Tree Find height of the tree
    // Given a Binary Tree check if it is a Balanced or Not
        int checkBalance(TreeNode* node) {
            if (!node) return 0;
     
            int leftDepth = checkBalance(node->left);
            if (leftDepth == -1) return -1;
            
            int rightDepth = checkBalance(node->right);
            if (rightDepth == -1) return -1;
            
            if (abs(leftDepth - rightDepth) > 1) return -1; 
            
            return 1 + max(leftDepth, rightDepth);
        }
    // ZigZag Level Order Traversal BT
    // Serialize Binary Tree
    // Deserialize Binary Tree
    // Q1. Level Order
        /*
        Q.1 -> Given a binary tree, return the level order traversal of its nodes' values. (i.e., from left to right, level by level).

        Note :
            

        Problem Constraints
        1 <= number of nodes <= 10^5

        Input Format
            First and only argument is root node of the binary tree, A. 

        Output Format
            Return a 2D integer array denoting the level order traversal of the given binary tree.

        Input 1:
            3
        / \
        9  20
            /  \
        15   7

        Output 1:
        [
        [3],
        [9, 20],
        [15, 7]
        ]

        Input 2:
        1
        / \
        6   2
            /
        3

        Output 2:
        [ 
        [1]
        [6, 2]
        [3]
        ]

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */

        vector<vector<int> > Solution::solve(TreeNode* root) {
            vector<vector<int>> result;
            if (!root) return result; // if root is null, return empty result
            
            queue<TreeNode*> q;
            q.push(root);
            
            while (!q.empty()) {
                int levelSize = q.size(); // number of nodes at the current level
                vector<int> currentLevel;
                
                for (int i = 0; i < levelSize; ++i) {
                    TreeNode* node = q.front(); // get the front node from the queue
                    q.pop(); // remove it from the queue
                    currentLevel.push_back(node->val); // add its value to the current level
                    
                    // Add the left child to the queue if it exists
                    if (node->left) q.push(node->left);
                    
                    // Add the right child to the queue if it exists
                    if (node->right) q.push(node->right);
                }
                
                // Add the current level to the result
                result.push_back(currentLevel);
            }
            
            return result;
        }
    // Q2. Right View of Binary tree
        /*
        Q.2 -> Given a binary tree of integers denoted by root A. Return an array of integers representing the right view of the Binary tree.
        Right view of a Binary Tree is a set of nodes visible when the tree is visited from Right side.

        Note :
            

        Problem Constraints
            1 <= Number of nodes in binary tree <= 100000
            0 <= node values <= 10^9

        Input Format
            First and only argument is head of the binary tree A.   

        Output Format
            Return an array, representing the right view of the binary tree.

        Input 1:
        
                    1
                /   \
                2    3
                / \  / \
            4   5 6  7
            /
            8 


        Output 1:
            [1, 3, 7, 8]

        Input 2:

                    1
                /  \
                2    3
                \
                    4
                    \
                    5

        Output 2:
            [1, 3, 4, 5]

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */
        vector<int> Solution::solve(TreeNode* A) {
            vector<int> rightView;
            if (!A) return rightView; // If the tree is empty, return an empty list
            
            queue<TreeNode*> q;
            q.push(A); // Start with the root node
            
            while (!q.empty()) {
                int levelSize = q.size(); // Number of nodes at the current level
                
                for (int i = 0; i < levelSize; ++i) {
                    TreeNode* node = q.front();
                    q.pop();
                    
                    // If this is the last node in the current level, add it to the right view
                    if (i == levelSize - 1) {
                        rightView.push_back(node->val);
                    }
                    
                    // Add the left and right children to the queue
                    if (node->left) q.push(node->left);
                    if (node->right) q.push(node->right);
                }
            }
            
            return rightView;
        }
    // Q3. Vertical Order traversal
        /*
        Q.3 -> Given a binary tree, return a 2-D array with vertical order traversal of it. Go through the example and image for more details.

        NOTE: If 2 Tree Nodes shares the same vertical level then the one with lesser depth will come first.

        Problem Constraints
            0 <= number of nodes <= 10^5

        Input Format
            First and only arument is a pointer to the root node of binary tree, A.

        Output Format
            Return a 2D array denoting the vertical order traversal of tree as shown.

        Input 1:
            6
            /   \
        3     7
        / \     \
        2   5     9

        Output 1:
        [
            [2],
            [3],
            [6, 5],
            [7],
            [9]
        ]

        Input 2:
            1
            /   \
        3     7
        /       \
        2         9

        Output 2:
        [
            [2],
            [3],
            [1],
            [7],
            [9]
        ]

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */
        vector<vector<int> > Solution::verticalOrderTraversal(TreeNode* A) {
            vector<vector<int>> result;
            if (!A) return result;

            // Map to store nodes at each vertical level
            map<int, vector<int>> nodes_map;

            // Queue to store nodes and their corresponding vertical levels
            queue<pair<TreeNode*, int>> q;
            q.push({A, 0});

            int min_vertical = 0, max_vertical = 0;

            // Perform level order traversal and populate the map
            while (!q.empty()) {
                auto front = q.front();
                q.pop();

                TreeNode* node = front.first;
                int vertical = front.second;

                nodes_map[vertical].push_back(node->val);

                // Update min and max vertical levels
                min_vertical = min(min_vertical, vertical);
                max_vertical = max(max_vertical, vertical);

                if (node->left) q.push({node->left, vertical - 1});
                if (node->right) q.push({node->right, vertical + 1});
            }

            // Iterate through vertical levels from min_vertical to max_vertical
            for (int vertical = min_vertical; vertical <= max_vertical; ++vertical) {
                result.push_back(nodes_map[vertical]);
            }

            return result;
        }
    // Q4. Balanced Binary Tree
        /*

        Q.4 -> Given a root of binary tree A, determine if it is height-balanced.
        A height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

        Note :

        Problem Constraints
            1 <= size of tree <= 100000

        Input Format
            First and only argument is the root of the tree A. 

        Output Format
            Return 0 / 1 ( 0 for false, 1 for true ) for this problem.

        Input 1:
            1
        / \
        2   3

        Output 1:
            1

        Input 2:
        
            1
            /
            2
            /
        3

        Output 2:
            0

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */

        int checkBalance(TreeNode* node) {
            if (!node) return 0; // Base case: empty node has height 0
            
            int leftDepth = checkBalance(node->left);  // Depth of left subtree
            if (leftDepth == -1) return -1; // Left subtree is not balanced
            
            int rightDepth = checkBalance(node->right); // Depth of right subtree
            if (rightDepth == -1) return -1; // Right subtree is not balanced
            
            // Check if the current node is balanced
            if (abs(leftDepth - rightDepth) > 1) return -1; 
            
            // Return the height of the current node
            return 1 + max(leftDepth, rightDepth);
        }


        int Solution::isBalanced(TreeNode* A) {
            return checkBalance(A) != -1;
        }
    // Q1. ZigZag Level Order Traversal BT
        /*
        Q.1 -> Given a binary tree, return the zigzag level order traversal of its nodes values. (ie, from left to right, then right to left for the next level and alternate between).

        Note :
            

        Problem Constraints
            1 <= number of nodes <= 10^5

        Input Format
            First and only argument is root node of the binary tree, A.   

        Output Format
            Return a 2D integer array denoting the zigzag level order traversal of the given binary tree.

        Input 1:
            3
        / \
        9  20
            /  \
        15   7

        Output 1:
        [
        [3],
        [20, 9],
        [15, 7]
        ]

        Input 2:
        1
        / \
        6   2
            /
        3

        Output 2:
        [ 
        [1]
        [2, 6]
        [3]
        ]

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */
        vector<vector<int> > Solution::zigzagLevelOrder(TreeNode* A) {
            vector<vector<int>> result;
            if (!A) return result;
            
            queue<TreeNode*> q;
            q.push(A);
            bool leftToRight = true; // Start with left to right traversal
            
            while (!q.empty()) {
                int size = q.size();
                vector<int> level(size);
                
                for (int i = 0; i < size; ++i) {
                    TreeNode* node = q.front();
                    q.pop();
                    
                    // Find the index to place node value in the level vector
                    int index = leftToRight ? i : (size - 1 - i);
                    level[index] = node->val;
                    
                    if (node->left) q.push(node->left);
                    if (node->right) q.push(node->right);
                }
                
                result.push_back(level);
                leftToRight = !leftToRight; // Toggle direction
            }
            
            return result;
        }
    // Q2. Serialize Binary Tree
        /*
        Q.2 -> Given the root node of a Binary Tree denoted by A. You have to Serialize the given Binary Tree in the described format.

        Serialize means encode it into a integer array denoting the Level Order Traversal of the given Binary Tree.

        NOTE:
            In the array, the NULL/None child is denoted by -1.
            For more clarification check the Example Input.

        Problem Constraints
            1 <= number of nodes <= 10^5

        Input Format
            Only argument is a A denoting the root node of a Binary Tree.  

        Output Format
            Return an integer array denoting the Level Order Traversal of the given Binary Tree.

        Input 1:
                1
                /   \
                2     3
            / \
            4   5

        Output 1:
            [1, 2, 3, 4, 5, -1, -1, -1, -1, -1, -1]

        Input 2:
                    1
                /   \
                2     3
                / \     \
            4   5     6

        Output 2:
            [1, 2, 3, 4, 5, -1, 6, -1, -1, -1, -1, -1, -1]

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */
        vector<int> Solution::solve(TreeNode* A) {
        vector<int> result;
            if (!A) return result;
            
            queue<TreeNode*> q;
            q.push(A);
            
            while (!q.empty()) {
                TreeNode* node = q.front();
                q.pop();
                
                if (node) {
                    result.push_back(node->val);
                    q.push(node->left);
                    q.push(node->right);
                } else {
                    result.push_back(-1);
                }
            }
            
            // We should not remove trailing -1s if they represent actual NULLs at the end of the array.
            return result;
        }
    // Q3. Deserialize Binary Tree
        /*
        Q.3 -> You are given an integer array A denoting the Level Order Traversal of the Binary Tree.
        You have to Deserialize the given Traversal in the Binary Tree and return the root of the Binary Tree.

        NOTE:
            In the array, the NULL/None child is denoted by -1.
            For more clarification check the Example Input.

        Problem Constraints
            1 <= number of nodes <= 10^5
            -1 <= A[i] <= 10^5

        Input Format
            Only argument is an integer array A denoting the Level Order Traversal of the Binary Tree.

        Output Format
            Return the root node of the Binary Tree.

        Input 1:
            A = [1, 2, 3, 4, 5, -1, -1, -1, -1, -1, -1]

        Output 1:
                1
                /   \
                2     3
            / \
            4   5

        Input 2:
            A = [1, 2, 3, 4, 5, -1, 6, -1, -1, -1, -1, -1, -1]

        Output 2:
                    1
                /   \
                2     3
                / \ .   \
            4   5 .   6

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */
        TreeNode* Solution::solve(vector<int> &A) {
            if (A.empty() || A[0] == -1) return NULL; // Empty input or root is NULL
            
            queue<TreeNode*> q;
            int index = 0;
            
            // Create the root node and add it to the queue
            TreeNode* root = new TreeNode(A[index++]);
            q.push(root);
            
            while (!q.empty() && index < A.size()) {
                TreeNode* node = q.front();
                q.pop();
                
                // Process the left child
                if (A[index] != -1) {
                    node->left = new TreeNode(A[index]);
                    q.push(node->left);
                }
                index++;
                
                // Process the right child
                if (index < A.size() && A[index] != -1) {
                    node->right = new TreeNode(A[index]);
                    q.push(node->right);
                }
                index++;
            }
            
            return root;
        }
    // Q4. Top View of Binary tree
        /*
        Q.4 -> Given a binary tree of integers denoted by root A. Return an array of integers representing the top view of the Binary tree.
        The top view of a Binary Tree is a set of nodes visible when the tree is visited from the top.
        Return the nodes in any order.

        Note :

        Problem Constraints
            1 <= Number of nodes in binary tree <= 100000
            0 <= node values <= 10^9

        Input Format
            First and only argument is head of the binary tree A.    

        Output Format
            Return an array, representing the top view of the binary tree.

        Input 1:
        
                    1
                /   \
                2    3
                / \  / \
            4   5 6  7
            /
            8 

        Output 1:
            [1, 2, 4, 8, 3, 7]

        Input 2:
        
                    1
                /  \
                2    3
                \
                    4
                    \
                    5

        Output 2:
            [1, 2, 3]

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */
        vector<int> Solution::solve(TreeNode* A) {
            if (!A) return {};

            map<int, int> topViewMap; // Map to store the first node at each horizontal distance
            queue<pair<TreeNode*, int>> q; // Queue to perform level-order traversal
            q.push({A, 0}); // Start with the root at horizontal distance 0

            while (!q.empty()) {
                auto front = q.front();
                q.pop();

                TreeNode* node = front.first;
                int hd = front.second;

                // If this horizontal distance is not yet recorded, add it
                if (topViewMap.find(hd) == topViewMap.end()) {
                    topViewMap[hd] = node->val;
                }

                // Add left and right children with updated horizontal distances
                if (node->left) {
                    q.push({node->left, hd - 1});
                }
                if (node->right) {
                    q.push({node->right, hd + 1});
                }
            }

            vector<int> result;
            // Collect the values in sorted order of horizontal distances
            for (const auto& entry : topViewMap) {
                result.push_back(entry.second);
            }

            return result;
        }

## BST ##
    // Search in BST
        TreeNode* searchBST(TreeNode* root, int target) {
            TreeNode* temp = root;
            while (temp != nullptr) {
                if(temp->val == target){
                    return temp;
                }
                if (temp->val > target)
                    root = root->left;
                else
                    root = root->right;
            }
            return nullptr;
        }
    // Insertion in BST
        TreeNode* insert(TreeNode* root, int key) {
            if (!root) return new TreeNode(key);  // Insert as root if tree is empty
            if (key < root->val)
                root->left = insert(root->left, key);  // Insert in left subtree
            else
                root->right = insert(root->right, key);  // Insert in right subtree
            return root;
        }

    // find minimum and maximum value in BST
        TreeNode* findMin(TreeNode* root) {
            TreeNode* temp = root;
            if (temp == nullptr) {
                return nullptr; // Tree is empty
            }
            while (temp->left != nullptr) {
                temp = temp->left; // Keep going left until you reach the leftmost node
            }
            return temp; // Return the leftmost node (minimum value)
        }

        TreeNode* findMax(TreeNode* root) {
            TreeNode* temp = root;
            if (temp == nullptr) {
                return nullptr; // Tree is empty
            }
            while (temp->right != nullptr) {
                temp = temp->right; // Keep going right until you reach the rightmost node
            }
            return temp; // Return the rightmost node (maximum value)
        }
    // Deletion in BST
        TreeNode* findMin(TreeNode* node) {
            while (node && node->left != nullptr) {
                node = node->left;
            }
            return node;
        }

        TreeNode* deleteNode(TreeNode* root, int key) {
            if (root == nullptr) return root;

            // If the key to be deleted is smaller than the root's key, go to the left subtree
            if (key < root->val) {
                root->left = deleteNode(root->left, key);
            }
            // If the key to be deleted is greater than the root's key, go to the right subtree
            else if (key > root->val) {
                root->right = deleteNode(root->right, key);
            }
            // If key is equal to root's key, this is the node to be deleted
            else {
                // Node with only one child or no child
                if (root->left == nullptr) {
                    TreeNode* temp = root->right;
                    delete root; // Free the memory of the node
                    return temp;
                } else if (root->right == nullptr) {
                    TreeNode* temp = root->left;
                    delete root; // Free the memory of the node
                    return temp;
                }

                // Node with two children: Get the inorder successor (smallest in the right subtree)
                TreeNode* temp = findMin(root->right);

                // Copy the inorder successor's content to this node
                root->val = temp->val;

                // Delete the inorder successor
                root->right = deleteNode(root->right, temp->val);
            }
            return root;
        }
    // Red Black Tree
    // AVL tree
    // Construct BST from Sorted Array
        TreeNode* sortedArrayToBST(int arr[], int start, int end) {
            // Base case: If the start index is greater than the end index, return nullptr
            if (start > end) {
                return nullptr;
            }

            // Find the middle index
            int mid = start + (end - start) / 2;

            // Create a new node with the middle element
            TreeNode* node = new TreeNode(arr[mid]);

            // Recursively build the left and right subtrees
            node->left = sortedArrayToBST(arr, start, mid - 1); // Left half
            node->right = sortedArrayToBST(arr, mid + 1, end); // Right half

            return node;
        }

    // Counstruct Bst from Unsorted Array
        TreeNode* insert(TreeNode* root, int val) {
            // If the root is null, create a new node and return it
            if (root == nullptr) {
                return new TreeNode(val);
            }

            // Recur down the tree to find the correct position
            if (val < root->val) {
                root->left = insert(root->left, val);
            } else {
                root->right = insert(root->right, val);
            }
            return root;
        }
        // Function to construct a BST from an unsorted array
        TreeNode* constructBST(int arr[], int n) {
            TreeNode* root = nullptr;
            for (int i = 0; i < n; i++) {
                root = insert(root, arr[i]); // Insert each element into the BST
            }
            return root;
        }
    // Check if a Binary Tree is BST or not
        bool isBSTUtil(TreeNode* node, int minVal, int maxVal) {
            // An empty tree is a BST
            if (node == nullptr) {
                return true;
            }

            // Check if the current node's value is within the valid range
            if (node->val < minVal || node->val > maxVal) {
                return false;
            }

            // Recursively check the left subtree and right subtree
            return isBSTUtil(node->left, minVal, node->val - 1) && 
                isBSTUtil(node->right, node->val + 1, maxVal);
        }

        bool isBST(TreeNode* root) {
            return isBSTUtil(root, INT_MIN, INT_MAX);
        }
    // Q1. Search in BST
        /*
        Q.1 -> Given a Binary Search Tree A. Check whether there exists a node with value B in the BST.

        Note :
            

        Problem Constraints
            1 <= Number of nodes in binary tree <= 10^5
            0 <= B <= 10^6

        Input Format
            First argument is a root node of the binary tree, A.
            Second argument is an integer B.

        Output Format
            Return 1 if such a node exist and 0 otherwise

        Input 1:
                    15
                /    \
                12      20
                / \    /  \
            10  14  16  27
            /
            8

            B = 16

        Output 1:
            1

        Input 2:
                    8
                / \
                6  21
                / \
                1   7

            B = 9

        Output 2:
            0

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */
        int Solution::solve(TreeNode* A, int B) {
            // Start from the root node
            TreeNode* current = A;

            // Traverse the tree
            while (current != NULL) {
                if (current->val == B) {
                    // If the current node's value is equal to B, return 1
                    return 1;
                } else if (B < current->val) {
                    // If B is less than current node's value, move to the left child
                    current = current->left;
                } else {
                    // If B is greater than current node's value, move to the right child
                    current = current->right;
                }
            }

            // If we exit the loop, B was not found in the tree
            return 0;
        }
    // Q2. Delete a node in BST
        /*
        Q.2 -> Given a Binary Search Tree(BST) A. If there is a node with value B present in the tree delete it and return the tree.

        Note - If there are multiple options, always replace a node by its in-order predecessor

        Problem Constraints
            2 <= No. of nodes in BST <= 10^5
            1 <= value of nodes <= 10^9
            Each node has a unique value

        Input Format
            The first argument is the root node of a Binary Search Tree A.
            The second argument is the value B.  

        Output Format
            Delete the given node if found and return the root of the BST.

        Input 1:
                    15
                /    \
                12      20
                / \    /  \
            10  14  16  27
            /
            8

            B = 10


        Output 1:
                    15
                /    \
                12      20
                / \    /  \
            8  14  16  27

        Input 2:
                    8
                / \
                6  21
                / \
                1   7

            B = 6


        Output 2:
                    8
                / \
                1  21
                \
                    7

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */

        TreeNode* findMax(TreeNode* node) {
            while (node->right != NULL) {
                node = node->right;
            }
            return node;
        }

        TreeNode* Solution::solve(TreeNode* A, int B) {
            // Base case: if the tree is empty, return NULL
            if (A == NULL) {
                return NULL;
            }

            // If the value to be deleted is less than the root's value, it lies in the left subtree
            if (B < A->val) {
                A->left = solve(A->left, B);
            }
            // If the value to be deleted is greater than the root's value, it lies in the right subtree
            else if (B > A->val) {
                A->right = solve(A->right, B);
            }
            // If the value is the same as the root's value, then this is the node to be deleted
            else {
                // Node with only one child or no child
                if (A->left == NULL) {
                    TreeNode* temp = A->right;
                    delete A;
                    return temp;
                }
                else if (A->right == NULL) {
                    TreeNode* temp = A->left;
                    delete A;
                    return temp;
                }

                // Node with two children: Get the in-order predecessor (maximum in the left subtree)
                TreeNode* temp = findMax(A->left);

                // Copy the in-order predecessor's content to this node
                A->val = temp->val;

                // Delete the in-order predecessor
                A->left = solve(A->left, temp->val);
            }
            return A;

        }
    // Q3. Sorted Array To Balanced BST
        /*
        Q.3 -> Given an array where elements are sorted in ascending order, convert it to a height Balanced Binary Search Tree (BBST).
        Balanced tree : a height-balanced binary tree is defined as a binary tree in which the depth of the two subtrees of every node never differ by more than 1.

        Note :

        Problem Constraints
            1 <= length of array <= 100000

        Input Format
            First argument is an integer array A.

        Output Format
            Return a root node of the Binary Search Tree.

        Input 1:
            A : [1, 2, 3]

        Output 1:
            2
            /   \
        1     3

        Input 2:
            A : [1, 2, 3, 5, 10]

        Output 2:
            3
            /   \
        2     5
        /       \
        1         10

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */

        TreeNode* buildBST(const vector<int> &A, int start, int end) {
            // Base case: if the subarray is invalid, return NULL
            if (start > end) {
                return NULL;
            }

            // Find the middle element to be the root of the current subtree
            int mid = start + (end - start) / 2;

            // Create the root node with the middle element
            TreeNode* node = new TreeNode(A[mid]);

            // Recursively construct the left and right subtrees
            node->left = buildBST(A, start, mid - 1);
            node->right = buildBST(A, mid + 1, end);

            return node;
        }
        TreeNode* Solution::sortedArrayToBST(const vector<int> &A) {
            return buildBST(A, 0, A.size() - 1);
        }
    // Q4. Valid Binary Search Tree
        /*
        Q.4 -> You are given a binary tree represented by root A. You need to check if it is a Binary Search Tree or not.
        Assume a BST is defined as follows:
        1) The left subtree of a node contains only nodes with keys less than the node's key.
        2) The right subtree of a node contains only nodes with keys greater than the node's key.
        3) Both the left and right subtrees must also be binary search trees.

        Note :
            

        Problem Constraints
            1 <= Number of nodes in binary tree <= 105
            0 <= node values <= 232-1

        Input Format
            First and only argument is head of the binary tree A.

        Output Format
            Return 0 if false and 1 if true.

        Input 1:
        
        1
        /  \
        2    3

        Output 1:
        0

        Input 2:
        
        2
        / \
        1   3

        Output 2:
        1

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */

        bool validate(TreeNode* node, long long minVal, long long maxVal) {
            // Base case: if the node is NULL, it's valid
            if (node == NULL) {
                return true;
            }

            // Check if the current node's value is within the allowed range
            if (node->val <= minVal || node->val >= maxVal) {
                return false;
            }

            // Recursively validate the left and right subtrees
            return validate(node->left, minVal, node->val) &&
                validate(node->right, node->val, maxVal);
        }


        int Solution::isValidBST(TreeNode* A) {
            // Initialize the range with the minimum and maximum possible values
            return validate(A, LLONG_MIN, LLONG_MAX) ? 1 : 0;
        }
    // Q1. Check for BST with One Child
        /*
        Q.1 -> Given preorder traversal of a binary tree, check if it is possible that it is also a preorder traversal of a Binary Search Tree (BST), where each internal node (non-leaf nodes) have exactly one child.

        Note :
            
        Problem Constraints
            1 <= number of nodes <= 100000

        Input Format
            First and only argument is an integer array denoting the preorder traversal of binary tree.

        Output Format
            Return a string "YES" if true else "NO".

        Input 1:
            A : [4, 10, 5, 8]

        Output 1:
            "YES"

        Input 2:
            A : [1, 5, 6, 4]

        Output 2:
            "NO"

        */

        // CODE
        string Solution::solve(vector<int> &A) {
            // Initialize the boundaries for left and right children
            int left = INT_MIN;
            int right = INT_MAX;

            // The first element is the root of the BST
            int root = A[0];

            // Iterate over the rest of the array
            for (int i = 1; i < A.size(); i++) {
                // If the current value is greater than root, it should be on the right side
                if (A[i] > root) {
                    left = root; // Update the left boundary
                } 
                // If the current value is less than or equal to root, it should be on the left side
                else {
                    right = root; // Update the right boundary
                }

                // Check if the current value violates the BST property
                if (A[i] < left || A[i] > right) {
                    return "NO"; // Invalid BST
                }

                // Update the root for the next iteration
                root = A[i];
            }

            return "YES"; // Valid BST
        }
    // Q2. BST nodes in a range
        /*
        Q.2 -> Given a binary search tree of integers. You are given a range B and C.
        Return the count of the number of nodes that lie in the given range.

        Note :
            

        Problem Constraints
            1 <= Number of nodes in binary tree <= 100000
            0 <= B < = C <= 10^9

        Input Format
            First argument is a root node of the binary tree, A.
            Second argument is an integer B.
            Third argument is an integer C.

        Output Format
            Return the count of the number of nodes that lies in the given range.

        Input 1:
                    15
                /    \
                12      20
                / \    /  \
            10  14  16  27
            /
            8

            B = 12
            C = 20

        Output 1:
            5

        Input 2:
                    8
                / \
                6  21
                / \
                1   7

            B = 2
            C = 20

        Output 2:
            3

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */

        int countNodesInRange(TreeNode* node, int B, int C) {
            if (node == NULL) {
                return 0;
            }
            
            int count = 0;

            // If the current node's value is within the range, count this node
            if (node->val >= B && node->val <= C) {
                count = 1;
            }

            // Recursively count nodes in the left and right subtrees
            if (node->val > B) {
                count += countNodesInRange(node->left, B, C);
            }
            if (node->val < C) {
                count += countNodesInRange(node->right, B, C);
            }

            return count;
        }

        int Solution::solve(TreeNode* A, int B, int C) {
            return countNodesInRange(A, B, C);
        }
    // Q3. Two Sum BST
        /*
        Q.3 -> Given a binary search tree A, where each node contains a positive integer, and an integer B, you have to find whether or not there exist two different nodes X and Y such that X.value + Y.value = B.
        Return 1 to denote that two such nodes exist. Return 0, otherwise.

        Note :
            

        Problem Constraints
            1 <= size of tree <= 100000
            1 <= B <= 10^9

        Input Format
            First argument is the head of the tree A.
            Second argument is the integer B.    

        Output Format
            Return 1 if such a pair can be found, 0 otherwise.

        Input 1:
        Input 1:

                10
                / \
                9   20

        B = 19

        Output 1:
            1

        Input 2:
        
                10
                / \
                9   20

        B = 40

        Output 2:
            0

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */
        void inOrderTraversal(TreeNode* node, vector<int>& values) {
            if (node == NULL) {
                return;
            }
            inOrderTraversal(node->left, values);
            values.push_back(node->val);
            inOrderTraversal(node->right, values);
        }

        int Solution::t2Sum(TreeNode* A, int B) {
            vector<int> values;
            inOrderTraversal(A, values);
            
            int left = 0;
            int right = values.size() - 1;
            
            while (left < right) {
                int sum = values[left] + values[right];
                if (sum == B) {
                    return 1;
                } else if (sum < B) {
                    left++;
                } else {
                    right--;
                }
            }
            
            return 0;
        }

## LCA + Morris Inorder Traversal ##
    // Find K th Smallest Element in BST 
        int count = 0; // Counter to track number of nodes visited
        int result = -1; // Stores the Kth smallest value

        void inOrder(TreeNode* root, int k) {
            if (root == NULL) return;

            // Traverse left subtree
            inOrder(root->left, k);

            // Visit the node
            count++;
            if (count == k) {
                result = root->val;
                return;
            }

            // Traverse right subtree
            inOrder(root->right, k);
        }

        int kthSmallest(TreeNode* root, int k) {
            inOrder(root, k);
            return result;
        }

    // Morris Inorder Traversal
        void morrisInOrderTraversal(TreeNode* root) {
            TreeNode* current = root;

            while (current != NULL) {
                if (current->left == NULL) {
                    // Visit the current node since there is no left subtree
                    cout << current->val << " ";
                    current = current->right;
                } else {
                    // Find the in-order rightMost_of_curr_L of current
                    TreeNode* rightMost_of_curr_L = current->left;
                    while (rightMost_of_curr_L->right != NULL && rightMost_of_curr_L->right != current) {
                        rightMost_of_curr_L = rightMost_of_curr_L->right;
                    }

                    if (rightMost_of_curr_L->right == NULL) {
                        // Make a temporary link to the current node
                        rightMost_of_curr_L->right = current;
                        current = current->left;
                    } else {
                        // Remove the temporary link and visit the current node
                        rightMost_of_curr_L->right = NULL;
                        cout << current->val << " ";
                        current = current->right;
                    }
                }
            }
        }
    // Morris Preorder Traversal
        void morrisPrOrderTraversal(TreeNode* root) {
            TreeNode* current = root;

            while (current != NULL) {
                if (current->left == NULL) {
                    // Visit the current node since there is no left subtree
                    cout << current->val << " ";
                    current = current->right;
                } else {
                    // Find the in-order rightMost_of_curr_L of current
                    TreeNode* rightMost_of_curr_L = current->left;
                    while (rightMost_of_curr_L->right != NULL && rightMost_of_curr_L->right != current) {
                        rightMost_of_curr_L = rightMost_of_curr_L->right;
                    }
                    if (rightMost_of_curr_L->right == NULL) {
                        cout << current->val << " ";
                        // Make a temporary link to the current node
                        rightMost_of_curr_L->right = current;
                        current = current->left;
                    } else {
                        // Remove the temporary link and visit the current node
                        rightMost_of_curr_L->right = NULL;
                        current = current->right;
                    }
                }
            }
        }
    // Path From Root To Node
        bool getPath(TreeNode* root, vector<int>& path, int target) {
            if (root == NULL) return false;

            // Add the current node to the path
            path.push_back(root->val);

            // Check if the current node is the target node
            if (root->val == target) {
                return true;
            }

            // Recur for left and right subtrees
            if (getPath(root->left, path, target) || getPath(root->right, path, target)) {
                return true;
            }

            // If not found in either subtree, remove the current node from path
            path.pop_back();
            return false;
        }
    // Lowest Common Ancestor
        // Solution 1 (Find last common in Path from Root to Node)
            // Helper function to find the path from the root node to the target node
            bool findPath(TreeNode* root, TreeNode* target, vector<TreeNode*>& path) {
                if (root == NULL) {
                    return false;
                }

                // Add the current node to the path
                path.push_back(root);

                // Check if we have reached the target node
                if (root == target) {
                    return true;
                }

                // Recur for left and right subtrees
                if (findPath(root->left, target, path) || findPath(root->right, target, path)) {
                    return true;
                }

                // If not present in either subtree, remove root from path and backtrack
                path.pop_back();
                return false;
            }
            // Function to find LCA by comparing paths from root to each node
            TreeNode* findLCA(TreeNode* root, TreeNode* p, TreeNode* q) {
                vector<TreeNode*> path1, path2;

                // Find paths from root to p and q
                if (!findPath(root, p, path1) || !findPath(root, q, path2)) {
                    return NULL; // If either p or q is not present in the tree
                }

                // Compare the paths to find the last common node
                int i;
                for (i = 0; i < path1.size() && i < path2.size(); i++) {
                    if (path1[i] != path2[i]) {
                        break;
                    }
                }

                // The last common node is the LCA
                return path1[i - 1];
            }

        // Solution 2 (Recursive Traversal)
            TreeNode* findLCA(TreeNode* root, TreeNode* p, TreeNode* q) {
                // Base case: if root is null or root is one of the nodes p or q
                if (root == NULL || root == p || root == q) {
                    return root;
                }

                // Recur for the left and right subtrees
                TreeNode* left = findLCA(root->left, p, q);
                TreeNode* right = findLCA(root->right, p, q);

                // If both left and right are non-null, p and q are found in different branches
                if (left != NULL && right != NULL) {
                    return root;
                }

                // Otherwise, return the non-null node
                return (left != NULL) ? left : right;
            }
    // LCA in BST
        TreeNode* findLCA(TreeNode* root, TreeNode* p, TreeNode* q) {
            while (root != NULL) {
                // If both p and q are smaller than root, then LCA is in the left subtree
                if (p->val < root->val && q->val < root->val) {
                    root = root->left;
                }
                // If both p and q are greater than root, then LCA is in the right subtree
                else if (p->val > root->val && q->val > root->val) {
                    root = root->right;
                }
                // If one node is on the left and the other is on the right, root is the LCA
                else {
                    return root;
                }
            }
            return NULL; // If root is NULL, LCA does not exist
        }
    // Q1. Least Common Ancestor
        /*
        Q.1 -> Find the lowest common ancestor in an unordered binary tree A, given two values, B and C, in the tree.
        Lowest common ancestor: the lowest common ancestor (LCA) of two nodes and w in a tree or directed acyclic graph (DAG) is the lowest (i.e., deepest) node that has both v and w as descendants.

        Note :

        Problem Constraints
            1 <= size of tree <= 100000
            1 <= B, C <= 109   

        Input Format
            First argument is head of tree A.
            Second argument is integer B.
            Third argument is integer C.    

        Output Format
            Return the LCA.

        Input 1:
            1
            /  \
            2    3
        B = 2
        C = 3


        Output 1:
        1

        Input 2:
            1
            /  \
            2    3
        / \
        4   5
        B = 4
        C = 5

        Output 2:
        2

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */


        TreeNode* findLCA(TreeNode* root, int B, int C, bool &foundB, bool &foundC) {
            // Base case: if root is null, return null
            if (root == NULL) {
                return NULL;
            }

            // If current node is either B or C, mark them as found and return this node
            if (root->val == B) {
                foundB = true;
                return root;
            }
            if (root->val == C) {
                foundC = true;
                return root;
            }

            // Recursively search in left and right subtrees
            TreeNode* leftLCA = findLCA(root->left, B, C, foundB, foundC);
            TreeNode* rightLCA = findLCA(root->right, B, C, foundB, foundC);

            // If both left and right calls return non-null, this node is the LCA
            if (leftLCA != NULL && rightLCA != NULL) {
                return root;
            }

            // Otherwise return the non-null child, or null if both are null
            return (leftLCA != NULL) ? leftLCA : rightLCA;
        }

        bool find(TreeNode* root, int val) {
            if (root == NULL) {
                return false;
            }
            if (root->val == val || find(root->left, val) || find(root->right, val)) {
                return true;
            }
            return false;
        }


        int Solution::lca(TreeNode* A, int B, int C) {
            bool foundB = false, foundC = false;

            // Find the LCA of B and C
            TreeNode* lcaNode = findLCA(A, B, C, foundB, foundC);

            // Ensure both B and C are found in the tree before returning the LCA
            if (foundB && foundC) {
                return lcaNode->val;
            }

            // If B and C are not found, check if the other node is still in the tree
            if (foundB && find(A, C)) {
                return lcaNode->val;
            }
            if (foundC && find(A, B)) {
                return lcaNode->val;
            }

            // If either B or C is missing from the tree, return -1
            return -1;
        }
    // Q2. Kth Smallest Element In BST
        /*
        Q.2 -> Given a binary search tree represented by root A, write a function to find the Bth smallest element in the tree.

        Note :
            

        Problem Constraints
            1 <= Number of nodes in binary tree <= 100000
            0 <= node values <= 10^9

        Input Format
            First and only argument is head of the binary tree A.

        Output Format
            Return an integer, representing the Bth element.

        Input 1:
                    2
                /   \
                1    3
        B = 2


        Output 1:
            2

        Input 2:
                    3
                /
                2
                /
                1
        B = 1

        Output 2:
            1

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */

        void inorder(TreeNode* root, int &count, int B, int &result) {
            if (root == NULL || count >= B) {
                return;
            }
            
            // Traverse the left subtree
            inorder(root->left, count, B, result);
            
            // Increment count of nodes visited
            count++;
            
            // If count matches B, we found the B-th smallest element
            if (count == B) {
                result = root->val;
                return;
            }
            
            // Traverse the right subtree
            inorder(root->right, count, B, result);
        }

        int Solution::kthsmallest(TreeNode* A, int B) {
            int count = 0;    // To track the number of visited nodes
            int result = -1;  // To store the B-th smallest element
            
            // Perform in-order traversal
            inorder(A, count, B, result);
            
            return result;
        }
    // Q3. LCA in BST
        /*
        Q.3 -> 
        Given a Binary Search Tree A. Also given are two nodes B and C. Find the lowest common ancestor of the two nodes.
        Note 1 :- It is guaranteed that the nodes B and C exist.
        Note 2 :- The LCA of B and C in A is the shared ancestor of B and C that is located farthest from the root.

        Problem Constraints
            1 <= Number of nodes in binary tree <= 105
            1 <= B , C <= 105   

        Input Format
            First argument is a root node of the binary tree, A.
            Second argument is an integer B.
            Third argument is an integer C.    

        Output Format
            Return the LCA of the two nodes

        Input 1:
                    15
                /    \
                12      20
                / \    /  \
            10  14  16  27
            /
            8

            B = 8
            C = 20

        Output 1:
            15

        Input 2:
                    8
                / \
                6  21
                / \
                1   7

            B = 7
            C = 1

        Output 2:
            6

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */
        int Solution::solve(TreeNode* A, int B, int C) {
            TreeNode* current = A;
            
            while (current != NULL) {
                // If both B and C are smaller than current node, move to the left subtree
                if (B < current->val && C < current->val) {
                    current = current->left;
                }
                // If both B and C are greater than current node, move to the right subtree
                else if (B > current->val && C > current->val) {
                    current = current->right;
                }
                // Otherwise, current node is the LCA
                else {
                    return current->val;
                }
            }
            
            return -1; // This return is never reached because the problem guarantees B and C exist in the tree
        }
    // Q4. Morris Inorder Traversal
        /*
        Q.4 -> 
        Given a binary tree, return the inorder traversal of its nodes' values.
        NOTE: Using recursion and stack are not allowed.

        Problem Constraints
            1 <= number of nodes <= 105

        Input Format
            First and only argument is root node of the binary tree, A.

        Output Format
            Return an integer array denoting the inorder traversal of the given binary tree.

        Input 1:
        1
            \
            2
            /
        3


        Output 1:
            [1, 3, 2]

        Input 2:
        1
        / \
        6   2
            /
        3

        Output 2:
            [6, 1, 3, 2]

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */
        vector<int> Solution::solve(TreeNode* A) {
            vector<int> result;
            TreeNode* current = A;
            
            while (current != NULL) {
                // Case 1: If there is no left child, visit this node and move to right child
                if (current->left == NULL) {
                    result.push_back(current->val);
                    current = current->right;
                }
                // Case 2: If there is a left child, find the inorder predecessor
                else {
                    TreeNode* predecessor = current->left;
                    // Find the rightmost node in the left subtree
                    while (predecessor->right != NULL && predecessor->right != current) {
                        predecessor = predecessor->right;
                    }
                    
                    // Case 2a: If predecessor's right child is NULL, set it to the current node and move to left child
                    if (predecessor->right == NULL) {
                        predecessor->right = current;
                        current = current->left;
                    }
                    // Case 2b: If predecessor's right child is already current, remove the link and visit current node
                    else {
                        predecessor->right = NULL;  // Remove the temporary link
                        result.push_back(current->val);  // Visit current node
                        current = current->right;  // Move to right child
                    }
                }
            }
            
            return result;
        }
    // Q1. Recover Binary Search Tree
        /*
        Q.1 -> Two elements of a Binary Search Tree (BST), represented by root A are swapped by mistake. Tell us the 2 values, when swapped, will restore the Binary Search Tree (BST).
        A solution using O(n) space is pretty straightforward. Could you devise a constant space solution?
        Note: The 2 values must be returned in ascending order

        Note :

        Problem Constraints
            1 <= size of tree <= 100000

        Input Format
            First and only argument is the head of the tree,A    

        Output Format
            Return the 2 elements which need to be swapped.

        Input 1:
                1 
                / \ 
            2   3

        Output 1:
            [2, 1]

        Input 2:
                2
                / \
            3   1

        Output 2:
            [3, 1]

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */
        vector<int> Solution::recoverTree(TreeNode* A) {
            TreeNode* current = A;
            TreeNode* prev = NULL;  // To track the previous node in inorder traversal
            TreeNode* first = NULL; // First node where the violation occurs
            TreeNode* second = NULL; // Second node where the violation occurs
            
            while (current != NULL) {
                if (current->left == NULL) {
                    // Check for swapped nodes
                    if (prev != NULL && prev->val > current->val) {
                        if (first == NULL) {
                            first = prev;
                        }
                        second = current;
                    }
                    // Move prev to current
                    prev = current;
                    current = current->right;
                } else {
                    // Find the inorder predecessor of current
                    TreeNode* predecessor = current->left;
                    while (predecessor->right != NULL && predecessor->right != current) {
                        predecessor = predecessor->right;
                    }
                    
                    // If the right child of predecessor is NULL, set it to current and move to left child
                    if (predecessor->right == NULL) {
                        predecessor->right = current;
                        current = current->left;
                    } 
                    // If the right child of predecessor is already current, remove the link and visit current
                    else {
                        predecessor->right = NULL;
                        // Check for swapped nodes
                        if (prev != NULL && prev->val > current->val) {
                            if (first == NULL) {
                                first = prev;
                            }
                            second = current;
                        }
                        // Move prev to current
                        prev = current;
                        current = current->right;
                    }
                }
            }
            
            // Return the swapped values in ascending order
            vector<int> result;
            result.push_back(min(first->val, second->val));
            result.push_back(max(first->val, second->val));
            
            return result;
        }
    // Q2. Common Nodes in Two BST
        /*
        Q.2 -> 
        Given two BST's A and B, return the (sum of all common nodes in both A and B) % (109 +7) .
        In case there is no common node, return 0.

        NOTE: Try to do it one pass through the trees.

        Problem Constraints
            1 <= Number of nodes in the tree A and B <= 105
            1 <= Node values <= 106   

        Input Format
            First argument represents the root of BST A.
            Second argument represents the root of BST B.

        Output Format
            Return an integer denoting the (sum of all common nodes in both BST's A and B) % (109 +7) .

        Input 1:
        Tree A:
            5
        / \
        2   8
        \   \
            3   15
                /
                9

        Tree B:
            7
        / \
        1  10
        \   \
            2  15
            /
            11

        Output 1:
            17

        Input 2:
        Tree A:
            7
        / \
        1   10
        \   \
            2   15
                /
            11

        Tree B:
            7
        / \
        1  10
        \   \
            2  15
            /
            11

        Output 2:
            46

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */
        int Solution::solve(TreeNode* A, TreeNode* B) {
            const int MOD = 1e9 + 7;
            stack<TreeNode*> stackA, stackB;
            int sum = 0;

            // Push left subtree nodes onto stack
            auto pushLeft = [](TreeNode* node, stack<TreeNode*>& st) {
                while (node != NULL) {
                    st.push(node);
                    node = node->left;
                }
            };

            // Initialize the stack with left-most nodes of both trees
            pushLeft(A, stackA);
            pushLeft(B, stackB);

            // Traverse both trees in-order using stack
            while (!stackA.empty() && !stackB.empty()) {
                TreeNode* topA = stackA.top();
                TreeNode* topB = stackB.top();

                if (topA->val == topB->val) {
                    // Common node found, add to sum
                    sum = (sum + topA->val) % MOD;
                    
                    // Pop both nodes and push their right subtrees
                    stackA.pop();
                    stackB.pop();
                    pushLeft(topA->right, stackA);
                    pushLeft(topB->right, stackB);
                }
                else if (topA->val < topB->val) {
                    // Move forward in tree A
                    stackA.pop();
                    pushLeft(topA->right, stackA);
                } else {
                    // Move forward in tree B
                    stackB.pop();
                    pushLeft(topB->right, stackB);
                }
            }

            return sum;
        }
    // Q3. Distance between Nodes of BST
        /*
        Q.3 -> 
        Given a binary search tree.
        Return the distance between two nodes with given two keys B and C. It may be assumed that both keys exist in BST.

        NOTE: Distance between two nodes is number of edges between them.


        Note :
            

        Problem Constraints
            1 <= Number of nodes in binary tree <= 1000000
            0 <= node values <= 109   

        Input Format
            First argument is a root node of the binary tree, A.
            Second argument is an integer B.
            Third argument is an integer C.

        Output Format
            Return an integer denoting the distance between two nodes with given two keys B and C

        Input 1:
            
                5
            /   \
            2     8
            / \   / \
            1   4 6   11
        B = 2
        C = 11

        Output 1:
            3

        Input 2:
        
                6
            /   \
            2     9
            / \   / \
            1   4 7   10
        B = 2
        C = 6

        Output 2:
            1

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */

        // Function to find the Lowest Common Ancestor (LCA) of two nodes B and C
        TreeNode* findLCA(TreeNode* root, int B, int C) {
            if (!root) return NULL;

            // If both B and C are smaller than root, LCA lies in the left subtree
            if (B < root->val && C < root->val)
                return findLCA(root->left, B, C);

            // If both B and C are greater than root, LCA lies in the right subtree
            if (B > root->val && C > root->val)
                return findLCA(root->right, B, C);

            // If one node is smaller and the other is larger, root is the LCA
            return root;
        }

        // Function to find the distance from the LCA to a given node
        int findDistance(TreeNode* root, int key) {
            int dist = 0;
            while (root != NULL) {
                if (key < root->val) {
                    root = root->left;
                } else if (key > root->val) {
                    root = root->right;
                } else {
                    return dist; // Found the key
                }
                dist++;
            }
            return dist;
        }

        int Solution::solve(TreeNode* A, int B, int C) {
            // Find the Lowest Common Ancestor (LCA)
            TreeNode* lca = findLCA(A, B, C);

            // Calculate distance from LCA to B and from LCA to C
            int distB = findDistance(lca, B);
            int distC = findDistance(lca, C);

            // The total distance is the sum of both distances
            return distB + distC;
        }

## Problems on Trees ##
    // Invert The Binary Tree
    // Equal Tree Partition
    // Next Pointer to Binary Tree
    // Check if Root to Leaf path sum is equal to K
    // Diameter in Binary Tree
    // Path Sum
    // Identical Binary Trees
    // Q1. Next Pointer Binary Tree
        /*
        Q.1 -> 
        Given a binary tree,
        Populate each next pointer to point to its next right node. If there is no next right node, the next pointer should be set to NULL.
        Initially, all next pointers are set to NULL.
        Assume perfect binary tree.

        Problem Constraints
            1 <= Number of nodes in binary tree <= 100000
            0 <= node values <= 10^9

        Input Format
            First and only argument is head of the binary tree A.

        Output Format
            Return the head of the binary tree after the changes are made.

        Input 1:
            1
            /  \
        2    3

        Output 1:
        
                1 -> NULL
            /  \
            2 -> 3 -> NULL

        Input 2:
        
                1
            /  \
            2    5
            / \  / \
            3  4  6  7


        Output 2:
        
                1 -> NULL
            /  \
            2 -> 5 -> NULL
            / \  / \
            3->4->6->7 -> NULL

        */

        // CODE
        /**
        * Definition for binary tree with next pointer.
        * struct TreeLinkNode {
        *  int val;
        *  TreeLinkNode *left, *right, *next;
        *  TreeLinkNode(int x) : val(x), left(NULL), right(NULL), next(NULL) {}
        * };
        */
        void Solution::connect(TreeLinkNode* A) {
            if (!A) return;  // If the tree is empty, return immediately.

            TreeLinkNode* current = A;  // Start from the root.
            
            while (current->left) {  // Since it's a perfect binary tree, if a node has a left child, it must have a right child.
                TreeLinkNode* nextLevel = current;  // Start from the beginning of the current level.
                
                while (nextLevel) {  // Traverse through the current level using the `next` pointers.
                    // Connect the left child to the right child.
                    nextLevel->left->next = nextLevel->right;
                    
                    // If there is a next node, connect the right child to the next node's left child.
                    if (nextLevel->next) {
                        nextLevel->right->next = nextLevel->next->left;
                    }
                    
                    // Move to the next node at the current level.
                    nextLevel = nextLevel->next;
                }
                
                // Move to the next level.
                current = current->left;
            }
        }

    // Q2. Diameter of binary tree
        /*
        Q.2 -> 
        Given a Binary Tree A consisting of N integer nodes, you need to find the diameter of the tree.
        The diameter of a tree is the number of edges on the longest path between two nodes in the tree.

        Problem Constraints
            0 <= N <= 105

        Input Format
            First and only Argument represents the root of binary tree A.

        Output Format
            Return an single integer denoting the diameter of the tree.

        Input 1:
                1
                /   \
                2     3
            / \
            4   5

        Output 1:
            3

        Input 2:
                    1
                /   \
                2     3
                / \     \
            4   5     6

        Output 2:
            4

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */

        pair<int, int> Depth(TreeNode* A) {
            if (A == NULL) return {0, 0};  // Base case: empty node has depth 0, diameter 0

            pair<int, int> leftDepth = Depth(A->left);  // Get depth/diameter from left subtree
            pair<int, int> rightDepth = Depth(A->right);  // Get depth/diameter from right subtree

            // Update the depth for the current node
            int currentDepth = 1 + max(leftDepth.first, rightDepth.first);

            // Compute the maximum path through the current node
            int currentMaxPath = leftDepth.first + rightDepth.first;

            // Compute the largest path (diameter) seen so far
            int largestPath = max({leftDepth.second, rightDepth.second, currentMaxPath});

            return {currentDepth, largestPath};  // Return depth and largest path (diameter)
        }

        int Solution::solve(TreeNode* A) {
            if (A == NULL) return 0;  // Edge case: empty tree

            pair<int, int> result = Depth(A);  // Get depth and diameter from the root
            return result.second;  // Return the diameter (stored in result.second)
        }
    // Q3. Path Sum
        /*
        Q.3 -> Given a binary tree and a sum, determine if the tree has a root-to-leaf path such that adding up all the values along the path equals the given sum.

        Problem Constraints
            1 <= number of nodes <= 105
            -100000 <= B, value of nodes <= 100000   

        Input Format
            First argument is a root node of the binary tree, A.
            Second argument is an integer B denoting the sum.    

        Output Format
            Return 1, if there exist root-to-leaf path such that adding up all the values along the path equals the given sum. Else, return 0.

        Input 1:
        Tree:    5
                / \
                4   8
            /   / \
            11  13  4
            /  \      \
            7    2      1

        B = 22

        Output 1:
            1

        Input 2:
        Tree:    5
                / \
                4   8
            /   / \
            -11 -13  4

        B = -1

        Output 2:
            0

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */
        int Solution::hasPathSum(TreeNode* A, int B) {
            // Base case: if the node is null, no path exists
            if (A == NULL) {
                return 0;
            }
            
            // Check if we are at a leaf node (no children)
            if (A->left == NULL && A->right == NULL) {
                return (A->val == B) ? 1 : 0;  // Check if the remaining sum matches the leaf node's value
            }
            
            // Recursively check left and right subtrees with the updated sum (B - A->val)
            int leftResult = hasPathSum(A->left, B - A->val);
            int rightResult = hasPathSum(A->right, B - A->val);
            
            // If either the left or right subtree has a valid path, return 1 (true)
            return (leftResult || rightResult);
        }
    // Q4. Invert the Binary Tree
        /*
        Q.4 -> Given a binary tree A, invert the binary tree and return it.
        Inverting refers to making the left child the right child and vice versa.

        Note :

        Problem Constraints
            1 <= size of tree <= 100000

        Input Format
            First and only argument is the head of the tree A.    

        Output Format
            Return the head of the inverted tree.

        Input 1:
            
            1
        /   \
        2     3

        Output 1:
        
            1
        /   \
        3     2

        Input 2:
        
            1
        /   \
        2     3
        / \   / \
        4   5 6   7

        Output 2:
        
            1
        /   \
        3     2
        / \   / \
        7   6 5   4

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */
        TreeNode* Solution::invertTree(TreeNode* A) {
            // Base case: if the node is NULL, return NULL
            if (A == NULL) {
                return NULL;
            }

            // Recursively invert the left and right subtrees
            TreeNode* leftInverted = invertTree(A->left);
            TreeNode* rightInverted = invertTree(A->right);

            // Swap the left and right children
            A->left = rightInverted;
            A->right = leftInverted;

            // Return the root of the inverted tree
            return A;
        }
    // Q5. Equal Tree Partition
        /*
        Q.5 -> 
        Given a binary tree A. Check whether it is possible to partition the tree to two trees which have equal sum of values after removing exactly one edge on the original tree.

        Problem Constraints
            1 <= size of tree <= 100000
            0 <= value of node <= 109

        Input Format
            First and only argument is head of tree A.

        Output Format
            Return 1 if the tree can be partitioned into two trees of equal sum else return 0.

        Input 1:
                        5
                    /  \
                    3    7
                    / \  / \
                    4  6  5  6

        Output 1:
            1

        Input 2:
                        1
                    / \
                    2   10
                        / \
                        20  2

        Output 2:
            0

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */

        unordered_set<long long> subtreeSums; // Store subtree sums
        bool canPartition = false;  // Flag to track if partitioning is possible

        // Helper function to calculate the sum of a subtree
        long long calculateSubtreeSum(TreeNode* node, long long totalSum) {
            if (!node) return 0;

            // Recursively calculate the sum of the left and right subtrees
            long long leftSum = calculateSubtreeSum(node->left, totalSum);
            long long rightSum = calculateSubtreeSum(node->right, totalSum);

            // Calculate the sum of the current subtree
            long long subtreeSum = leftSum + rightSum + node->val;

            // If the subtree sum is half of the total sum and it's not the total sum itself
            if (subtreeSum == totalSum / 2) {
                canPartition = true;
            }

            // Store this subtree sum in the set
            subtreeSums.insert(subtreeSum);

            return subtreeSum;
        }

        int Solution::solve(TreeNode* A) {
        if (!A) return 0;

            // Calculate the total sum of the tree
            long long totalSum = calculateSubtreeSum(A, 0);

            // If total sum is odd, we cannot partition the tree equally
            if (totalSum % 2 != 0) return 0;

            // Recalculate the subtree sums and check for partition
            subtreeSums.clear(); // Clear previous sums
            canPartition = false; // Reset the partition flag

            // Perform the subtree sum calculation again, this time checking for valid partitions
            calculateSubtreeSum(A, totalSum);

            // Return if the partition is possible
            return canPartition ? 1 : 0;
        }
    // Q1. Identical Binary Trees
        /*
        Q.1 -> 
        Given two binary trees, check if they are equal or not.
        Two binary trees are considered equal if they are structurally identical and the nodes have the same value.

        Problem Constraints
            1 <= number of nodes <= 105

        Input Format
            The first argument is a root node of the first tree, A.
            The second argument is a root node of the second tree, B.    

        Output Format
            Return 0 / 1 ( 0 for false, 1 for true ) for this problem.

        Input 1:
        1       1
        / \     / \
        2   3   2   3

        Output 1:
            1

        Input 2:
        1       1
        / \     / \
        2   3   3   3

        Output 2:
            0

        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */
        int Solution::isSameTree(TreeNode* A, TreeNode* B) {
            // If both trees are empty, they are identical
            if (A == nullptr && B == nullptr) {
                return 1;
            }

            // If one of the trees is empty and the other is not, they are not identical
            if (A == nullptr || B == nullptr) {
                return 0;
            }

            // Check if the current nodes have the same value
            // Recursively check the left and right subtrees
            if (A->val == B->val 
                && isSameTree(A->left, B->left) 
                && isSameTree(A->right, B->right)) {
                return 1;
            }

            // If the values are not the same or the structure is different, return false
            return 0;
        }
    // Q2. Invert the Binary Tree
        /*
        Q.2 -> 
        Given a binary tree A, invert the binary tree and return it.
        Inverting refers to making the left child the right child and vice versa.

        Problem Constraints
            1 <= size of tree <= 100000

        Input Format
            First and only argument is the head of the tree A.    

        Output Format
            Return the head of the inverted tree.

        Input 1:
            
            1
        /   \
        2     3

        Output 1:
        
            1
        /   \
        3     2

        Input 2:
        
            1
        /   \
        2     3
        / \   / \
        4   5 6   7

        Output 2:
        
            1
        /   \
        3     2
        / \   / \
        7   6 5   4


        */

        // CODE
        /**
        * Definition for binary tree
        * struct TreeNode {
        *     int val;
        *     TreeNode *left;
        *     TreeNode *right;
        *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
        * };
        */
        TreeNode* Solution::invertTree(TreeNode* A) {
            // Base case: if the tree is empty, return nullptr
            if (A == nullptr) {
                return nullptr;
            }
            
            // Swap the left and right children of the current node
            TreeNode* temp = A->left;
            A->left = A->right;
            A->right = temp;
            
            // Recursively invert the left and right subtrees
            invertTree(A->left);
            invertTree(A->right);
            
            // Return the root of the inverted tree
            return A;
        }

## Trees Exatra ##
    // Maximum Depth of Binary Tree
        int maxDepth(TreeNode* root) {
            if (root == NULL) {
                return 0; // Base case: an empty tree has depth 0
            }
            
            // Compute the depth of left and right subtrees recursively
            int leftDepth = maxDepth(root->left);
            int rightDepth = maxDepth(root->right);
            
            // Maximum depth is 1 plus the greater depth of the two subtrees
            return 1 + max(leftDepth, rightDepth);
        }

    // check for Balanced Binary Tree 
        // Helper function to check the height of the tree
        // Returns -1 if the subtree is unbalanced; otherwise, returns the height
        int checkHeight(TreeNode* root) {
            if (root == NULL) {
                return 0; // Base case: an empty tree has height 0
            }

            // Recursively get the height of the left and right subtrees
            int leftHeight = checkHeight(root->left);
            if (leftHeight == -1) {
                return -1; // Left subtree is unbalanced
            }

            int rightHeight = checkHeight(root->right);
            if (rightHeight == -1) {
                return -1; // Right subtree is unbalanced
            }

            // Check if the current node is unbalanced
            if (abs(leftHeight - rightHeight) > 1) {
                return -1; // Current node is unbalanced
            }

            // Return the height of the subtree rooted at this node
            return 1 + max(leftHeight, rightHeight);
        }

        // Function to check if the binary tree is balanced
        bool isBalanced(TreeNode* root) {
            return checkHeight(root) != -1;
        }
    // Diameter of Binary Tree
        int height(TreeNode* node, int &diameter) {
            if (!node) return 0;
            
            int leftHeight = height(node->left, diameter);
            int rightHeight = height(node->right, diameter);
            
            // Update the diameter
            diameter = max(diameter, leftHeight + rightHeight);
            
            return 1 + max(leftHeight, rightHeight);
        }

        int diameterOfBinaryTree(TreeNode* root) {
            int diameter = 0;
            height(root, diameter);
            return diameter;
        }
    // Maximum Path Sum
        int maxPathDown(TreeNode* node, int &maxSum) {
            if (!node) return 0;
            
            int left = max(0, maxPathDown(node->left, maxSum)); // ignore negative paths
            int right = max(0, maxPathDown(node->right, maxSum));
            
            // Update maxSum to include the maximum path that passes through this node
            maxSum = max(maxSum, left + right + node->val);
            
            // Return the max path that can be extended upwards
            return max(left, right) + node->val;
        }

        int maxPathSum(TreeNode* root) {
            int maxSum = INT_MIN;
            maxPathDown(root, maxSum);
            return maxSum;
        }
    // Check if Two Binary Trees are Identical Or Not
        bool isIdentical(TreeNode* root1, TreeNode* root2) {
            // Both trees are empty
            if (!root1 && !root2) return true;
            
            // Only one of the trees is empty
            if (!root1 || !root2) return false;
            
            // Check if the current nodes have the same value and recurse for left and right subtrees
            return (root1->val == root2->val) &&
                isIdentical(root1->left, root2->left) &&
                isIdentical(root1->right, root2->right);
        }
    // ZigZag Level Order Traversal
        vector<vector<int>> zigzagLevelOrder(TreeNode* root) {
            vector<vector<int>> result;
            if (!root) return result;

            queue<TreeNode*> q;
            q.push(root);
            bool leftToRight = true;

            while (!q.empty()) {
                int levelSize = q.size();
                deque<int> currentLevel;

                for (int i = 0; i < levelSize; i++) {
                    TreeNode* node = q.front();
                    q.pop();

                    if (leftToRight) {
                        currentLevel.push_back(node->val);
                    } else {
                        currentLevel.push_front(node->val);
                    }

                    if (node->left) q.push(node->left);
                    if (node->right) q.push(node->right);
                }

                result.push_back(vector<int>(currentLevel.begin(), currentLevel.end()));
                leftToRight = !leftToRight;  // Toggle the direction
            }

            return result;
        }
    // Boundry Traversal of Binary Tree        
        void addLeftBoundary(TreeNode* node, vector<int>& result) {
            TreeNode* curr = node->left;
            while (curr) {
                if (!(curr->left == NULL && curr->right == NULL)) {  // Skip leaf nodes
                    result.push_back(curr->val);
                }
                curr = (curr->left) ? curr->left : curr->right;
            }
        }
        void addLeafNodes(TreeNode* node, vector<int>& result) {
            if (!node) return;
            if (!node->left && !node->right) {
                result.push_back(node->val);  // Add leaf node
                return;
            }
            addLeafNodes(node->left, result);
            addLeafNodes(node->right, result);
        }
        void addRightBoundary(TreeNode* node, vector<int>& result) {
            TreeNode* curr = node->right;
            vector<int> temp;
            while (curr) {
                if (!(curr->left == NULL && curr->right == NULL)) {  // Skip leaf nodes
                    temp.push_back(curr->val);
                }
                curr = (curr->right) ? curr->right : curr->left;
            }
            for (int i = temp.size() - 1; i >= 0; i--) {
                result.push_back(temp[i]);  // Add in reverse order
            }
        }
        vector<int> boundaryTraversal(TreeNode* root) {
            vector<int> result;
            if (!root) return result;

            result.push_back(root->val);  // Start with the root node

            // Step 1: Add left boundary (excluding leaf nodes)
            if (root->left) {
                addLeftBoundary(root, result);
            }

            // Step 2: Add all leaf nodes (left to right)
            addLeafNodes(root, result);

            // Step 3: Add right boundary (in reverse, excluding leaf nodes)
            if (root->right) {
                addRightBoundary(root, result);
            }

            return result;
        }
    // Check For Symmetrical Binary Tree
        bool isSymmetric(TreeNode* left, TreeNode* right) {
            if (!left && !right) return true;  // Both are null
            if (!left || !right) return false;  // One is null
            return (left->val == right->val) &&  // Values must be the same
                isSymmetric(left->left, right->right) &&  // Check left and right
                isSymmetric(left->right, right->left);  // Check right and left
        }

        bool isSymmetric(TreeNode* root) {
            if (!root) return true;  // An empty tree is symmetric
            return isSymmetric(root->left, root->right);  // Compare left and right subtrees
        }
    // Maximum Width of Binary Tree
        int widthOfBinaryTree(TreeNode* root) {
            if (root == NULL) {
                return 0; // Empty tree has width 0
            }

            int maxWidth = 0;
            queue<pair<TreeNode*, unsigned long long>> q; // Pair of node and its position
            q.push({root, 0}); // Start with root at position 0

            while (!q.empty()) {
                int levelSize = q.size();
                unsigned long long start = q.front().second; // First position at the current level
                unsigned long long end = q.back().second;    // Last position at the current level

                // Width of the current level
                maxWidth = max(maxWidth, static_cast<int>(end - start + 1));

                // Process each node in the current level
                for (int i = 0; i < levelSize; i++) {
                    auto [node, pos] = q.front();
                    q.pop();

                    // Adjust positions to avoid overflow
                    unsigned long long newPos = pos - start;

                    // Enqueue left and right children with updated positions
                    if (node->left) q.push({node->left, 2 * newPos + 1});
                    if (node->right) q.push({node->right, 2 * newPos + 2});
                }
            }

            return maxWidth;
        }
    // Check Children Sum Property
        bool isChildrenSum(TreeNode* root) {
            // An empty tree satisfies the property
            if (root == NULL) return true;
            
            // A leaf node also satisfies the property
            if (root->left == NULL && root->right == NULL) return true;
            
            // Sum of the values of the left and right children
            int leftValue = (root->left != NULL) ? root->left->val : 0;
            int rightValue = (root->right != NULL) ? root->right->val : 0;
            
            // Check if the current node's value matches the sum of its children
            bool currentNodeSatisfies = (root->val == leftValue + rightValue);
            
            // Recursively check the left and right subtrees
            return currentNodeSatisfies && isChildrenSum(root->left) && isChildrenSum(root->right);
        }
    // Make Children Sum Propert Binary Tree
        void changeTree(BinaryTreeNode<int> * root) {
            if (root == NULL) return;
            int child = 0;
            if (root->left) {
                child += root->left->data;
            }
            if (root->right) {
                child += root->right->data;
            }

            if (child >= root->data){
                root->data = child;
            } 
            else {
                if (root->left) root->left->data = root->data;
                else if (root->right) root->right->data = root->data;
            }

            changeTree(root->left);
            changeTree(root->right);

            int tot = 0;
            if (root->left) tot += root->left->data;
            if (root->right) tot += root->right->data;
            if (root->left || root->right) root->data = tot;
        }

    // Print all nodes From Distance K from a node in all direction
        void dfs(TreeNode* node, unordered_map<TreeNode*, TreeNode*>& parent_map) {
            if (!node) return;
            if (node->left) {
                parent_map[node->left] = node;
                dfs(node->left, parent_map);
            }
            if (node->right) {
                parent_map[node->right] = node;
                dfs(node->right, parent_map);
            }
        }

        void printNodesAtDistanceK(TreeNode* root, TreeNode* target, int K) {
            unordered_map<TreeNode*, TreeNode*> parent_map;
            dfs(root, parent_map);

            queue<TreeNode*> queue;
            unordered_set<TreeNode*> visited;
            
            queue.push(target);
            visited.insert(target);

            int current_distance = 0;

            while (!queue.empty()) {
                if (current_distance == K) {
                    break;
                }
                current_distance++;
                int level_size = queue.size();

                for (int i = 0; i < level_size; ++i) {
                    TreeNode* node = queue.front();
                    queue.pop();

                    // Add the left child
                    if (node->left && visited.find(node->left) == visited.end()) {
                        visited.insert(node->left);
                        queue.push(node->left);
                    }

                    // Add the right child
                    if (node->right && visited.find(node->right) == visited.end()) {
                        visited.insert(node->right);
                        queue.push(node->right);
                    }

                    // Add the parent
                    if (parent_map.find(node) != parent_map.end() && 
                        visited.find(parent_map[node]) == visited.end()) {
                        visited.insert(parent_map[node]);
                        queue.push(parent_map[node]);
                    }
                }
            }

            // Print nodes at distance K
            while (!queue.empty()) {
                cout << queue.front()->val << " ";
                queue.pop();
            }
            cout << endl;
        }

    // Minimum Time Taken to Burn the Binary Tree
        // DFS to create parent mapping
        void dfs(TreeNode* node, unordered_map<TreeNode*, TreeNode*>& parent_map) {
            if (!node) return;
            if (node->left) {
                parent_map[node->left] = node;
                dfs(node->left, parent_map);
            }
            if (node->right) {
                parent_map[node->right] = node;
                dfs(node->right, parent_map);
            }
        }
        // Function to find the minimum time to burn the binary tree from a target node
        int minTimeToBurnTree(TreeNode* root, TreeNode* target) {
            unordered_map<TreeNode*, TreeNode*> parent_map;
            dfs(root, parent_map);

            queue<TreeNode*> queue;
            unordered_set<TreeNode*> visited;
            int time = 0;

            queue.push(target);
            visited.insert(target);

            while (!queue.empty()) {
                int level_size = queue.size();
                // Spread fire for the current time unit
                for (int i = 0; i < level_size; ++i) {
                    TreeNode* node = queue.front();
                    queue.pop();

                    // Add the left child
                    if (node->left && visited.find(node->left) == visited.end()) {
                        visited.insert(node->left);
                        queue.push(node->left);
                    }

                    // Add the right child
                    if (node->right && visited.find(node->right) == visited.end()) {
                        visited.insert(node->right);
                        queue.push(node->right);
                    }

                    // Add the parent
                    if (parent_map.find(node) != parent_map.end() && 
                        visited.find(parent_map[node]) == visited.end()) {
                        visited.insert(parent_map[node]);
                        queue.push(parent_map[node]);
                    }
                }
                // Increase time after spreading fire to the next level
                if (!queue.empty()) {
                    time++;
                }
            }

            return time;
        }
    // Count total Node in Complete Binary Tree
        // Function to find the height of the leftmost path
        int findHeightLeft(TreeNode* root) {
            int height = 0;
            while (root != nullptr) {
                height++;
                root = root->left; // Go down the left side
            }
            return height;
        }

        // Function to find the height of the rightmost path
        int findHeightRight(TreeNode* root) {
            int height = 0;
            while (root != nullptr) {
                height++;
                root = root->right; // Go down the right side
            }
            return height;
        }

        // Function to count total nodes in a complete binary tree
        int countNodes(TreeNode* root) {
            if (root == nullptr) {
                return 0; // Base case: if the node is null, return 0
            }

            // Find heights of left and right subtrees
            int lh = findHeightLeft(root);
            int rh = findHeightRight(root);

            // If left height equals right height, it's a full tree
            if (lh == rh) {
                return (1 << lh) - 1; // Total nodes = 2^height - 1
            }

            // Otherwise, count recursively
            return 1 + countNodes(root->left) + countNodes(root->right);
        }
    // Serialize and Deserialize Binary Tree
        string serialize(TreeNode* root) {
            if (!root) return "null";

            stringstream ss;
            queue<TreeNode*> q;
            q.push(root);

            while (!q.empty()) {
                TreeNode* node = q.front();
                q.pop();
                if (node) {
                    ss << node->val << ",";
                    q.push(node->left);
                    q.push(node->right);
                } else {
                    ss << "null,";
                }
            }

            string serialized = ss.str();
            // Remove the trailing comma
            return serialized.substr(0, serialized.size() - 1);
        }

        // Deserializes your encoded data to tree.
        TreeNode* deserialize(string data) {
            if (data == "null") return nullptr;

            stringstream ss(data);
            string token;
            getline(ss, token, ',');
            
            TreeNode* root = new TreeNode(stoi(token));
            queue<TreeNode*> q;
            q.push(root);

            while (getline(ss, token, ',')) {
                TreeNode* parent = q.front();
                q.pop();

                // Process left child
                if (token != "null") {
                    parent->left = new TreeNode(stoi(token));
                    q.push(parent->left);
                }

                // Process right child
                if (getline(ss, token, ',')) {
                    if (token != "null") {
                        parent->right = new TreeNode(stoi(token));
                        q.push(parent->right);
                    }
                }
            }

            return root;
        }
    // Flatten a Binary Tree to Linked List 
        // Solution 1 [Recursive] T(N) S(N)
            void flattenHelper(TreeNode* node, TreeNode*& prev) {
                if (!node) return;

                // Traverse the right subtree first
                flattenHelper(node->right, prev);
                flattenHelper(node->left, prev);

                // Rearranging the pointers
                node->right = prev; // Set the right child to the previous node
                node->left = nullptr; // Set the left child to null
                prev = node; // Update previous node to current
            }
        // Solution 2 [Iterative] T(N) S(N)
            void flatten(TreeNode* root) {
                if (!root) return;

                stack<TreeNode*> s;
                s.push(root);

                TreeNode* prev = nullptr;

                while (!s.empty()) {
                    TreeNode* node = s.top();
                    s.pop();

                    // If there's a previous node, point its right to the current node
                    if (prev) {
                        prev->right = node;
                        prev->left = nullptr; // Make sure left is null
                    }

                    // Push right and then left child to the stack
                    if (node->right) {
                        s.push(node->right);
                    }
                    if (node->left) {
                        s.push(node->left);
                    }

                    // Update the previous node to the current node
                    prev = node;
                }
            }
        // Solution 3 [Morris Traversal] T(N) S(1)
            void flatten(TreeNode* root) {
                TreeNode* current = root;

                while (current) {
                    if (current->left) {
                        // Find the rightmost node of the left subtree
                        TreeNode* rightmost = current->left;
                        while (rightmost->right) {
                            rightmost = rightmost->right;
                        }

                        // Rewire the connections
                        rightmost->right = current->right; // Connect the right subtree
                        current->right = current->left;     // Move left subtree to the right
                        current->left = nullptr;             // Set left child to null
                    }
                    // Move to the right in the tree
                    current = current->right;
                }
            }
    // Ceil and Floor in BST
        int findCeil(TreeNode* root, int key) {
            int ceil = -1;
            while (root) {
                if (root->val == key) {
                    return root->val; // Exact match
                } else if (root->val > key) {
                    ceil = root->val; // Possible ceil candidate
                    root = root->left; // Move left to find a smaller or exact match
                } else {
                    root = root->right; // Move right to find a greater value
                }
            }
            return ceil;
        }

        int findFloor(TreeNode* root, int key) {
            int floor = -1;
            while (root) {
                if (root->val == key) {
                    return root->val; // Exact match
                } else if (root->val < key) {
                    floor = root->val; // Possible floor candidate
                    root = root->right; // Move right to find a larger or exact match
                } else {
                    root = root->left; // Move left to find a smaller value
                }
            }
            return floor;
        }

    // Check if a Tree is a BST or BT 
        bool isBSTUtil(TreeNode* node, long long minVal, long long maxVal) {
            // An empty node is considered a BST
            if (!node) return true;
            
            // If the current node''s value does not lie within the range, it''s not a BST
            if (node->val <= minVal || node->val >= maxVal) return false;
            
            // Recursively check the left and right subtrees with updated ranges
            return isBSTUtil(node->left, minVal, node->val) &&
                isBSTUtil(node->right, node->val, maxVal);
        }
        
        bool isValidBST(TreeNode* root) {
            // Start with the range [LLONG_MIN, LLONG_MAX]
            return isBSTUtil(root, LLONG_MIN, LLONG_MAX);
        }
    // Construct a BST from a preorder traversal
        TreeNode* buildBSTFromPreorder(vector<int>& preorder, int& index, int upperBound) {
            // If all elements are processed or the current element is greater than the allowed bound
            if (index == preorder.size() || preorder[index] > upperBound) {
                return nullptr;
            }

            // Construct the root node with the current value
            TreeNode* root = new TreeNode(preorder[index++]);

            // All values in the left subtree should be less than root's value
            root->left = buildBSTFromPreorder(preorder, index, root->val);

            // All values in the right subtree should be greater than root's value but less than the upper bound
            root->right = buildBSTFromPreorder(preorder, index, upperBound);

            return root;
        }

        TreeNode* bstFromPreorder(vector<int>& preorder) {
            int index = 0;
            return buildBSTFromPreorder(preorder, index, INT_MAX);
        }
    // Inorder Successor/Predecessor in BST
        TreeNode* inorderSuccessor(TreeNode* root, TreeNode* node) {
            if (node->right) {
                // Find the leftmost node in the right subtree
                TreeNode* current = node->right;
                while (current->left) {
                    current = current->left;
                }
                return current;
            }

            // If no right child, traverse from root to find successor
            TreeNode* successor = nullptr;
            TreeNode* current = root;
            while (current) {
                if (node->val < current->val) {
                    successor = current;
                    current = current->left;
                } else if (node->val > current->val) {
                    current = current->right;
                } else {
                    break;
                }
            }
            return successor;
        }

        TreeNode* inorderPredecessor(TreeNode* root, TreeNode* node) {
            if (node->left) {
                // Find the rightmost node in the left subtree
                TreeNode* current = node->left;
                while (current->right) {
                    current = current->right;
                }
                return current;
            }

            // If no left child, traverse from root to find predecessor
            TreeNode* predecessor = nullptr;
            TreeNode* current = root;
            while (current) {
                if (node->val < current->val) {
                    current = current->left;
                } else if (node->val > current->val) {
                    predecessor = current;
                    current = current->right;
                } else {
                    break;
                }
            }
            return predecessor;
        }
    // Binary Search Tree Iterator
        class BSTIterator {
            private:
                std::stack<TreeNode*> stack;

                // Helper function to push all left nodes of a subtree onto the stack
                void pushLeftNodes(TreeNode* node) {
                    while (node) {
                        stack.push(node);
                        node = node->left;
                    }
                }

            public:
                // Constructor initializes the iterator for the BST by pushing left nodes
                BSTIterator(TreeNode* root) {
                    pushLeftNodes(root);
                }

                // Returns the next smallest number in the BST
                int next() {
                    // Top element of stack is the next smallest element
                    TreeNode* node = stack.top();
                    stack.pop();

                    // If node has a right child, push all left nodes of the right subtree
                    if (node->right) {
                        pushLeftNodes(node->right);
                    }

                    return node->val;
                }

                // Returns whether the next smallest number exists
                bool hasNext() {
                    return !stack.empty();
                }
        };
    // Two Sum In BST
        // Approach 1: Inorder Traversal + Two-Pointer Technique
            void inorderTraversal(TreeNode* root, std::vector<int>& nodes) {
                if (!root) return;
                inorderTraversal(root->left, nodes);
                nodes.push_back(root->val);
                inorderTraversal(root->right, nodes);
            }

            bool findTarget(TreeNode* root, int target) {
                std::vector<int> nodes;
                inorderTraversal(root, nodes);

                int left = 0, right = nodes.size() - 1;
                while (left < right) {
                    int sum = nodes[left] + nodes[right];
                    if (sum == target) {
                        return true;
                    } else if (sum < target) {
                        left++;
                    } else {
                        right--;
                    }
                }
                return false;
            }

        // Approach 2: Using a Hash Set
            bool findTargetHelper(TreeNode* root, int target, std::unordered_set<int>& seen) {
                if (!root) return false;
                if (seen.count(target - root->val)) return true;
                seen.insert(root->val);
                return findTargetHelper(root->left, target, seen) || findTargetHelper(root->right, target, seen);
            }

            bool findTarget(TreeNode* root, int target) {
                std::unordered_set<int> seen;
                return findTargetHelper(root, target, seen);
            }
    // Recover BST | Correct BST with two nodes swapped
        TreeNode *first = nullptr, *second = nullptr, *prev = new TreeNode(INT_MIN);
        // Inorder traversal helper to identify swapped nodes
        void inorder(TreeNode* root) {
            if (!root) return;

            inorder(root->left);

            // Check if we have found a violation of the BST property
            if (prev->val > root->val) {
                if (!first) {
                    first = prev;
                }
                second = root;
            }
            
            // Update prev node for next iteration
            prev = root;

            inorder(root->right);
        }
        void recoverTree(TreeNode* root) {
            // Perform inorder traversal to identify the swapped nodes
            inorder(root);
            
            // Swap values of the first and second node
            if (first && second) {
                swap(first->val, second->val);
            }
        }
    // Largest BST in Binary Tree
        struct Info {
            int size;      // Size of the current BST
            int minVal;    // Minimum value in the current subtree
            int maxVal;    // Maximum value in the current subtree
            bool isBST;    // Whether the current subtree is a BST

            Info(int size, int minVal, int maxVal, bool isBST)
                : size(size), minVal(minVal), maxVal(maxVal), isBST(isBST) {}
        };

        int largestBSTSize = 0;  // Track the size of the largest BST

        Info largestBSTSubtreeHelper(TreeNode* node) {
            if (!node) return Info(0, INT_MAX, INT_MIN, true);

            // Recursively find information for left and right subtrees
            Info leftInfo = largestBSTSubtreeHelper(node->left);
            Info rightInfo = largestBSTSubtreeHelper(node->right);

            // Check if current node is a valid BST
            if (leftInfo.isBST && rightInfo.isBST &&
                node->val > leftInfo.maxVal && node->val < rightInfo.minVal) {
                
                // Current subtree is a BST
                int size = leftInfo.size + rightInfo.size + 1;
                largestBSTSize = std::max(largestBSTSize, size);
                int minVal = std::min(node->val, leftInfo.minVal);
                int maxVal = std::max(node->val, rightInfo.maxVal);

                return Info(size, minVal, maxVal, true);
            }

            // If it's not a BST, return info with max size so far, but mark it as not a BST
            return Info(std::max(leftInfo.size, rightInfo.size), 0, 0, false);
        }

        int largestBSTSubtree(TreeNode* root) {
            largestBSTSubtreeHelper(root);
            return largestBSTSize;
        }
---------------------------------------------------------------------------------------------------------------
//######################
//## UNIT 4 ##
//###################### 
---------------------------------------------------------------------------------------------------------------
// Heaps
## Heaps 1: Introduction ##
    // Max-Heap Implementation:
        class MaxHeap {
            vector<int> heap;
            // Heapify down: After removal of root
            void heapifyDown(int index) {
                int largest = index;
                int leftChild = 2 * index + 1;
                int rightChild = 2 * index + 2;
                
                if (leftChild < heap.size() && heap[leftChild] > heap[largest]) {
                    largest = leftChild;
                }
                
                if (rightChild < heap.size() && heap[rightChild] > heap[largest]) {
                    largest = rightChild;
                }
                
                if (largest != index) {
                    swap(heap[index], heap[largest]);
                    heapifyDown(largest);
                }
            }
            // Heapify up: After insertion
            void heapifyUp(int index) {
                int parent = (index - 1) / 2;
                
                if (index > 0 && heap[index] > heap[parent]) {
                    swap(heap[index], heap[parent]);
                    heapifyUp(parent);
                }
            }
            public:
            // Insert element into the heap
            void insert(int value) {
                heap.push_back(value);
                heapifyUp(heap.size() - 1);  // Sift up the newly inserted element
            }
            // Extract the maximum element (root)
            int extractMax() {
                if (heap.empty()) {
                    throw runtime_error("Heap is empty!");
                }
                int maxVal = heap[0];
                heap[0] = heap.back();  // Move the last element to the root
                heap.pop_back();  // Remove the last element
                heapifyDown(0);  // Sift down the new root
                return maxVal;
            }
            // Get the maximum element
            int getMax() {
                if (heap.empty()) {
                    throw runtime_error("Heap is empty!");
                }
                return heap[0];
            }
            // Display the heap
            void displayHeap() {
                for (int val : heap) {
                    cout << val << " ";
                }
                cout << endl;
            }
        };
    // Build a Max-Heap in O(n)
        class MaxHeap {
            vector<int> heap;

            // Heapify the subtree rooted at index i
            void heapify(int n, int i) {
                int largest = i;         // Initialize largest as root
                int left = 2 * i + 1;    // Left child
                int right = 2 * i + 2;   // Right child

                // If left child is larger than root
                if (left < n && heap[left] > heap[largest]) {
                    largest = left;
                }

                // If right child is larger than the largest so far
                if (right < n && heap[right] > heap[largest]) {
                    largest = right;
                }

                // If the largest is not root, swap and continue heapifying
                if (largest != i) {
                    swap(heap[i], heap[largest]);
                    // Recursively heapify the affected subtree
                    heapify(n, largest);
                }
            }

            public:
            // Constructor to initialize the heap with an existing array
            MaxHeap(vector<int> &arr) {
                heap = arr;
            }

            // Function to build a max heap in O(n)
            void buildHeap() {
                int n = heap.size();

                // Start from the last non-leaf node and heapify each node
                for (int i = n / 2 - 1; i >= 0; i--) {
                    heapify(n, i);
                }
            }

            // Display the heap
            void displayHeap() {
                for (int i = 0; i < heap.size(); i++) {
                    cout << heap[i] << " ";
                }
                cout << endl;
            }
        };
    // Max heap in Cpp
        priority_queue<int> maxHeap;

        maxHeap.push(10);
        maxHeap.push(30);

        maxHeap.empty();

        maxHeap.top();
        maxHeap.pop();

    // Min heap in Cpp
        priority_queue<int, vector<int>, greater<int>> minHeap;

        minHeap.push(10);
        minHeap.push(30);

        minHeap.empty();

        minHeap.top();
        minHeap.pop();

    // Custom Comparators in Heaps:
        struct Compare {
            bool operator()(pair<int, int> const& p1, pair<int, int> const& p2) {
                return p1.first < p2.first; // Max-heap based on the first element of the pair
            }
        };

         priority_queue<pair<int, int>, vector<pair<int, int>>, Compare> maxHeap;

        maxHeap.push({1, 2});
        maxHeap.push({3, 4});

        maxHeap.empty();

        maxHeap.top();
        maxHeap.pop();

    
    // Heapify
        // Bottom Up heapify
            void heapifyUp(vector<int>& heap, int index) {
                int parent = (index - 1) / 2;
                if (index > 0 && heap[index] > heap[parent]) {
                    swap(heap[index], heap[parent]);
                    heapifyUp(heap, parent); // Recursively heapify the parent
                }
            }
        // Top Down Heapify
            void heapify_down(vector<int>& heap, int n, int i) {
                int largest = i;       // Root
                int left = 2 * i + 1;  // Left Child
                int right = 2 * i + 2; // Right Child

                // Find the largest among root, left, and right
                if (left < n && heap[left] > heap[largest])
                    largest = left;
                if (right < n && heap[right] > heap[largest])
                    largest = right;

                // If largest is not root
                if (largest != i) {
                    swap(heap[i], heap[largest]);
                    heapify_down(heap, n, largest);
                }
            }
    // Insertion in Heap
        // Bottom-Up Heapify for Max-Heap
        void heapifyUp(vector<int>& heap, int index) {
            int parent = (index - 1) / 2;
            if (index > 0 && heap[index] > heap[parent]) {
                swap(heap[index], heap[parent]);
                heapifyUp(heap, parent); // Recursively heapify the parent
            }
        }

        // Function to Insert into the Heap
        void insert(vector<int>& heap, int value) {
            heap.push_back(value);           // Add the new element at the end
            heapifyUp(heap, heap.size() - 1); // Restore heap property
        }
    // Deletion/ Extract in Heap
        // Heapify Function (Max-Heap)
        void heapify_down(vector<int>& heap, int n, int i) {
            int largest = i;       // Root
            int left = 2 * i + 1;  // Left Child
            int right = 2 * i + 2; // Right Child

            // Find the largest among root, left, and right
            if (left < n && heap[left] > heap[largest])
                largest = left;
            if (right < n && heap[right] > heap[largest])
                largest = right;

            // If largest is not root
            if (largest != i) {
                swap(heap[i], heap[largest]);
                heapify_down(heap, n, largest);
            }
        }
        // Function to Extract the Root (Max-Heap)
        int extractRoot(vector<int>& heap) {
            int n = heap.size();
            if (n == 0) return -1; // Empty Heap

            int root = heap[0];
            heap[0] = heap[n - 1]; // Replace root with last element
            heap.pop_back();       // Remove last element

            heapify_down(heap, heap.size(), 0); // Restore heap property
            return root;
        } 
    // Build Heap in O(NLog(N))
        // Bottom-Up Heapify for Max-Heap
        void heapifyUp(vector<int>& heap, int index) {
            int parent = (index - 1) / 2;
            if (index > 0 && heap[index] > heap[parent]) {
                swap(heap[index], heap[parent]);
                heapifyUp(heap, parent);
            }
        }

        // Function to Insert an Element into the Heap
        void insert(vector<int>& heap, int value) {
            heap.push_back(value);           // Add new element at the end
            heapifyUp(heap, heap.size() - 1); // Restore heap property
        }

        // Build Heap Naively (O(N log N))
        void buildHeapNaive(vector<int>& heap, const vector<int>& arr) {
            for (int val : arr) {
                insert(heap, val);
            }
        }
    // Build Heap in O(N)
        void heapify(vector<int>& heap, int n, int i) {
            int largest = i;       // Root
            int left = 2 * i + 1;  // Left Child
            int right = 2 * i + 2; // Right Child

            // Find the largest among root, left, and right
            if (left < n && heap[left] > heap[largest])
                largest = left;
            if (right < n && heap[right] > heap[largest])
                largest = right;

            // If largest is not root
            if (largest != i) {
                swap(heap[i], heap[largest]);
                heapify(heap, n, largest);
            }
        }
        void buildHeap(vector<int>& heap) {
            int n = heap.size();

            // Start from the last non-leaf node and heapify each node
            for (int i = (n / 2) - 1; i >= 0; i--) {
                heapify(heap, n, i);
            }
        }    
    // Q1. Connect ropes
        /*
        Q.1 -> You are given an array A of integers that represent the lengths of ropes.
        You need to connect these ropes into one rope. The cost of joining two ropes equals the sum of their lengths.
        Find and return the minimum cost to connect these ropes into one rope.

        Note :
            

        Problem Constraints
            1 <= length of the array <= 100000
            1 <= A[i] <= 1000

        Input Format
            The only argument given is the integer array A.

        Output Format
            Return an integer denoting the minimum cost to connect these ropes into one rope.

        Input 1:
            A = [1, 2, 3, 4, 5]

        Output 1:
            33

        Input 2:
            A = [5, 17, 100, 11]

        Output 2:
            182

        */

        // CODE
        int Solution::solve(vector<int> &A) {
            // Priority queue to act as a min-heap
            std::priority_queue<int, std::vector<int>, std::greater<int>> minHeap;
            
            // Insert all rope lengths into the min-heap
            for (int length : A) {
                minHeap.push(length);
            }
            
            int totalCost = 0;
            
            // While there are more than one rope to connect
            while (minHeap.size() > 1) {
                // Take out the two smallest ropes
                int first = minHeap.top();
                minHeap.pop();
                int second = minHeap.top();
                minHeap.pop();
                
                // The cost to connect these two ropes
                int cost = first + second;
                totalCost += cost;
                
                // Insert the new rope (result of connecting two ropes) back into the heap
                minHeap.push(cost);
            }
            
            return totalCost;
        }
    // Q2. Build a Heap
        /*
        Q.2 -> Given an array A of N integers, convert that array into a min heap and return the array.

        NOTE: A min heap is a binary tree where every node has a value less than or equal to its children.

        Problem Constraints
        1  N  10^5
        0  A[i]  10^9 

        Input Format
            First and only argument of input contains a single integer array A of length N.

        Output Format
            Return the reordered array A such that it forms a min heap.

        Input 1:
            A = [5, 13, -2, 11, 27, 31, 0, 19]

        Output 1:
            A = [-2, 5, 0, 13, 11, 19, 27, 31]


        */

        // CODE
        class Solution {
        public:
            // Function to heapify a subtree rooted at index i
            void heapify(vector<int>& A, int n, int i) {
                int smallest = i;  // Initialize smallest as root
                int left = 2 * i + 1;  // Left child
                int right = 2 * i + 2;  // Right child

                // If left child is smaller than root
                if (left < n && A[left] < A[smallest]) {
                    smallest = left;
                }

                // If right child is smaller than smallest so far
                if (right < n && A[right] < A[smallest]) {
                    smallest = right;
                }

                // If smallest is not root
                if (smallest != i) {
                    swap(A[i], A[smallest]);  // Swap root with the smallest

                    // Recursively heapify the affected subtree
                    heapify(A, n, smallest);
                }
            }

            vector<int> buildHeap(vector<int>& A) {
                int n = A.size();

                // Build heap (rearrange the array)
                // Start from the last non-leaf node and move upwards
                for (int i = n / 2 - 1; i >= 0; i--) {
                    heapify(A, n, i);
                }

                // The array is now a min-heap
                return A;
            }
        };
    // Q3. Heap Queries
        /*
        Q.3 -> You have an empty min heap. You are given an array A consisting of N queries. Let P denote A[i][0] and Q denote A[i][1]. There are two types of queries:

        P = 1, Q = -1 : Pop the minimum element from the heap.
        P = 2, 1 <= Q <= 109 : Insert Q into the heap.

        Return an integer array containing the answer for all the extract min operation. If the size of heap is 0, then extract min should return -1.

        Note :
            

        Problem Constraints
            1 <= N <= 10^5
            1 <= A[i][0] <= 2
            1 <= A[i][1] <= 10^9 or A[i][1] = -1

        Input Format
            The only argument A is a 2D integer array

        Output Format
            Return an integer array

        Input 1:    
            A = [[1, -1], [2, 2], [2, 1], [1, -1]]

        Output 1:
            [-1, 1]

        Input 2:
            A = [[2, 5], [2, 3], [2, 1], [1, -1], [1, -1]]

        Output 2:
            [1, 3]

        */

        // CODE
        vector<int> Solution::solve(vector<vector<int> > &A) {
            priority_queue<int, vector<int>, greater<int>> minHeap;
            vector<int> result;
            
            // Process each query in the input array
            for (int i = 0; i < A.size(); i++) {
                int P = A[i][0];
                int Q = A[i][1];
                
                if (P == 1) {
                    // Pop the minimum element from the heap
                    if (minHeap.empty()) {
                        result.push_back(-1);  // If the heap is empty, return -1
                    } else {
                        result.push_back(minHeap.top());  // Add the minimum element to result
                        minHeap.pop();  // Remove the minimum element from the heap
                    }
                } else if (P == 2) {
                    // Insert Q into the heap
                    minHeap.push(Q);
                }
            }
            
            return result;  // Return the results of all the extract min operations
        }

    // Q1. Maximum array sum after B negations
        /*
        Q.1 -> Given an array of integers A and an integer B. You must modify the array exactly B number of times. In a single modification, we can replace any one array element A[i] by -A[i].
        You need to perform these modifications in such a way that after exactly B modifications, sum of the array must be maximum.


        NOTE: You can perform the modification on the same element multiple times.
            

        Problem Constraints
            1 <= length of the array <= 5*10^5
            1 <= B <= 5 * 10^6
            -100 <= A[i] <= 100

        Input Format
            The first argument given is an integer array A.
            The second argument given is an integer B.

        Output Format
            Return an integer denoting the maximum array sum after B modifications.

        Input 1:
            A = [24, -68, -29, -9, 84]
            B = 4

        Output 1:
            196

        Input 2:
            A = [57, 3, -14, -87, 42, 38, 31, -7, -28, -61]
            B = 10

        Output 2:
            362

        */

        // CODE
        int Solution::solve(vector<int> &A, int B) {
            // Create a min-heap (priority queue)
            priority_queue<int, vector<int>, greater<int>> pq;

            // Insert all elements of A into the min-heap
            for (int i = 0; i < A.size(); i++) {
                pq.push(A[i]);
            }

            // Perform flips based on the value of B
            while (B > 0 && !pq.empty()) {
                // Get the smallest element from the heap
                int smallest = pq.top();
                pq.pop(); // Remove the smallest element
                
                // Flip the smallest element (whether it's negative or positive)
                smallest = -smallest;
                
                // Push the flipped element back into the heap
                pq.push(smallest);
                
                // Decrease B after each flip
                B--;
            }


            // Calculate the total sum of the elements in the heap
            int ans = 0;
            while (!pq.empty()) {
                ans += pq.top();
                pq.pop();
            }

            return ans;
        }
    // Q2. Misha and Candies
        /*
        Q.2 -> Misha loves eating candies. She has been given N boxes of Candies.
        She decides that every time she will choose a box having the minimum number of candies, eat half of the candies and put the remaining candies in the other box that has the minimum number of candies.
        Misha does not like a box if it has the number of candies greater than B so she won't eat from that box. Can you find how many candies she will eat?

        NOTE 1: If a box has an odd number of candies then Misha will eat the floor(odd / 2).

        NOTE 2: The same box will not be chosen again.

        Problem Constraints
            1 <= N <= 10^5
            1 <= A[i] <= 10^5
            1 <= B <= 10^6  

        Input Format
            The first argument is A an Array of Integers, where A[i] is the number of candies in the ith box.
            The second argument is B, the maximum number of candies Misha like in a box.

        Output Format
            Return an integer denoting the number of candies Misha will eat.

        Input 1:
            A = [3, 2, 3]
            B = 4

        Output 1:
            2

        Input 2:
            A = [1, 2, 1]
            B = 2

        Output 2:
            1

        */

        // CODE
        int Solution::solve(vector<int> &A, int B) {
        // Step 1: Create a priority queue (min-heap) to store candy counts
            priority_queue<int, vector<int>, greater<int>> pq;

            // Step 2: Insert all candy counts into the min-heap
            for (int candies : A) {
                pq.push(candies);
            }

            // Step 3: Initialize a variable to track the total number of candies eaten
            int total_candies = 0;

            // Step 4: Process the boxes until the heap is empty
            while (!pq.empty()) {
                // Get the box with the minimum number of candies
                int current_candies = pq.top();
                pq.pop();

                // Step 5: Check if the number of candies is less than or equal to B
                if (current_candies <= B) {
                    // Calculate how many candies Misha can eat (half of the current candies)
                    int candies_eaten = current_candies / 2;  // floor division by default for integers
                    total_candies += candies_eaten;

                    // If there are more boxes left in the heap, update the next smallest box
                    if (!pq.empty()) {
                        int next_candy_box = pq.top();
                        pq.pop();
                        // Update the next candy box with the remaining candies after Misha eats
                        pq.push(next_candy_box + (current_candies - candies_eaten));
                    }
                } else {
                    // Step 6: If the current box has more candies than Misha likes, stop processing
                    break;
                }
            }

            // Step 7: Return the total number of candies Misha has eaten
            return total_candies;
        }

    // Q3. Minimum largest element
        /*
        Q.3 -> Given an array A of N numbers, you have to perform B operations. In each operation, you have to pick any one of the N elements and add the original value(value stored at the index before we did any operations) to its current value. You can choose any of the N elements in each operation.
        Perform B operations in such a way that the largest element of the modified array(after B operations) is minimized.
        Find the minimum possible largest element after B operations.

        Problem Constraints
            1 <= N <= 10^4
            0 <= B <= 10^4
            1 <= A[i] <= 10^4

        Input Format
            The first argument is an integer array A.
            The second argument is an integer B.

        Output Format
            Return an integer denoting the minimum possible largest element after B operations.

        Input 1:
            A = [1, 2, 3, 4] 
            B = 3

        Output 1:
            4

        Input 2:
            A = [5, 1, 4, 2] 
            B = 5

        Output 2:
            5

        */

        // CODE
        typedef pair<int, int> PAIR;

        struct comparator {
            bool operator()(const PAIR &A, const PAIR &B) {
                return A.first + A.second > B.first + B.second; // Compare the sums for min heap behavior
            }
        };

        int Solution::solve(vector<int> &A, int B) {
            // Create a priority queue (min-heap) using the custom comparator
            priority_queue<PAIR, vector<PAIR>, comparator> pq;

            // Initialize the heap with pairs (value, original value)
            for(int i = 0; i < A.size(); i++) {
                pq.push({A[i], A[i]});
            }
        
            // Perform B operations
            while(B--) {
                PAIR currMinimumVal = pq.top(); // Get the minimum value pair
                pq.pop(); // Remove it from the heap
                // Push the updated pair back into the heap
                pq.push({currMinimumVal.first + currMinimumVal.second, currMinimumVal.second});
            }

            // Find the maximum element from the final heap
            int ans = INT_MIN;
            while(!pq.empty()) {
                ans = max(ans, pq.top().first); // Keep track of the maximum element
                pq.pop(); // Remove the top element
            }
        
            return ans; // Return the maximum element found
        }
## Heaps 2: Problems ##
    // Heap Sort
        void heapify(int arr[], int n, int i) {
            int largest = i; // Initialize largest as root
            int left = 2 * i + 1; // left = 2*i + 1
            int right = 2 * i + 2; // right = 2*i + 2

            // If left child is larger than root
            if (left < n && arr[left] > arr[largest])
                largest = left;

            // If right child is larger than largest so far
            if (right < n && arr[right] > arr[largest])
                largest = right;

            // If largest is not root
            if (largest != i) {
                swap(arr[i], arr[largest]); // Swap

                // Recursively heapify the affected subtree
                heapify(arr, n, largest);
            }
        }

        // Main function to do heap sort
        void heapSort(int arr[], int n) {
            // Build heap (rearrange array)
            for (int i = n / 2 - 1; i >= 0; i--)
                heapify(arr, n, i);

            // One by one extract an element from heap
            for (int i = n - 1; i >= 0; i--) {
                // Move current root to end
                swap(arr[0], arr[i]);

                // call heapify on the reduced heap
                heapify(arr, i, 0);
            }
        }
    // K-th Largest Element
        int kthLargestUsingMinHeap(vector<int>& nums, int k) {
            // Create a min-heap (priority queue) to keep track of the k largest elements
            priority_queue<int, vector<int>, greater<int>> minHeap;

            // Add first k elements to the heap
            for (int i = 0; i < k; ++i) {
                minHeap.push(nums[i]);
            }

            // Iterate over the remaining elements
            for (int i = k; i < nums.size(); ++i) {
                // If current element is greater than the smallest element in heap, replace the root
                if (nums[i] > minHeap.top()) {
                    minHeap.pop();         // Remove the smallest element
                    minHeap.push(nums[i]); // Insert the new element
                }
            }

            // The root of the heap is the Kth largest element
            return minHeap.top();
        }
    // K-th Largest Element for all Windows
        vector<int> kthLargestInWindows(const vector<int>& nums, int k) {
            vector<int> result;
            priority_queue<int, vector<int>, greater<int>> minHeap;

            // Process first k elements
            for (int i = 0; i < k; ++i) {
                minHeap.push(nums[i]);
            }

            // Root of the heap is the Kth largest element in the first window
            result.push_back(minHeap.top());

            // Process the rest of the array using sliding window technique
            for (int i = k; i < nums.size(); ++i) {
                // Remove the element that is going out of the window
                minHeap.push(nums[i]);

                // If the heap size exceeds k, remove the smallest element
                if (minHeap.size() > k) {
                    minHeap.pop();
                }

                // The root of the heap is the Kth largest element in the current window
                result.push_back(minHeap.top());
            }

            return result;
        }
    // Median of Stream of Integers
        vector<int> Solution::solve(vector<int> &A) {
            // Max-heap for the smaller half
            priority_queue<int> left;
            // Min-heap for the larger half
            priority_queue<int, vector<int>, greater<int>> right;
            vector<int> result;

            for (int i = 0; i < A.size(); i++) {
                int num = A[i];

                // Add the new number to one of the heaps
                if (left.empty() || num <= left.top()) {
                    left.push(num);
                } else {
                    right.push(num);
                }

                // Balance the heaps (left can have at most 1 more element than right)
                if (left.size() > right.size() + 1) {
                    right.push(left.top());
                    left.pop();
                } else if (right.size() > left.size()) {
                    left.push(right.top());
                    right.pop();
                }

                // Get the median
                result.push_back(left.top());
            }

            return result;
        }
    // Q1. Ath largest element
        /*
        Q.1 -> Given an integer array B of size N.
        You need to find the Ath largest element in the subarray [1 to i], where i varies from 1 to N. In other words, find the Ath largest element in the sub-arrays [1 : 1], [1 : 2], [1 : 3], ...., [1 : N].

        NOTE: If any subarray [1 : i] has less than A elements, then the output should be -1 at the ith index.

        Problem Constraints
            1 <= N <= 100000
            1 <= A <= N
            1 <= B[i] <= INT_MAX

        Input Format
            The first argument is an integer A.
            The second argument is an integer array B of size N.

        Output Format
            Return an integer array C, where C[i] (1 <= i <= N) will have the Ath largest element in the subarray [1 : i].

        Input 1:
            A = 4  
            B = [1 2 3 4 5 6] 

        Output 1:
            [-1, -1, -1, 1, 2, 3]

        Input 2:
            A = 2
            B = [15, 20, 99, 1]

        Output 2:
            [-1, 15, 20, 20]

        */

        // CODE
        vector<int> Solution::solve(int A, vector<int> &B) {
            int N = B.size();
            vector<int> result(N, -1);  // Initialize result array with -1
            priority_queue<int, vector<int>, greater<int>> minHeap;  // Min-heap to store the top A largest elements

            for (int i = 0; i < N; i++) {
                minHeap.push(B[i]);  // Insert current element into the heap

                // If the heap has more than A elements, remove the smallest (heap root)
                if (minHeap.size() > A) {
                    minHeap.pop();
                }

                // If we have at least A elements, the root of the heap is the A-th largest
                if (i + 1 >= A) {
                    result[i] = minHeap.top();
                }
            }

            return result;
        }
    // Q2. Running Median
        /*
        Q.2 -> Flipkart is currently dealing with the difficulty of precisely estimating and displaying the expected delivery time for orders to a specific pin code. The existing method relies on historical delivery time data for that pin code, using the median value as the expected delivery time. As the order history expands with new entries, Flipkart aims to enhance this process by dynamically updating the expected delivery time whenever a new delivery time is added. The objective is to find the expected delivery time after each new element is incorporated into the list of delivery times. End Goal: With every addition of new delivery time, requirement is to find the median value.
        Why Median ? The median is calculated because it provides a more robust measure of the expected delivery time The median is less sensitive to outliers or extreme values than the mean. In the context of delivery times, this is crucial because occasional delays or unusually fast deliveries (outliers) can skew the mean significantly, leading to inaccurate estimations.
        Given an array of integers, A denoting the delivery times for each order. New arrays of integer B and C are formed, each time a new delivery data is encountered, append it at the end of B and append the median of array B at the end of C. Your task is to find and return the array C.

        NOTE:
        If the number of elements is N in B and N is odd, then consider the median as B[N/2] ( B must be in sorted order).
        If the number of elements is N in B and N is even, then consider the median as B[N/2-1]. ( B must be in sorted order).

        Note :
            

        Problem Constraints
            1 <= length of the array <= 100000
            1 <= A[i] <= 109

        Input Format
            The only argument given is the integer array A.

        Output Format
            Return an integer array C, C[i] denotes the median of the first i delivery times.

        Input 1:
            A = [1, 2, 5, 4, 3]

        Output 1:
            [1, 1, 2, 2, 3]

        Input 2:
            A = [5, 17, 100, 11]

        Output 2:
            [5, 5, 17, 11]

        */

        // CODE
        vector<int> Solution::solve(vector<int> &A) {
            // Max-heap for the smaller half
            priority_queue<int> left;
            // Min-heap for the larger half
            priority_queue<int, vector<int>, greater<int>> right;
            vector<int> result;

            for (int i = 0; i < A.size(); i++) {
                int num = A[i];

                // Add the new number to one of the heaps
                if (left.empty() || num <= left.top()) {
                    left.push(num);
                } else {
                    right.push(num);
                }

                // Balance the heaps (left can have at most 1 more element than right)
                if (left.size() > right.size() + 1) {
                    right.push(left.top());
                    left.pop();
                } else if (right.size() > left.size()) {
                    left.push(right.top());
                    right.pop();
                }

                // Get the median
                result.push_back(left.top());
            }

            return result;
        }
    // Q1. Ways to form Max Heap
        /*
        Q.1 -> Max Heap is a special kind of complete binary tree in which, for every node, the value present in that node is greater than the value present in its children nodes.
        Find the number of distinct Max Heap that can be made from A distinct integers.
        In short, you have to ensure the following properties for the max heap :
        Heap has to be a complete binary tree ( A complete binary tree is a binary tree in which every level, except possibly the last, is completely filled, and all nodes are as far left as possible.)
        Every node is greater than all its children.

        NOTE: If you want to know more about Heaps, please visit this link. Return your answer modulo 109 + 7.

        Problem Constraints
            1 <= A <= 100

        Input Format
            The first and only argument is an integer A.

        Output Format
            Return an integer denoting the number of distinct Max Heap.

        Input 1:
            A = 4

        Output 1:
            3

        Input 2:
            A = 10

        Output 2:
            3360

        */

        // CODE
        vector<int> fact, ifact;
        int mod = 1000000007;

        int expo(int a, int b, int c){
            long long ans=1;
            if(a==0)return 0;
            if(b==0)return 1;
        
            while(b){
                if(b%2==1){
                    ans=(ans*1LL*a)%c;
                }
                a = (a*1LL* a)%c;
            
            
                b=b>>1;
            }
            return ans%c;
        }
        void calcfact(int A, int C){
            fact.resize(A+2);
            ifact.resize(A+2);
            fact[0]=fact[1] = 1;
            ifact[0]=ifact[1] = expo(1,C-2, C);
            for(int i=2;i<=A;i++){
                fact[i] = (fact[i-1]*1LL*i)%C;
                ifact[i] = expo(fact[i],C-2, C);
            }
        }
        //recursive ways func
        int ways(int N){
            if(N==1 | N==2){
                return 1;
            }

            int H = (int) log2(N);
            int twoph = expo (2,H,mod);
            int L=  (twoph/2)-1+ min(N-(twoph-1),(twoph/2));
            int R=N-1-L; //L+R = N-1
            int n1Cl = ((fact[N-1]*1LL*ifact[N-1-L])%mod*1LL*ifact[L])%mod;

            return(( n1Cl*1LL*ways(L))%mod*1LL*ways(R))%mod;
        }

        int Solution::solve(int A) {
        
            calcfact(A,mod);

            //find L R then call ways

            return ways(A);

        }
    // Q2. Product of 3
        /*
        Q.2 -> Given an integer array A of size N.
        You have to find the product of the three largest integers in array A from range 1 to i, where i goes from 1 to N.
        Return an array B where B[i] is the product of the largest 3 integers in range 1 to i in array A. If i < 3, then the integer at index i in B should be -1.

        Problem Constraints
            1 <= N <= 10^5
            0 <= A[i] <= 10^3

        Input Format
            First and only argument is an integer array A.

        Output Format
            Return an integer array B. B[i] denotes the product of the largest 3 integers in range 1 to i in array A.

        Input 1:
            A = [1, 2, 3, 4, 5]

        Output 1:
            [-1, -1, 6, 24, 60]

        Input 2:
            A = [10, 2, 13, 4]

        Output 2:
            [-1, -1, 260, 520]

        */

        // CODE
        vector<int> Solution::solve(vector<int> &A) {
            int n = A.size();
            vector<int> result(n, -1);  // Initialize result with -1 for i < 3
            
            if (n < 3) {
                // If the array has less than 3 elements, return -1 for all positions
                return result;
            }

            // We will store the top 3 largest elements encountered so far
            priority_queue<int> maxHeap;

            for (int i = 0; i < n; i++) {
                // Add the current element to the max heap
                maxHeap.push(A[i]);

                // When we have at least 3 elements in the heap
                if (i >= 2) {
                    vector<int> top3;
                    
                    // Get the top 3 largest elements from the heap
                    for (int j = 0; j < 3; j++) {
                        top3.push_back(maxHeap.top());
                        maxHeap.pop();
                    }

                    // Calculate the product of the top 3 largest numbers
                    result[i] = top3[0] * top3[1] * top3[2];
                    
                    // Push them back into the heap
                    for (int j = 0; j < 3; j++) {
                        maxHeap.push(top3[j]);
                    }
                }
            }

            return result;
        }
    // Q3. Kth Smallest Element in a Sorted Matrix
        /*
        Q.3 -> Given a sorted matrix of integers A of size N x M and an integer B.
        Each of the rows and columns of matrix A is sorted in ascending order, find the Bth smallest element in the matrix.

        NOTE: Return The Bth smallest element in the sorted order, not the Bth distinct element.

        Problem Constraints
            1 <= N, M <= 500
            1 <= A[i] <= 10^9
            1 <= B <= N * M

        Input Format
            The first argument given is the integer matrix A.
            The second argument given is an integer B. 

        Output Format
            Return the B-th smallest element in the matrix.

        Input 1:
            A = [ [9, 11, 15],
                [10, 15, 17] ] 
            B = 6

        Output 1:
            17

        Input 2:
            A = [  [5, 9, 11],
                    [9, 11, 13],
                    [10, 12, 15],
                    [13, 14, 16],
                    [16, 20, 21] ]
            B = 12

        Output 2:
            16

        */

        // CODE
        int countLessEqual(const vector<vector<int>>& A, int mid) {
            int n = A.size(), m = A[0].size();
            int count = 0, row = n - 1, col = 0;
            
            // Start from the bottom-left corner and count elements <= mid
            while (row >= 0 && col < m) {
                if (A[row][col] <= mid) {
                    // All elements in this row till this column are <= mid
                    count += (row + 1);
                    col++;  // Move right to find more elements <= mid
                } else {
                    row--;  // Move up as elements in this row are greater than mid
                }
            }
            return count;
        }

        int Solution::solve(vector<vector<int> > &A, int B) {
            int n = A.size(), m = A[0].size();
            int low = A[0][0], high = A[n-1][m-1];
            
            while (low < high) {
                int mid = low + (high - low) / 2;
                int count = countLessEqual(A, mid);
                
                if (count < B) {
                    low = mid + 1;  // Move right if count is less than B
                } else {
                    high = mid;  // Move left as we need to find a smaller or equal element
                }
            }
            
            // After the loop, low will be the B-th smallest element
            return low;
        }
## Interview Problems ##
    // Metting rooms
        int Solution::solve(int A, vector<vector<int> > &B) {
            
            const int MAX_TIME = 1e6 + 1;
            vector<int> timeline(MAX_TIME, 0);
        
            for(int i=0; i<B.size(); i++){
                int start = B[i][0];
                int end = B[i][1];

                // Increment for start time
                timeline[start] += 1;
                // Decrement for end time (as end time is exclusive)
                if (end < MAX_TIME) {
                    timeline[end] -= 1;
                }
            }

            // Compute the prefix sum and find the maximum value
            int maxRooms = 0;
            int currentRooms = 0;
            
            for (int i = 0; i < MAX_TIME; ++i) {
                currentRooms += timeline[i];
                maxRooms = max(maxRooms, currentRooms);
            }
            
            return maxRooms;
        }
    // Merge K Sorted Array
        vector<int> mergeKSortedArrays(vector<vector<int>> &arrays) {
            // Min-Heap to store elements in the format (value, array index, element index)
            priority_queue<tuple<int, int, int>, vector<tuple<int, int, int>>, greater<tuple<int, int, int>>> minHeap;

            // Resultant merged array
            vector<int> result;

            // Step 1: Push the first element of each array into the heap
            for (int i = 0; i < arrays.size(); ++i) {
                if (!arrays[i].empty()) {
                    minHeap.push({arrays[i][0], i, 0});
                }
            }

            // Step 2: Process the heap
            while (!minHeap.empty()) {
                auto [value, arrayIdx, elementIdx] = minHeap.top();
                minHeap.pop();

                // Add the smallest value to the result
                result.push_back(value);

                // Push the next element from the same array into the heap
                if (elementIdx + 1 < arrays[arrayIdx].size()) {
                    minHeap.push({arrays[arrayIdx][elementIdx + 1], arrayIdx, elementIdx + 1});
                }
            }

            return result;
        }
    // Minimum Window Substring
        string minWindow(string s, string t) {
            if (s.empty() || t.empty()) return "";

            // Frequency map for characters in T
            unordered_map<char, int> tFreq;
            for (char c : t) {
                tFreq[c]++;
            }

            // Frequency map for characters in the current window
            unordered_map<char, int> windowFreq;
            int left = 0, right = 0;
            int minLen = INT_MAX;
            int startIdx = 0;
            int matched = 0;

            while (right < s.size()) {
                char c = s[right];
                windowFreq[c]++;

                // Check if this character satisfies the requirement in T
                if (tFreq.count(c) && windowFreq[c] == tFreq[c]) {
                    matched++;
                }

                // Shrink the window from the left
                while (matched == tFreq.size()) {
                    if (right - left + 1 < minLen) {
                        minLen = right - left + 1;
                        startIdx = left;
                    }

                    char leftChar = s[left];
                    if (tFreq.count(leftChar) && windowFreq[leftChar] == tFreq[leftChar]) {
                        matched--;
                    }
                    windowFreq[leftChar]--;
                    left++;
                }

                right++;
            }

            return minLen == INT_MAX ? "" : s.substr(startIdx, minLen);
        }
    // Q1. Shaggy and distances (Minimum Distance Equal Pair)
        /*
        Q.1 -> Shaggy has an array A consisting of N elements. We call a pair of distinct indices in that array a special if elements at those indices in the array are equal.
        Shaggy wants you to find a special pair such that the distance between that pair is minimum. Distance between two indices is defined as |i-j|. If there is no special pair in the array, then return -1.

        Note :
            

        Problem Constraints
            1 <= |A| <= 10^5

        Input Format
            The first and only argument is an integer array A. 

        Output Format
            Return one integer corresponding to the minimum possible distance between a special pair.

        Input 1:
            A = [7, 1, 3, 4, 1, 7]

        Output 1:
            3

        Input 2:
            A = [1, 1]

        Output 2:
            1

        */

        // CODE
        int Solution::solve(vector<int> &A) {

            unordered_map<int, int> map;
            int ans = INT_MAX;
            for(int i=0; i<A.size(); i++){
                if(map.count(A[i]) > 0){
                    ans = min(ans, i - map[A[i]]);
                }
                map[A[i]] = i;
            }

            if(ans == INT_MAX){
                return -1;
            }else{
                return ans;
            }
        }
    // Q2. K Places Apart
        /*
        Q.2 -> N people having different priorities are standing in a queue.
        The queue follows the property that each person is standing at most B places away from its position in the sorted queue.
        Your task is to sort the queue in the increasing order of priorities.

        NOTE:
        No two persons can have the same priority.
        Use the property of the queue to sort the queue with complexity O(NlogB).

        Problem Constraints
            1 <= N <= 100000
            0 <= B <= N

        Input Format
            The first argument is an integer array A representing the priorities and initial order of N persons.
            The second argument is an integer B.

        Output Format
            Return an integer array representing the sorted queue.

        Input 1:
            A = [1, 40, 2, 3]
            B = 2

        Output 1:
            [1, 2, 3, 40]

        Input 2:
            A = [2, 1, 17, 10, 21, 95]
            B = 1

        Output 2:
            [1, 2, 10, 17, 21, 95]

        */

        // CODE
        vector<int> Solution::solve(vector<int> &A, int B) {

            priority_queue<int, std::vector<int>, std::greater<int>> minHeap;

            for(int i=0; i<=B; i++){
                minHeap.push(A[i]);
            }
            int j=0;
            for(int i=B+1; i<A.size(); i++){
                A[j] = minHeap.top();
                minHeap.pop();
                j++;
                minHeap.push(A[i]);
            }

            for(int i=j; i<A.size(); i++){
                A[i] = minHeap.top();
                minHeap.pop();
            }
            return A;
        }
    // Q3. Merge K Sorted Lists
        /*
        Q.3 -> Given a list containing head pointers of N sorted linked lists.
        Merge these given sorted linked lists and return them as one sorted list.

        Note :
            

        Problem Constraints
            1 <= total number of elements in given linked lists <= 100000

        Input Format
            The first and only argument is a list containing N head pointers.

        Output Format
            Return a pointer to the head of the sorted linked list after merging all the given linked lists.

        Input 1:
        1 -> 10 -> 20
        4 -> 11 -> 13
        3 -> 8 -> 9

        Output 1:
            1 -> 3 -> 4 -> 8 -> 9 -> 10 -> 11 -> 13 -> 20

        Input 2:
        10 -> 12
        13
        5 -> 6

        Output 2:
            5 -> 6 -> 10 -> 12 ->13

        */

        // CODE
        /**
        * Definition for singly-linked list.
        * struct ListNode {
        *     int val;
        *     ListNode *next;
        *     ListNode(int x) : val(x), next(NULL) {}
        * };
        */

        // Comparator for the priority queue (min heap)
        struct Compare {
            bool operator()(ListNode* a, ListNode* b) {
                return a->val > b->val;  // Min heap: smaller values should have higher priority
            }
        };
        ListNode* Solution::mergeKLists(vector<ListNode*> &A) {

            // Priority queue (min heap) to store ListNode pointers
            priority_queue<ListNode*, vector<ListNode*>, Compare> minHeap;

            // Add the head of each linked list to the heap
            for (auto list : A) {
                if (list != NULL) {
                    minHeap.push(list);
                }
            }

            // Dummy node to form the merged linked list
            ListNode* dummy = new ListNode(0);
            ListNode* tail = dummy;

            // Process the heap until it's empty
            while (!minHeap.empty()) {
                // Get the smallest element (top of the heap)
                ListNode* smallest = minHeap.top();
                minHeap.pop();

                // Add the smallest element to the result list
                tail->next = smallest;
                tail = tail->next;

                // If the smallest element has a next node, add it to the heap
                if (smallest->next != NULL) {
                    minHeap.push(smallest->next);
                }
            }

            // Return the merged list starting from the next node of dummy
            return dummy->next;
            
        }
    // Q4. Meeting Rooms II
        /*
        Q.4 -> You are given an array B of meeting time intervals where each interval is represented as [start, end] (with start < end). You need to find the minimum number of conference rooms required to host all the meetings.

        Note :
            

        Problem Constraints
            1 <= B.length <= 104
            0 <= start < end <= 106

        Input Format
            The first line contains an integer n, the number of meetings.
            The next n lines each contain two space-separated integers start and end representing the start and end times of the meetings.

        Output Format
            Output a single integer representing the minimum number of conference rooms required.

        Input 1:
            A = 3
            B = [ [0, 30],
                [5, 10],
                [15, 20] ]

        Output 1:
            2

        Input 2:
            A = 1
            B = [ [0, 1] ]

        Output 2:
            1

        */

        // CODE
        int Solution::solve(int A, vector<vector<int> > &B) {
            
            const int MAX_TIME = 1e6 + 1;
            vector<int> timeline(MAX_TIME, 0);
        
            for(int i=0; i<B.size(); i++){
                int start = B[i][0];
                int end = B[i][1];

                // Increment for start time
                timeline[start] += 1;
                // Decrement for end time (as end time is exclusive)
                if (end < MAX_TIME) {
                    timeline[end] -= 1;
                }
            }

            // Compute the prefix sum and find the maximum value
            int maxRooms = 0;
            int currentRooms = 0;
            
            for (int i = 0; i < MAX_TIME; ++i) {
                currentRooms += timeline[i];
                maxRooms = max(maxRooms, currentRooms);
            }
            
            return maxRooms;
        }
## Heaps Extra ##
// Greedy
## Greedy 1: Introduction ##
    // Q1. Flipkart's Challenge in Effective Inventory Management
        /*
        Q.1 -> In the recent expansion into grocery delivery, Flipkart faces a crucial challenge in effective inventory management. Each grocery item on the platform carries its own expiration date and profit margin, represented by two arrays, A and B of size N. A[i] denotes the time left before expiration date for the ith item, and B[i] denotes profit margin for the ith item. To mitigate potential losses due to expiring items, Flipkart is seeking a strategic solution.
        The objective is to identify a method to strategically buy certain items, ensuring they are sold before their expiration date, thereby maximizing overall profit. Can you assist Flipkart in developing an innovative approach to optimize their grocery inventory and enhance profitability?
        Your task is to find the maximum profit one can earn by buying groceries considering that you can only buy one grocery item at a time.

        NOTE:
        You can assume that it takes 1 minute to buy a grocery item, so you can only buy the ith grocery item when the current time <= A[i] - 1.
        You can start buying from day = 0.
        Return your answer modulo 109 + 7.

        Problem Constraints
        1 <= N <= 105
            1 <= A[i] <= 109
            0 <= B[i] <= 109



        Input Format
            The first argument is an integer array A represents the deadline for buying the grocery items.
            The second argument is an integer array B represents the profit obtained after buying the grocery items.

        Output Format
            Return an integer denoting the maximum profit you can earn.

        Input 1:
            A = [1, 3, 2, 3, 3]
            B = [5, 6, 1, 3, 9]

        Output 1:
            20

        Input 2:
            A = [3, 8, 7, 5]
            B = [3, 1, 7, 19]

        Output 2:
            30

        */

        // CODE
        int Solution::solve(vector<int> &A, vector<int> &B) {
            const int MOD = 1000000007;
            vector<pair<int, int>> pairs;

            for(int i=0;i<A.size();i++){
                pairs.push_back({A[i], B[i]});
            }

            sort(pairs.begin(), pairs.end());
            for(int i=0; i<A.size(); i++){
                A[i] = pairs[i].first;
                B[i] = pairs[i].second;
            }

            priority_queue<int,vector<int>,greater<int>> heap;

            // cout<<" A:- ";
            // for(int i=0; i<B.size(); i++){ cout<< ", "<<A[i]<<" ";}
            // cout<<" |B:- ";
            // for(int i=0; i<B.size(); i++){ cout<< ", "<<B[i]<<" ";}

            int t=0;
            int ans =0;
            for(int i=0; i<B.size(); i++){
                if(t<A[i]){
                    ans = (ans +B[i]) % MOD;
                    heap.push(B[i]);
                    t++;
                }else if(B[i] > heap.top()){
                    ans = (ans - heap.top() + MOD) % MOD;
                    ans = (ans +B[i]) % MOD;
                    heap.pop();
                    heap.push(B[i]);
                }
            }

            return ans;
        }


    // Q2. Finish Maximum Jobs
        /*
        Q.2 -> There are N jobs to be done, but you can do only one job at a time.
        Given an array A denoting the start time of the jobs and an array B denoting the finish time of the jobs.
        Your aim is to select jobs in such a way so that you can finish the maximum number of jobs.
        Return the maximum number of jobs you can finish.

        Note :
            

        Problem Constraints
            1 <= N <= 105
            1 <= A[i] < B[i] <= 109

        Input Format
            The first argument is an integer array A of size N, denoting the start time of the jobs.
            The second argument is an integer array B of size N, denoting the finish time of the jobs.

        Output Format
            Return an integer denoting the maximum number of jobs you can finish.

        Input 1:
            A = [1, 5, 7, 1]
            B = [7, 8, 8, 8]

        Output 1:
            2

        Input 2:
            A = [3, 2, 6]
            B = [9, 8, 9]

        Output 2:
            1

        */

        // CODE
        int Solution::solve(vector<int> &A, vector<int> &B) {

            vector<pair<int, int>> pairs;

            for(int i=0;i<A.size();i++){
                pairs.push_back({B[i], A[i]});
            }

            sort(pairs.begin(), pairs.end());
            for(int i=0; i<A.size(); i++){
                B[i] = pairs[i].first;
                A[i] = pairs[i].second;
            }

            int ans = 1;
            int end = B[0];

            for(int i=0; i<A.size(); i++){
                if(A[i] >= end){
                    ans++;
                    end = B[i];
                }
            }

            return ans;

        }
    // Q3. Distribute Candy
        /*
        Q.3 -> N children are standing in a line. Each child is assigned a rating value.
        You are giving candies to these children subjected to the following requirements:
            Each child must have at least one candy.
            Children with a higher rating get more candies than their neighbors.
        What is the minimum number of candies you must give?

        Problem Constraints
            1 <= N <= 10^5
            -10^9 <= A[i] <= 10^9

        Input Format
            The first and only argument is an integer array A representing the rating of children.

        Output Format
            Return an integer representing the minimum candies to be given.

        Input 1:
            A = [1, 2]

        Output 1:
            3

        Input 2:
            A = [1, 5, 2, 1]

        Output 2:
            7

        */

        // CODE
        int Solution::candy(vector<int> &A) {
            int n = A.size();

            int ans = 0;
            vector<int> C(n, 1);

            for(int i=1; i<n; i++){
                if(A[i] > A[i-1]){
                    C[i] = C[i-1]+1;
                } 
            }

            ans += C[n-1];
            for(int i=n-2; i>=0; i--){
                if(A[i] > A[i+1]){
                    C[i] =  max(C[i], C[i+1]+1);
                }
                
                ans += C[i];
            }

            return ans;
        }
    // Q1. Another Coin Problem
        /*
        Q.1 -> The monetary system in DarkLand is really simple and systematic. The locals-only use coins. The coins come in different values. The values used are:
        1, 5, 25, 125, 625, 3125, 15625, ...
        Formally, for each K >= 0 there are coins worth 5K.
        Given an integer A denoting the cost of an item, find and return the smallest number of coins necessary to pay exactly the cost of the item (assuming you have a sufficient supply of coins of each of the types you will need)

        Note :
            

        Problem Constraints
            1 <= A <= 210^9

        Input Format
            The only argument given is integer A.       

        Output Format
            Return the smallest number of coins necessary to pay exactly the cost of the item.

        Input 1:
            A = 47

        Output 1:
            A = 9

        Input 2:
            7

        Output 2:
            5

        */

        // CODE
        int Solution::solve(int A) {
             vector<int> coins;
    
            // Generate all coin values <= A
            long long coinValue = 1;
            while (coinValue <= A) {
                coins.push_back(coinValue);
                coinValue *= 5;
            }
            
            int count = 0;  // To store the number of coins
            int n = coins.size();
            
            // Traverse from the largest coin to the smallest
            for (int i = n - 1; i >= 0; i--) {
                if (A == 0) break;  // If A is fully paid
                count += A / coins[i];  // Use as many coins of this value as possible
                A %= coins[i];         // Reduce A by the total value paid using this coin
            }
            
            return count;  // Return the minimum number of coins
        }
    // Q2. Seats
        /*
        Q.2 -> There is a row of seats represented by string A. Assume that it contains N seats adjacent to each other.
        There is a group of people who are already seated in that row randomly. i.e. some are sitting together & some are scattered.
        An occupied seat is marked with a character 'x' and an unoccupied seat is marked with a dot ('.')
        Now your target is to make the whole group sit together i.e. next to each other, without having any vacant seat between them in such a way that the total number of hops or jumps to move them should be minimum.
        In one jump a person can move to the adjacent seat (if available).

        NOTE: 1. Return your answer modulo 10^7 + 3.

        Problem Constraints
            1 <= N <= 1000000
            A[i] = 'x' or '.'
            
        Input Format
            The first and only argument is a string A of size N.  

        Output Format
            Return an integer denoting the minimum number of jumps required.

        Input 1:
            A = "....x..xx...x.."

        Output 1:
            5

        Input 2:
            A = "....xxx"

        Output 2:
            0

        */

        // CODE
        int Solution::seats(string A) {
            const int MOD = 10000003;
            vector<int> ocupied_seats;
            int N = A.size();
            for(int i=0; i<N; i++){
                if(A[i] == 'x'){
                    ocupied_seats.push_back(i);
                }
            }

            if(ocupied_seats.size() == 0){
                return 0;
            }
            int mid = ocupied_seats.size()/2;
            int median = ocupied_seats[mid]; 

            int Seat_no = median-mid;

            // cout<<" | ocupied_seats :- ";
            // for(int i=0; i<ocupied_seats.size(); i++){ cout<< ", "<<ocupied_seats[i]<<" ";}
            // cout<<" | median :- "<<median;
            // cout<<" | Seat_no :- "<<Seat_no << " " ;

            int ans = 0;
            for(int i=0; i<ocupied_seats.size(); i++){
                ans = (ans + abs(Seat_no - ocupied_seats[i])) % MOD;
                // cout<<" | distance :- " << abs(Seat_no - ocupied_seats[i]) << " | ";
                // cout<<" | ans :- " << ans << " | ";
                Seat_no++;
            }

            return ans;
        }
    // Q3. Assign Mice to Holes
        /*
        Q.3 -> N Mice and N holes are placed in a straight line. Each hole can accommodate only one mouse.
        The positions of Mice are denoted by array A, and the position of holes is denoted by array B.
        A mouse can stay at his position, move one step right from x to x + 1, or move one step left from x to x  1. Any of these moves consume 1 minute.
        Assign mice to holes so that the time when the last mouse gets inside a hole is minimized.

        Note :
            

        Problem Constraints
            1 <= N <= 10^5
            -10^9 <= A[i], B[i] <= 10^9

        Input Format
            The first argument is an integer array A.
            The second argument is an integer array B.

        Output Format
            Return an integer denoting the minimum time when the last nouse gets inside the holes.

        Input 1:
            A = [-4, 2, 3]
            B = [0, -2, 4]

        Output 1:
            2

        Input 2:
            A = [-2]
            B = [-6]

        Output 2:
            4

        */

        // CODE
        int Solution::mice(vector<int> &A, vector<int> &B) {

            sort(A.begin(), A.end());
            sort(B.begin(), B.end());

            int min_time = 0;

            for(int i=0; i<A.size(); i++){
                int time = abs(A[i] - B[i]);
                min_time = max(min_time, time);
            }

            return min_time;
        }

## Greedy Extra ## 
    // Assign Cokie
        int findContentChildren(std::vector<int>& g, std::vector<int>& s) {
            // Sort the greed factors and cookie sizes
            std::sort(g.begin(), g.end());
            std::sort(s.begin(), s.end());
            
            int L = 0; // Pointer for children
            int R = 0; // Pointer for cookies
            
            // Assign cookies to children using a greedy approach
            while (L < s.size() && R < g.size()) {
                if (g[R] <= s[L]) {
                    // If the cookie can satisfy the child's greed
                    R++;
                }
                // Move to the next cookie in either case
                L++;
            }
            
            // The number of satisfied children is equal to L
            return R;
        }
    // Lemonade Change
        bool lemonadeChange(std::vector<int>& bills) {
            int fiveDollar = 0, tenDollar = 0; // Count of $5 and $10 bills
            
            for (int bill : bills) {
                if (bill == 5) {
                    // Customer pays with $5
                    fiveDollar++;
                } else if (bill == 10) {
                    // Customer pays with $10
                    if (fiveDollar > 0) {
                        fiveDollar--; // Give change using one $5 bill
                        tenDollar++;
                    } else {
                        return false; // Not enough $5 bills for change
                    }
                } else {
                    // Customer pays with $20
                    if (tenDollar > 0 && fiveDollar > 0) {
                        tenDollar--; // Give change using one $10 bill
                        fiveDollar--; // Give change using one $5 bill
                    } else if (fiveDollar >= 3) {
                        fiveDollar -= 3; // Give change using three $5 bills
                    } else {
                        return false; // Not enough bills for change
                    }
                }
            }
            
            return true; // Successfully provided change to all customers
        }
    // Program for Shortest Job First (or SJF) CPU Scheduling
        double shortestJobFirst(std::vector<int>& burstTimes) {
            // Step 1: Sort the array of burst times
            std::sort(burstTimes.begin(), burstTimes.end());
            
            // Step 2: Initialize time and waiting
            int time = 0;
            int waiting = 0;
            int n = burstTimes.size();
            
            // Step 3: Traverse the array from left to right
            for (int i = 0; i < n; i++) {
                // Step 4: Accumulate time and waiting time
                time += burstTimes[i];
                waiting += time;
            }
            
            // Step 5: Return the average waiting time
            return static_cast<double>(waiting) / n;
        }
    // Jump Game
        bool canJump(std::vector<int>& nums) {
            // Step 1: Initialize MaxInd to keep track of the maximum reachable index
            int MaxInd = 0;

            // Step 2: Traverse the array
            for (int i = 0; i < nums.size(); i++) {
                // If the current index is beyond the maximum reachable index, return false
                if (i > MaxInd) {
                    return false;
                }
                // Update the maximum reachable index
                MaxInd = std::max(MaxInd, i + nums[i]);
            }

            // Step 3: Return true if we can reach the end
            return true;
        }
    // Jump Game II (return min Jumps)
        int minJumps(std::vector<int>& nums) {
            // Step 1: Initialize jumps, L, and R
            int jumps = 0;
            int L = 0, R = 0;
            int n = nums.size();

            // Step 2: Traverse while R (right pointer) has not reached the end
            while (R < n - 1) {
                int farthest = 0;
                
                // Step 3: Find the farthest we can reach in the current range [L, R]
                for (int i = L; i <= R; i++) {
                    farthest = std::max(farthest, i + nums[i]);
                }

                // Move to the next range
                L = R + 1;
                R = farthest;
                jumps++;
                
                // If we cannot progress further, return -1 (edge case handling)
                if (L > R) {
                    return -1;
                }
            }

            // Step 4: Return the number of jumps
            return jumps;
        }
        
    // Job sequencing Problem
        // Structure to represent a job
        struct Job {
            int id;       // Job ID
            int deadline; // Deadline of job
            int profit;   // Profit if job is completed within its deadline
        };

        // Comparator function to sort jobs in descending order of profit
        bool jobComparator(Job a, Job b) {
            return a.profit > b.profit;
        }

        int jobSequencingProblem(std::vector<Job>& jobs) {
            // Step 1: Sort jobs according to profit in descending order
            std::sort(jobs.begin(), jobs.end(), jobComparator);

            // Step 2: Initialize totalProfit, cnt, and find max_deadline
            int totalProfit = 0, cnt = 0;
            int max_deadline = -1;

            // Find the maximum deadline among all jobs
            for (const auto& job : jobs) {
                max_deadline = std::max(max_deadline, job.deadline);
            }

            // Step 3: Create a hash array to keep track of filled slots
            std::vector<int> hash(max_deadline + 1, -1); // Initialize with -1 (unfilled slots)

            // Step 4: Traverse through all jobs to schedule them
            for (const auto& job : jobs) {
                // Try to find a slot from job.deadline to 0 (reverse traversal)
                for (int j = job.deadline; j > 0; j--) {
                    if (hash[j] == -1) { // If slot is available
                        cnt++;
                        hash[j] = job.id; // Assign the job ID to this slot
                        totalProfit += job.profit; // Add the profit
                        break; // Break since job is scheduled
                    }
                }
            }

            // Return total profit
            return totalProfit;
        }
    // N meetings in one room
        // Structure to store meeting details
        struct Meeting {
            int start; // Start time of the meeting
            int end;   // End time of the meeting
            int pos;   // Position of the meeting in the original input
        };

        // Comparator function to sort meetings by their end time
        bool meetingComparator(Meeting a, Meeting b) {
            if (a.end == b.end) {
                return a.pos < b.pos; // If end times are equal, sort by original position
            }
            return a.end < b.end;
        }

        std::vector<int> maxMeetings(std::vector<int>& start, std::vector<int>& end, int n) {
            // Step 1: Create a vector of Meeting structures
            std::vector<Meeting> meetings(n);
            for (int i = 0; i < n; i++) {
                meetings[i] = {start[i], end[i], i + 1}; // Store meeting data
            }

            // Step 2: Sort the meetings based on their end times
            std::sort(meetings.begin(), meetings.end(), meetingComparator);

            // Step 3: Initialize count, freetime, and a vector to store the selected meeting positions
            int cnt = 1; // At least one meeting is selected (the first)
            int freetime = meetings[0].end; // End time of the first meeting
            std::vector<int> selectedMeetings = {meetings[0].pos}; // First meeting selected

            // Step 4: Traverse the remaining meetings to select non-overlapping ones
            for (int i = 1; i < n; i++) {
                if (meetings[i].start > freetime) {
                    cnt++;
                    freetime = meetings[i].end; // Update the free time
                    selectedMeetings.push_back(meetings[i].pos); // Add position of the selected meeting
                }
            }

            // Step 5: Return the selected meetings
            return selectedMeetings;
        }
    // Non-overlapping Intervals
        int eraseOverlapIntervals(std::vector<std::vector<int>>& intervals) {
            if (intervals.empty()) {
                return 0;
            }

            // Step 1: Sort intervals by their end times (second element)
            std::sort(intervals.begin(), intervals.end(), [](const std::vector<int>& a, const std::vector<int>& b) {
                return a[1] < b[1];
            });

            // Step 2: Initialize variables
            int cnt = 1; // Count of non-overlapping intervals (we always count the first interval)
            int lastEndTime = intervals[0][1]; // Track end time of the last selected interval

            // Step 3: Traverse the intervals
            for (int i = 1; i < intervals.size(); i++) {
                if (intervals[i][0] >= lastEndTime) {
                    // If the current interval does not overlap with the last selected interval
                    cnt++;
                    lastEndTime = intervals[i][1]; // Update last end time
                }
            }

            // Step 4: Return the number of intervals to remove (total intervals - count of non-overlapping intervals)
            return intervals.size() - cnt;
        }

    // Insert Interval
        std::vector<std::vector<int>> insertInterval(std::vector<std::vector<int>>& intervals, std::vector<int>& newInterval) {
            std::vector<std::vector<int>> res; // Result to store the merged intervals
            int i = 0;
            int n = intervals.size();

            // Step 2: Add all intervals that end before the start of newInterval
            while (i < n && intervals[i][1] < newInterval[0]) {
                res.push_back(intervals[i]);
                i++;
            }

            // Step 3: Merge overlapping intervals with newInterval
            while (i < n && intervals[i][0] <= newInterval[1]) {
                newInterval[0] = std::min(newInterval[0], intervals[i][0]);
                newInterval[1] = std::max(newInterval[1], intervals[i][1]);
                i++;
            }
            // Add the merged interval
            res.push_back(newInterval);

            // Step 4: Add the remaining intervals that start after newInterval ends
            while (i < n) {
                res.push_back(intervals[i]);
                i++;
            }

            return res;
        }

    // Minimum number of platforms required for a railway
        int findMinimumPlatforms(std::vector<int>& arrival, std::vector<int>& departure) {
            int n = arrival.size();

            // Step 1: Sort arrival and departure times
            std::sort(arrival.begin(), arrival.end());
            std::sort(departure.begin(), departure.end());

            // Step 2: Initialize pointers and counters
            int i = 0, j = 0; // Pointers for arrival and departure arrays
            int cnt = 0, max_cnt = 0;

            // Step 3: Traverse through the times
            while (i < n && j < n) {
                // If next event in timeline is an arrival
                if (arrival[i] <= departure[j]) {
                    cnt++; // A new platform is needed
                    max_cnt = std::max(max_cnt, cnt); // Update maximum platforms needed
                    i++;
                }
                // If next event is a departure
                else {
                    cnt--; // A train departs, freeing a platform
                    j++;
                }
            }

            // Step 4: Return the maximum number of platforms needed
            return max_cnt;
        }
    // Valid Paranthesis Checker
        // solution 1 Recursive (3^N)
            bool isValidParenthesesStringRecursive(const std::string &s, int ind, int cnt) {
                // Base cases
                if (cnt < 0) return false; // More ')' than '(' at any point
                if (ind == s.size()) return cnt == 0; // Valid only if completely balanced

                // Recursive exploration
                if (s[ind] == '(') {
                    return isValidParenthesesStringRecursive(s, ind + 1, cnt + 1); // Increment count for '('
                } else if (s[ind] == ')') {
                    return isValidParenthesesStringRecursive(s, ind + 1, cnt - 1); // Decrement count for ')'
                } else { // Handling wildcard '*'
                    return isValidParenthesesStringRecursive(s, ind + 1, cnt + 1) || // Consider as '('
                        isValidParenthesesStringRecursive(s, ind + 1, cnt - 1) || // Consider as ')'
                        isValidParenthesesStringRecursive(s, ind + 1, cnt);       // Consider as empty
                }
            }

        // solution 2 (N)
            bool isValidParenthesesString(std::string S) {
                int minBalance = 0, maxBalance = 0;
                
                for (char c : S) {
                    if (c == '(') {
                        minBalance++;
                        maxBalance++;
                    } else if (c == ')') {
                        minBalance--;
                        maxBalance--;
                    } else { // Handling wildcard '*'
                        minBalance--; 
                        maxBalance++;
                    }
                    
                    // Adjust minimum balance, it cannot go negative
                    if (minBalance < 0) minBalance = 0;

                    // If maxBalance is negative, there's no way to balance the parentheses
                    if (maxBalance < 0) return false;
                }
                
                // Valid if the minimum balance is exactly 0
                return minBalance == 0;
            }
    // Candy
        // Solution 1
            int candy(std::vector<int>& ratings) {
                int n = ratings.size();
                if (n == 0) return 0;

                std::vector<int> left(n, 1), right(n, 1);

                // Left iteration
                for (int i = 1; i < n; ++i) {
                    if (ratings[i] > ratings[i - 1]) {
                        left[i] = left[i - 1] + 1;
                    } else {
                        left[i] = 1;
                    }
                }

                // Right iteration
                for (int i = n - 2; i >= 0; --i) {
                    if (ratings[i] > ratings[i + 1]) {
                        right[i] = right[i + 1] + 1;
                    } else {
                        right[i] = 1;
                    }
                }

                // Calculate the sum
                int sum = 0;
                for (int i = 0; i < n; ++i) {
                    sum += std::max(left[i], right[i]);
                }

                return sum;
            }
        // Solution 2
            int candy(std::vector<int>& ratings) {
                int n = ratings.size();
                if (n == 0) return 0;

                int sum = 1; // Every child gets at least one candy
                int i = 1;

                while (i < n) {
                    // If ratings are equal, just add one candy and move on
                    if (ratings[i] == ratings[i - 1]) {
                        sum += 1;
                        i++;
                        continue;
                    }

                    // Handle increasing sequence (peak)
                    int peak = 1;
                    while (i < n && ratings[i] > ratings[i - 1]) {
                        peak++;
                        sum += peak;
                        i++;
                    }

                    // Handle decreasing sequence (valley)
                    int down = 0;
                    while (i < n && ratings[i] < ratings[i - 1]) {
                        down++;
                        sum += down;
                        i++;
                    }

                    // Adjust if the downward sequence was longer than the peak
                    if (down > peak) {
                        sum += down - peak + 1;
                    } else {
                        sum += 1; // For flat sections or where peak adjustment is not necessary
                    }
                }

                return sum;
            }
    // Fractional Knapsack Problem
        struct Item {
            int value;
            int weight;
        };

        // Comparator function to sort items according to value-to-weight ratio
        bool comparator(Item a, Item b) {
            double r1 = (double)a.value / (double)a.weight;
            double r2 = (double)b.value / (double)b.weight;
            return r1 > r2;
        }

        double fractionalKnapsack(int W, std::vector<Item>& items) {
            // Sort items by value-to-weight ratio
            std::sort(items.begin(), items.end(), comparator);

            double maxValue = 0.0; // Maximum value we can achieve
            for (const auto& item : items) {
                if (W == 0) break; // If the knapsack is full, we stop

                if (item.weight <= W) {
                    // If the whole item can fit, take it all
                    W -= item.weight;
                    maxValue += item.value;
                } else {
                    // Take the fraction of the remaining weight
                    maxValue += item.value * ((double)W / (double)item.weight);
                    W = 0; // The knapsack is now full
                }
            }

            return maxValue;
        }
    // Greedy algorithm to find minimum number of coins
    // Program for Least Recently Used (LRU) Page Replacement Algorithm
// RCURSION & Backtracking
## Recursion 1 ##
    // Q1. Find Fibonacci - II
        /*
        Q.1 -> The Fibonacci numbers are the numbers in the following integer sequence.
        0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, ..
        In mathematical terms, the sequence Fn of Fibonacci numbers is defined by the recurrence relation:
        Fn = Fn-1 + Fn-2
        Given a number A, find and return the Ath Fibonacci Number using recursion.
        Given that F0 = 0 and F1 = 1.

        Note :
            

        Problem Constraints
        0 <= A <= 20

        Input Format
            First and only argument is an integer A.

        Output Format
            Return an integer denoting the Ath term of the sequence.

        Input 1:
            A = 2

        Output 1:
            1

        Input 2:
            A = 9

        Output 2:
            34

        */

        // CODE

        int fib(int N){
        //    if(N == 1){
        //        return 1;
        //    }else if(N == 0){
        //        return 0;
        //    }else{
        //         return fib(N-1) + fib(N-2);
        //    }

        if(N <= 1){
            return N;
        }else{
                return fib(N-1) + fib(N-2);
        }
        }

        int Solution::findAthFibonacci(int A) {
            int F = fib(A);
            return F;
        }
    // Q2. Find Factorial!
        /*
        Q.2 -> Write a program to find the factorial of the given number A using recursion.

        Note: The factorial of a number N is defined as the product of the numbers from 1 to N.

        Problem Constraints
            0 <= A <= 12

        Input Format
            First and only argument is an integer A.

        Output Format
            Return an integer denoting the factorial of the number A.

        Input 1:
            A = 4

        Output 1:
            24

        Input 2:
            A = 1

        Output 2:
            1

        */

        // CODE
        int fact(int N){
            if(N==0){
                return 1;
            }else{
                return N * fact(N-1);
            }
        }

        int Solution::solve(int A) {

            return fact(A);
        }
    // Q3. Print 1 to A function
        /*
        Q.3 -> You are given an integer A, print 1 to A using using recursion.

        Note :- After printing all the numbers from 1 to A, print a new line.

        Problem Constraints
            1 <= A <= 104

        Input Format
            First argument A is an integer. 

        Output Format
            Print A space-separated integers 1 to A.
            Note: There should be exactly one space after each integer. After printing all the integers, print a new line

        Input 1:
            A = 10

        Output 1:
            1 2 3 4 5 6 7 8 9 10 

        Input 2:
            A = 5

        Output 2:
            1 2 3 4 5 

        */

        // CODE
        void inc(int N){
            // if(N==1){
            //     cout<<N<< " " ;
            //     return;
            // }else{
            //     inc(N-1);
            //     cout<<N<< " ";
            // }

            if(N == 1){
                cout<<N<<" ";
                return;
            }

            inc(N-1);

            cout<<N<<" ";

        
        }

        void Solution::solve(int A) {
            inc(A);
            cout<<"\n";
        }
    // Q1. Sum of Digits!
        /*
        Q.1 -> Given a number A, we need to find the sum of its digits using recursion.

        Note :
            

        Problem Constraints
            1 <= A <= 10^9

        Input Format
            The first and only argument is an integer A.

        Output Format
            Return an integer denoting the sum of digits of the number A.

        Input 1:
            A = 46

        Output 1:
            10

        Input 2:
            A = 11

        Output 2:
            2

        */

        // CODE
        int sumOfDigits(int A) {
            // Base case: if A is 0, return 0
            if (A == 0) return 0;
            
            // Recursive case: return the last digit + sum of the rest of the digits
            return (A % 10) + sumOfDigits(A / 10);
        }

        int Solution::solve(int A) {
            return sumOfDigits(A);
        }
    // Q2. Print A to 1 function
        /*
        Q.2 -> You are given an integer A, print A to 1 using using recursion.

        Note :- After printing all the numbers from A to 1, print a new line.

        Problem Constraints
            1 <= A <= 10^4

        Input Format
            First argument A is an integer.

        Output Format
            Print A space-separated integers A to 1.
            Note: There should be exactly one space after each integer. Print a new line after printing the A integers

        Input 1:
            10

        Output 1:
            10 9 8 7 6 5 4 3 2 1

        Input 2:
            5

        Output 2:
            5 4 3 2 1 

        */

        // CODE
        void dec(int N){
            if (N==1){
                cout<<N<<" ";
                return;
            }else{
                cout<<N<<" ";
                dec(N-1);
            }
        }

        void Solution::solve(int A) {
            dec(A);
            cout<<"\n";
        }
    // Q3. Decreasing Increasing in one Function
        /*
        Q.3 -> Print N numbers in Decreasing Order and then in Increasing Order.
        You are given a positive number N.
        You are required to print the numbers from N to 1.
        You are required to not use any loops. Don't change the signature of the function DecThenInc function.

        Note : Please print an new line after printing the output.

        Problem Constraints
            1 <= N <= 100   

        Input Format
            The first line contains a single integer N.

        Output Format
            A single line having number printed from N to 1 and then from 1 to N.

        Input 1:
            1

        Output 1:
            1 1

        Input 2:
            4

        Output 2:
            4 3 2 1 1 2 3 4


        */

        // CODE
        void decinc(int N){
            if(N==0){
                return;
            }
            cout<<N << " ";
            decinc(N-1);
            cout<<N << " ";

        }

        void Solution::DecThenInc(int A) {
            decinc(A);
            cout<<"\n";
        }

## Recursion 2 ##
    // Q1. Implement Power Function
        /*
        Q.1 -> Implement pow(A, B) % C. In other words, given A, B and C, Find (AB % C). 

        Note : The remainders on division cannot be negative. In other words, make sure the answer you return is non-negative.
            

        Problem Constraints
            -109 <= A <= 109
            0 <= B <= 109
            1 <= C <= 109

        Input Format
            Given three integers A, B, C.

        Output Format
            Return an integer.

        Input 1:
            A = 2
            B = 3
            C = 3

        Output 1:
            2

        Input 2:
            A = 3
            B = 3
            C = 1

        Output 2:
            0

        */

        // CODE
        int Solution::pow(int A, int B, int C) {

            // Approach 1
            if (B == 0) return 1 % C; // Base case: A^0 is 1
            long long half = pow(A, B / 2, C); // Recursive step
            half = (half * half) % C; // Combine the results of the two halves
            if (B % 2 != 0) { // odd case
                half = (half * (A % C)) % C; // If B is odd, multiply by A one more time
            }
            // Make sure result is positive
            if (half < 0) {
                half = (half + C) % C;
            }
            return half;


        }
    // Q2. Print Array using Recursion
        /*
        Q.2 -> You are given an array A. Print the elements of the array using recursion

        Note :  You are required to not use any loops, You can create new functions.
                Don't change the signature of the function PrintArray.
                Print a new empty line after printing the output.
            

        Problem Constraints
            1 <= | A | <= 100
            -1000 <= A[i] <= 1000

        Input Format
            One line containing the array A

        Output Format
            Print the elements of the array in the sequential order.

        Input 1:
            A = [6, -2, 5, 3]

        Output 1:
            6 -2 5 3 

        Input 2:
            A = [1]

        Output 2:
            1 

        */

        // CODE
        void PrintArrayHelper(const std::vector<int> &A, int index) {
                // Base case: if the current index is equal to the size of the array, return
                if (index == A.size()) {
                    return;
                }
                
                // Print the current element
                std::cout << A[index] << " ";
                
                // Recursive call for the next element
                PrintArrayHelper(A, index + 1);
        }

        void Solution::PrintArray(vector<int> &A) {
            PrintArrayHelper(A, 0);
            cout<<"\n";
        }
    // Q3. Max of an Array Using Recursion
        /*
        Q.3 -> Given an array A of size N, write a recursive function that returns the maximum element of the array.

        Note :
            

        Problem Constraints
            1 <= N <= 100
            1 <= A[i] <= 1000

        Input Format
            The first line contains the array A.

        Output Format
            A single integer is the maximum value of the array.

        Input 1:
            A = [12, 10, 3, 4, 5]

        Output 1:
            12

        Input 2:
            A = [1, 5, 80, 40]

        Output 2:
            80

        */

        // CODE
        int findMaxHelper(const std::vector<int> &A, int index, int maxSoFar) {
                // Base case: if the current index is equal to the size of the array, return the maximum found so far
                if (index == A.size()) {
                    return maxSoFar;
                }
                
                // Update the maximum found so far
                maxSoFar = std::max(maxSoFar, A[index]);
                
                // Recursive call for the next element
                return findMaxHelper(A, index + 1, maxSoFar);
        }

        int Solution::getMax(vector<int> &A) {

            return findMaxHelper(A, 0, A[0]);
        }
    // Q4. Check Palindrome using Recursion
        /*
        Q.4 -> Write a recursive function that checks whether string A is a palindrome or Not.
        Return 1 if the string A is a palindrome, else return 0.

        Note: A palindrome is a string that's the same when read forward and backward.

        Problem Constraints
            1 <= |A| <= 50000
            String A consists only of lowercase letters.    

        Input Format
            The first and only argument is a string A.

        Output Format
            Return 1 if the string A is a palindrome, else return 0.

        Input 1:
            A = "naman"

        Output 1:
            1

        Input 2:
            A = "strings"

        Output 2:
            0

        */

        // CODE
        bool isPalindromeHelper(const std::string &A, int start, int end) {
            // Base case: if start is greater than or equal to end, it's a palindrome
            if (start >= end) {
                return true;
            }
            
            // Check if the characters at start and end positions are the same
            if (A[start] != A[end]) {
                return false;
            }
            
            // Recursive call to check the next pair of characters
            return isPalindromeHelper(A, start + 1, end - 1);
        }

        int Solution::solve(string A) {
            return isPalindromeHelper(A, 0, A.size() - 1) ? 1 : 0;
        }

    // Q5. All Indices Of Array
        /*
        Q.5 -> Given an array of integers A with N elements and a target integer B, the task is to find all the indices at which B occurs in the array.

        Note: The problem encourages recursive logic for learning purposes. Although the online judge doesn't enforce recursion, it's recommended to use recursive solutions to align with the question's spirit.

        Problem Constraints
            1 <= N <= 103
            1 <= A[i] <= 103
            1 <= B <= 103
            It is guaranteed that the target B, exist atleast once in the Array A.

        Input Format
            First Argument in an Array of Integers, A.
            Second Argument is the Target, B. 

        Output Format
            Return the sorted array of indices.

        Input 1:
            A = [1, 2, 3, 4, 5]
            B = 1

        Output 1:
            [0]

        Input 2:
            A = [8, 9, 5, 6, 5, 5]
            B = 5

        Output 2:
            [2, 4, 5]

        */

        // CODE
        void findIndicesHelper(const std::vector<int> &A, int B, int index, std::vector<int> &indices) {
            // Base case: if the current index is equal to the size of the array, return
            if (index == A.size()) {
                return;
            }
            
            // If the current element matches B, add the index to the list of indices
            if (A[index] == B) {
                indices.push_back(index);
            }
            
            // Recursive call for the next element
            findIndicesHelper(A, B, index + 1, indices);
        }

        vector<int> Solution::allIndices(vector<int> &A, int B) {
            std::vector<int> indices;
            findIndicesHelper(A, B, 0, indices); // Start the recursion with the initial index 0
            return indices;
        }
    // Q6. Tower of Hanoi
        /*
        Q.6 -> In the classic problem of the Towers of Hanoi, you have 3 towers numbered from 1 to 3 (left to right) and A disks numbered from 1 to A (top to bottom) of different sizes which can slide onto any tower.
        The puzzle starts with disks sorted in ascending order of size from top to bottom (i.e., each disk sits on top of an even larger one).
        You have the following constraints:

        Only one disk can be moved at a time.
        A disk is slid off the top of one tower onto another tower.
        A disk cannot be placed on top of a smaller disk.
        You have to find the solution to the Tower of Hanoi problem.
        You have to return a 2D array of dimensions M x 3, where M is the minimum number of moves needed to solve the problem.
        In each row, there should be 3 integers (disk, start, end), where:

        disk - number of the disk being moved
        start - number of the tower from which the disk is being moved
        end - number of the tower to which the disk is being moved

        Note :
            

        Problem Constraints
            1 <= A <= 18

        Input Format
            The first argument is the integer A.

        Output Format
            Return a 2D array with dimensions M x 3 as mentioned above in the description.

        Input 1:
            A = 2

        Output 1:
            [1 1 2 ] [2 1 3 ] [1 2 3 ]

        Input 2:
            A = 3

        Output 2:
            [1 1 3 ] [2 1 2 ] [1 3 2 ] [3 1 3 ] [1 2 1 ] [2 2 3 ] [1 1 3 ]

        */

        // CODE
        void toh(int n, int start, int end, int aux, std::vector<std::vector<int>>& result) {
                // Base case: If only one disk, move it from start to end
                if (n == 1) {
                    result.push_back({n, start, end});
                    return;
                }
                
                // Recursive case:
                // Move n-1 disks from start to aux using end as auxiliary
                toh(n-1, start, aux, end, result);
                
                // Move nth disk from start to end
                result.push_back({n, start, end});
                
                // Move n-1 disks from aux to end using start as auxiliary
                toh(n-1, aux, end, start, result);
            }

        vector<vector<int> > Solution::towerOfHanoi(int A) {
            std::vector<std::vector<int>> result;
            toh(A, 1, 3, 2, result); // Initialize the recursive process
            return result;
        }
    // Q1. Kth Symbol - Easy
        /*
        Q.1 -> On the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.
        Given row number A and index B, return the Bth indexed symbol in row A. (The values of B are 0-indexed.).

        Note :


        Problem Constraints
            1 <= A <= 20
            0 <= B < 2A - 1

        Input Format
            First argument is an integer A.
            Second argument is an integer B.    

        Output Format
            Return an integer denoting the Bth indexed symbol in row A.

        Input 1:
            A = 3
            B = 0

        Output 1:
            0

        Input 2:
            A = 4
            B = 4

        Output 2:
            1

        Example Explanation
        Explanation 1:

        Row 1: 0
        Row 2: 01
        Row 3: 0110
        */


        // CODE

        int KThSymbol(int N, int K) {
            // Base case: Row 0 only has the symbol 0
            if (N == 1) {
                return 0;
            }
            
            // Recursive step: get the symbol in the previous row
            int parent = KThSymbol(N - 1, K / 2); // K/2 corresponds to the index in the previous row.
            
            
            // Check if K is odd or even
            bool isKOdd = (K % 2 == 1);
            
            // If parent symbol is 1:
            if (parent == 1) {
                if (isKOdd) {
                    return 0; // Odd index in a '1' row becomes 1
                } else {
                    return 1; // Even index in a '1' row becomes 0
                }
            } else {
                // If parent symbol is 0:
                if (isKOdd) {
                    return 1; // Odd index in a '0' row becomes 0
                } else {
                    return 0; // Even index in a '0' row becomes 1
                }
            }
        }

        int Solution::solve(int A, int B) {
            return KThSymbol(A, B);
        }


    // Q2. Is magic?
        /*
        Q.2 -> Given a number A, check if it is a magic number or not.
        A number is said to be a magic number if the sum of its digits is calculated till a single digit recursively by adding the sum of the digits after every addition. If the single digit comes out to be 1, then the number is a magic number.

        Note :
            

        Problem Constraints
            1 <= A <= 10^9

        Input Format
            The first and only argument is an integer A.

        Output Format
            Return an 1 if the given number is magic else return 0.

        Input 1:
            A = 83557

        Output 1:
            1

        Input 2:
            A = 1291

        Output 2:
            0

        */

        // CODE
        int sumOfDigits(int n) {
            int sum = 0;
            while (n > 0) {
                sum += n % 10;
                n /= 10;
            }
            return sum;
        }

        bool isMagicNumber(int A) {
            // Reduce the number to a single digit
            while (A >= 10) {
                A = sumOfDigits(A);
            }
            // Check if the single digit is 1
            return A == 1;
        }

        int Solution::solve(int A) {

            if (isMagicNumber(A)) {
                return 1;
            } else {
                return 0;
            }

            
        }
    // Q3. First Index using Recursion
        /*
        Q.3 -> You are given an array A of size N. Write a recursive function that returns the first index at which an integer B is found in the array.

        NOTE: If B is not found anywhere in the array then return -1.
            

        Problem Constraints
            1 <= N <= 100
            -1000 <= A[i] <= 1000
            -1000 <= B <= 1000

        Input Format
            The function contains two arguments.
            The first argument is the array A.
            The second argument is the element B that is to be searched.
        
        Output Format
            Return the Index of B from the list in integer format if B is present in the array, else return -1.

        Input 1:
            A = [-3, 5, 6, 2]  
            B = 6

        Output 1:
            2

        Input 2:
            A = [0, 1, 0, 2]  
            B = 3

        Output 2:
            -1

        */

        // CODE
        int findFirstIndex(vector<int> &A, int B, int index) {
            // Base case: if index reaches the size of the array, B is not found
            if (index == A.size()) {
                return -1;
            }
            // Check if the current element is B
            if (A[index] == B) {
                return index;
            }
            // Recursive call to check the next element
            return findFirstIndex(A, B, index + 1);
        }

        int Solution::FirstIndex(vector<int> &A, int B) {
            return findFirstIndex(A, B, 0);    
        }
    // Q4. Last Index using Recursion
        /*
        Q.4 ->You are given an array A of size N. Write a recursive function that returns the last index at which an integer B is found in the array.

        Note : If B is not found anywhere in the array then return -1.

        Problem Constraints
            1 <= N <= 100
            -1000 <= A[i] <= 1000
            -1000 <= B <= 1000

        Input Format
            The function contains two arguments.
            The first argument is the array A.
            The second argument is the element B that is to be searched.

        Output Format
            Return the last Index of B from the list in integer format if B is present in the array, else return -1.

        Input 1:
            A = [6, 5, 6, 2]  
            B = 6

        Output 1:
            2

        Input 2:
            A = [0, 1, 0, 2]  
            B = 3

        Output 2:
            -1

        */

        // CODE
        int findLastIndex(vector<int> &A, int B, int index) {
            // Base case: if index is less than 0, B is not found
            if (index < 0) {
                return -1;
            }
            // Check if the current element is B
            if (A[index] == B) {
                return index;
            }
            // Recursive call to check the previous element
            return findLastIndex(A, B, index - 1);
        }

        int Solution::LastIndex(vector<int> &A, int B) {
            return findLastIndex(A, B, A.size() - 1);
        }
    // Q5. Kth Symbol - Hard
        /*

        Q.5 -> 
        On the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.
        Given row number A and index B, return the Bth indexed symbol in row A. (The values of B are 0-indexed.).

        Note :
            

        Problem Constraints
            1 <= A <= 105
            0 <= B <= min(2A - 1 - 1 , 1018)

        Input Format
            First argument is an integer A.
            Second argument is an integer B.    

        Output Format
            Return an integer denoting the Bth indexed symbol in row A.

        Input 1:
            A = 3
            B = 0

        Output 1:
            0

        Input 2:
            A = 4
            B = 4

        Output 2:
            1

        */

        // CODE
        int Solution::solve(int A, long B) {
            // Base case: If we are at the first row and index is 0, the value is 0
            if (A == 1 && B == 0)
                return 0;

            // Recursive case: Calculate the value based on previous row
            int val = solve(A - 1, B / 2);
            
            // If B is even, return the value directly
            if (B % 2 == 0)
                return val;
            
            // If B is odd, return the complement of the value
            return 1 - val;
        }
## Backtracking 1 ##
    // Generating Subset in Lexographic Order
        void generateSubsets(vector<int>& nums, vector<int>& currentSubset, int index, vector<vector<int>>& allSubsets) {
            // Add the current subset to the result
            allSubsets.push_back(currentSubset);

            // Iterate through the array starting from the current index
            for (int i = index; i < nums.size(); i++) {
                currentSubset.push_back(nums[i]);      // Include the current element
                generateSubsets(nums, currentSubset, i + 1, allSubsets); // Recurse for the next elements
                currentSubset.pop_back();             // Backtrack to exclude the current element
            }
        }
        vector<vector<int>> subsetsInLexicographicalOrder(vector<int>& nums) {
            vector<vector<int>> allSubsets;
            vector<int> currentSubset;
            sort(nums.begin(), nums.end()); // Sort the input array to ensure lexicographical order
            generateSubsets(nums, currentSubset, 0, allSubsets);
            return allSubsets;
        }
    // Q1. Permutations
        /*
        Q.1 -> Given an integer array A of size N denoting collection of numbers , return all possible permutations.

        NOTE:
        No two entries in the permutation sequence should be the same.
        For the purpose of this problem, assume that all the numbers in the collection are unique.
        Return the answer in any order

        WARNING: 
        DO NOT USE LIBRARY FUNCTION FOR GENERATING PERMUTATIONS. 
        Example : next_permutations in C++ / itertools.permutations in python.
        If you do, we will disqualify your submission retroactively and give you penalty points.

        Problem Constraints
            1 <= N <= 9

        Input Format
            Only argument is an integer array A of size N.

        Output Format
            Return a 2-D array denoting all possible permutation of the array.

        Input 1:
            A = [1, 2, 3]

        Output 1:
        [ [1, 2, 3]
            [1, 3, 2]
            [2, 1, 3] 
            [2, 3, 1] 
            [3, 1, 2] 
            [3, 2, 1] ]

        */

        // CODE
        void generatePermutations(vector<int> &A, int index, vector<vector<int>> &result) {
            // Base case: when index reaches the size of the array, we have a valid permutation
            if (index == A.size()) {
                result.push_back(A);  // Add the current permutation to the result
                return;
            }

            // Iterate over the elements to swap and generate permutations
            for (int i = index; i < A.size(); i++) {
                swap(A[index], A[i]);  // Swap the current element with the index element
                generatePermutations(A, index + 1, result);  // Recursively call for the next index
                swap(A[index], A[i]);  // Backtrack to restore the original array
            }
        }

        vector<vector<int> > Solution::permute(vector<int> &A) {
            vector<vector<int>> result;  // To store all the permutations
            generatePermutations(A, 0, result);  // Call the recursive function
            return result;  // Return the result containing all permutations
        }

    // Q2. Generate all Parentheses II
        /*
        Q.2 -> Given an integer A pairs of parentheses, write a function to generate all combinations of well-formed parentheses of length 2*A.

        Note :
            

        Problem Constraints
            1 <= A <= 10

        Input Format
            First and only argument is integer A.

        Output Format
            Return a sorted list of all possible parenthesis.

        Input 1:
            A = 3

        Output 1:
            [ "((()))", "(()())", "(())()", "()(())", "()()()" ]

        Input 2:
            A = 1

        Output 2:
            [ "()" ]

        */

        // CODE
        void generateCombinations(int open, int close, string current, vector<string> &result) {
            // Base case: when no more parentheses can be added
            if (open == 0 && close == 0) {
                result.push_back(current);  // Add the valid combination to the result
                return;
            }

            // Add an opening parenthesis if there are any left
            if (open > 0) {
                generateCombinations(open - 1, close, current + "(", result);
            }

            // Add a closing parenthesis if it doesn't invalidate the sequence
            if (close > open) {
                generateCombinations(open, close - 1, current + ")", result);
            }
        }

        vector<string> Solution::generateParenthesis(int A) {
            vector<string> result;
            generateCombinations(A, A, "", result);  // Start with A open and A close parentheses available
            return result;
        }

    // Q3. Generate Subsets
        /*
        Q.3 -> Given a set of distinct integers A, return all possible subsets that can be formed from the elements of array A.

        Note :
            

        Problem Constraints
            1  |A|  16
            INT_MIN  A[i]  INT_MAX
            Array A is given in increasing order.
            All elements of array A are distinct.

        Input Format
            First and only argument of input contains a single integer array A.

        Output Format
            Return a vector of vectors denoting the answer in any order.

        Input 1:
            A = [1]

        Output 1:
        [
            []
            [1]
        ]

        Input 2:
            A = [1, 2, 3]

        Output 2:
        [
        []
        [1]
        [1, 2]
        [1, 2, 3]
        [1, 3]
        [2]
        [2, 3]
        [3]
        ]

        */

        // CODE
        class Solution {
        public:


            void generateSubsets(int index, vector<int> &A, vector<int> &currentSubset, vector<vector<int>> &result) {
                // Base case: if we've processed all elements
                if (index == A.size()) {
                    result.push_back(currentSubset);  // Add the current subset to the result
                    return;
                }

                // Case 1: Exclude the current element and move to the next
                generateSubsets(index + 1, A, currentSubset, result);

                // Case 2: Include the current element in the subset and move to the next
                currentSubset.push_back(A[index]);
                generateSubsets(index + 1, A, currentSubset, result);

                // Backtrack by removing the element (undo the decision)
                currentSubset.pop_back();
            }

            vector<vector<int>> subsets(vector<int> &A) {
                vector<vector<int>> result;
                vector<int> currentSubset;
                generateSubsets(0, A, currentSubset, result);  // Start the recursive process
                return result;
            }
        };

    // Q1. Letter Phone
        /*
        Q.1 -> Given a digit string A, return all possible letter combinations that the number could represent.
        A mapping of digit to letters (just like on the telephone buttons) is given below.
        The digit 0 maps to 0 itself. The digit 1 maps to 1 itself.

        NOTE: Make sure the returned strings are lexicographically sorted.

        Problem Constraints
            1 <= |A| <= 10

        Input Format
            The only argument is a digit string A.

        Output Format
            Return a string array denoting the possible letter combinations.

        Input 1:
            A = "23"

        Output 1:
            ["ad", "ae", "af", "bd", "be", "bf", "cd", "ce", "cf"]

        Input 2:
            A = "012"

        Output 2:
            ["01a", "01b", "01c"]

        */

        // CODE
        void backtrack(const string &digits, int index, string &current, vector<string> &result, const unordered_map<char, string> &digitMap) {
            // Base case: if the current combination is the same length as digits
            if (index == digits.size()) {
                result.push_back(current);
                return;
            }

            // Get the letters for the current digit
            char digit = digits[index];
            string &letters = digitMap.at(digit);

            // Explore each letter for the current digit
            for (char letter : letters) {
                current.push_back(letter); // Choose the letter
                backtrack(digits, index + 1, current, result, digitMap); // Recur for the next digit
                current.pop_back(); // Backtrack to explore other combinations
            }
        }

        vector<string> Solution::letterCombinations(string A) {
            if (A.empty()) return {}; // Return empty if input is empty

            // Mapping of digits to letters
            unordered_map<char, string> digitMap = {
                {'2', "abc"},
                {'3', "def"},
                {'4', "ghi"},
                {'5', "jkl"},
                {'6', "mno"},
                {'7', "pqrs"},
                {'8', "tuv"},
                {'9', "wxyz"},
                {'0', "0"},
                {'1', "1"}
            };

            vector<string> result;
            string current;
            backtrack(A, 0, current, result, digitMap);
            
            // The result is generated in lexicographical order due to the order in digitMap
            return result;
        }
    // Q2. Kth Symbol - Easy
        /*
        Q.2 -> On the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.
        Given row number A and index B, return the Bth indexed symbol in row A. (The values of B are 0-indexed.).

        Note :
            

        Problem Constraints
            1 <= A <= 20
            0 <= B < 2A - 1

        Input Format
            First argument is an integer A.
            Second argument is an integer B.

        Output Format
            Return an integer denoting the Bth indexed symbol in row A.

        Input 1:
            A = 3
            B = 0

        Output 1:
            0

        Input 2:
            A = 4
            B = 4

        Output 2:
            1

        */

        // CODE
        int Solution::solve(int A, int B) {
            // Base case: The first row only contains '0'
            if (A == 1) return 0;

            // Calculate the midpoint of the current row
            /*
                the length of the privious row is the midpoint of current row beacuse
                    - The first half of a row is identical to the previous row.
                    - The second half is the complement of the previous row.
                    - The length of Currnet row = 2^(A-1) 
                    - The length of Privious Row = 2^(A-2)
                    - Mid = 2^(A-2)
            */
            int mid = (1 << (A - 2)); // This is 2^(A-2)

            // If B is in the first half
            if (B < mid) {
                return solve(A - 1, B); // Same position in the previous row
            } else {
                return 1 - solve(A - 1, B - mid); // Complement of the position in the previous row
            }
        }

## Backtracking 2 ##
    // Q1. Subset Sum equal to K
        /*
        Q.1 -> Given an integer array A of size N.
        You are also given an integer B, you need to find whether their exist a subset in A whose sum equal B.
        If there exist a subset then return 1 else return 0.

        Note : Sum of elements of an empty subset is 0.

        Problem Constraints
        1 <= N <= 17
        -10^9 <= A[i] <= 10^9
        -10^9 <= B <= 10^9

        

        Input Format
            First argument is an integer array A.
            Second argument is an integer B.  

        Output Format
            Return 1 if there exist a subset with sum B else return 0.

        Input 1:
            A = [3, 34, -3, 12, 5, 2]
            B = 9

        Output 1:
            1

        Input 2:
            A = [-8, 34, 4, 0, -5, -2]
            B = -20

        Output 2:
            0

        */

        // CODE
        int solve(vector<int> &A, int B, int n) {
            // Base case: if target sum B is reached
            if (B == 0) return 1;
            
            // Base case: if no elements are left or target sum is not reachable
            if (n == 0) return 0;

            // Check if including A[n-1] in the subset gives the sum equal to B
            if (solve(A, B - A[n-1], n-1)) return 1; // take

            // Check if excluding A[n-1] in the subset gives the sum equal to B
            if (solve(A, B, n-1)) return 1; // no take

            return 0;
        }

        int Solution::SubsetSum(vector<int> &A, int B) {
            int N = A.size();
            return solve(A, B, N);
        }
    // Q2. Print paths in Staircase
        /*
        Q.2 -> You are climbing a staircase and it takes A steps to reach the top.
        Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
        You need to return all the distinct ways to climb to the top in lexicographical order.

        Note :

        Problem Constraints
            2 <= A <= 25

        Input Format
            The first and the only argument contains an integer A, the number of steps.    

        Output Format
            Return an 2-D Integer Array, which denotes all the unique valid paths to reach the top.

        Input 1:
            A = 2

        Output 1:
            [ [1, 1], [2] ]

        Input 2:
            A = 3

        Output 2:
            [ [1, 1, 1], [1, 2], [2, 1] ]

        */

        // CODE
       void findPaths(int n, int currentStep, vector<int>& path, vector<vector<int>>& result) {
            // Base case: If we have reached the top of the staircase
            if (currentStep == n) {
                // Add the current path to the result
                result.push_back(path);
                return;
            }
            
            // Recursive case: Try 1-step move if within range
            if (currentStep + 1 <= n) {
                path.push_back(1);
                printPaths(n, currentStep + 1, path, result);
                path.pop_back(); // Backtrack
            }
            
            // Try 2-step move if within range
            if (currentStep + 2 <= n) {
                path.push_back(2);
                printPaths(n, currentStep + 2, path, result);
                path.pop_back(); // Backtrack
            }
        }

        vector<vector<int> > Solution::WaysToClimb(int A) {
            vector<vector<int>> result;  // To store all valid paths
            vector<int> path;  // To store the current path being explored
            findPaths(A.size(), 0, path, result);  // Start the backtracking from step 0
            return result;
        }
    // Q3. Print All Maze Paths
        /*
        Q.3 ->
        You are given the dimensions of a rectangular board of size A x B. You need to print all the possible paths from top-left corner to bottom-right corner of the board.
        You can only move down (denoted by 'D') or right (denoted by 'R') at any point in time.
        NOTE : You need to return all the paths in Lexicographically sorted order. A lexicographic order is an arrangement of characters in alphabetical order. 

        Note :
            

        Problem Constraints
            1 <= A, B <= 8

        Input Format
            First Argument is an Integer A, which denotes the Row Index.
            Second Argument is an Integer B, which denotes the Column Index.

        Output Format
            Return a String Array, which denotes all the possible paths in separate lines. The paths should be returned in the Lexicographical order.

        Input 1:
            A = 3 , B = 2

        Output 1:
            DDR DRD RDD

        Input 2:
            A = 1 , B = 2

        Output 2:
            R

        */

        // CODE
        void find_all_path(int r, int c, int n, int m, string current_path, vector<string> &paths) {
            // Base Case: If we are out of bounds, return (we can't move beyond the maze)
            if (r >= n || c >= m) {
                return;
            }

            // If we reach the destination (bottom-right corner), add the current path to the result
            if (r == n - 1 && c == m - 1) {
                paths.push_back(current_path);
                return;
            }

            // Move Down (r+1, c) if within bounds
            find_all_path(r + 1, c, n, m, current_path + "D", paths);

            // Move Right (r, c+1) if within bounds
            find_all_path(r, c + 1, n, m, current_path + "R", paths);
        }

        vector<string> Solution::PrintAllPaths(int A, int B) {
            vector<string> result;  // To store all possible paths
            string path = "";       // To store the current path
            find_all_path(0, 0, A, B, path, result);  // Start backtracking from the top-left corner
            return result;
        }
    // Q1. Kth Symbol - Hard
        /*
        Q.1 -> On the first row, we write a 0. Now in every subsequent row, we look at the previous row and replace each occurrence of 0 with 01, and each occurrence of 1 with 10.
        Given row number A and index B, return the Bth indexed symbol in row A. (The values of B are 0-indexed.).

        Problem Constraints
            1 <= A <= 105
            0 <= B <= min(2A - 1 - 1 , 1018)

        Input Format
            First argument is an integer A.
            Second argument is an integer B    

        Output Format
            Return an integer denoting the Bth indexed symbol in row A.

        Input 1:
            A = 3
            B = 0

        Output 1:
            0

        Input 2:
            A = 4
            B = 4

        Output 2:
            1

        */

        // CODE
        int solution(int A, long B) {
            if (A == 0 || B == 0) {
                return 0;
            }

            int bit = solution(A - 1, B / 2);
            if (bit == 0) {
                return (B % 2 == 0) ? 0 : 1;
            } else {
                return (B % 2 == 0) ? 1 : 0;
            }
        }


        int Solution::solve(int A, long B) {
            return solution(A, B);
        }
    // Q2. Shortest path in a Binary Maze with Hurdles
        /*
        Q.2 -> 
        Given an MxN matrix where each element can either be 0 or 1. We need to find the length of shortest path between a given source cell to a destination cell.

        A cell with value 0 denotes that it's a hurdle. The path can only be created out of the cells with values 1.
        If NO path exists then print -1.

        The matrix A is given as input of size M x N.
        The coordinates of Source cell are given by B, C.
        The coordinates of Destination cell are given by D, E.


        Problem Constraints
            1 <= N , M <= 8
            0 <= A[i][j] <= 1
            0 <= B, C < N
            0 <= D, E < M
            A[B][C] == A[D][E] == 1

        Input Format
            First Argument is a 2-D Integer Array denotes the matrix A, of size MxN.
            Second Argument is an Integer B, denoting the Source Row Index
            Third Argument is an Integer C, denoting the Source Column Index
            Fourth Argument is an Integer D, denoting the Destination Row Index
            Fifth Argument is an Integer E, denoting the Destination Column Index

        Output Format
            Output a single integer denoting the length of the minimum distance from Source to destination

        Input 1:
            A = [[1, 1, 0, 0],
            [0, 1, 1, 0],
            [0, 0, 1, 1],
            [0, 0, 0, 1]]
            B = 0, C = 0
            D = 3, E = 3

        Output 1:
        6

        Input 2:
        A = [[1, 1, 1],
            [1, 0, 1],
            [1, 1, 1]]
        B = 0, C = 0
        D = 0, E = 2

        Output 2:
        2

        Input 3:
        A = [[1, 0, 1],
            [1, 0, 1],
            [1, 0, 1]]
        B = 0, C = 0
        D = 0, E = 2

        Output 3:
        -1

        */

        // CODE
        int min_dist = INT_MAX;

        void find_min_path(vector<vector<int>>& A, int r, int c, int dr, int dc, int dist, vector<vector<bool>>& visited, vector<vector<int>>& delta_move) {
            int n = A.size();
            int m = A[0].size();

            // Base case: if we reach the destination
            if (r == dr && c == dc) {
                min_dist = min(min_dist, dist);
                return;
            }

            // Explore all four directions (down, up, right, left)
            for (int i = 0; i < 4; i++) {
                int new_r = r + delta_move[i][0];
                int new_c = c + delta_move[i][1];

                // Check if the new cell is valid (within bounds, not visited, not a hurdle)
                if (new_r >= 0 && new_r < n && new_c >= 0 && new_c < m && !visited[new_r][new_c] && A[new_r][new_c] != 0) {
                    visited[new_r][new_c] = true;
                    find_min_path(A, new_r, new_c, dr, dc, dist + 1, visited, delta_move);  // Move to the next cell
                    visited[new_r][new_c] = false;  // Backtrack
                }
            }
        }

        int FindShortestPath(vector<vector<int>>& A, int B, int C, int D, int E) {
            int n = A.size();
            int m = A[0].size();

            // Directions: down, up, right, left
            vector<vector<int>> delta_move = {{1, 0}, {-1, 0}, {0, 1}, {0, -1}};

            // Initialize visited matrix
            vector<vector<bool>> visited(n, vector<bool>(m, false));

            // Start from the source cell
            visited[B][C] = true;

            // Start the recursive backtracking search for the shortest path
            find_min_path(A, B, C, D, E, 0, visited, delta_move);

            // If min_dist is still INT_MAX, there is no path, otherwise return the minimum distance found
            return (min_dist == INT_MAX) ? -1 : min_dist;
        }

## Rcursion & Backtracking Extra ##
    // Problems on Recursion
        // Print Name N times Using Recursion
            void f(int i, int n) {
                if (i > n) {
                    return;
                }
                std::cout << "name" << std::endl;
                f(i + 1, n);
            }
        // Print Linearly 1 -> n using recursion
            void f(int i, int n) {
                if (i > n) {
                    return;
                }
                std::cout << i << std::endl;
                f(i + 1, n);
            }
        // Print N to 1 using recursion
            void f(int i, int n) {
                if (i < 1) {
                    return;
                }
                std::cout << i << std::endl;
                f(i - 1, n);
            }
        // Print 1 to N using backtrack
            void f(int i, int n) {
                if (i < 1) {
                    return;
                }
                f(i - 1, n);
                std::cout << i << std::endl;
            }
        // Print N to 1 using backtrack
            void f(int i, int n) {
                if (i > n) {
                    return;
                }
                f(i + 1, n);
                std::cout << i << std::endl;
            }
    // Parameterized and Functional Recursion
        parameterized recursion
            void sumOfN_Parameterized(int i, int sum) {
                if (i < 1) {
                    std::cout << "Sum: " << sum << std::endl;
                    return;
                }
                sumOfN_Parameterized(i - 1, sum + i);
            }

            void factorial_Parameterized(int i, int product) {
                if (i < 1) {
                    std::cout << "Factorial: " << product << std::endl;
                    return;
                }
                factorial_Parameterized(i - 1, product * i);
            }
        Functional recursion
            int sumOfN_Functional(int n) {
                if (n == 0) {
                    return 0;
                }
                return n + sumOfN_Functional(n - 1);
            }

            int factorial_Functional(int n) {
                if (n == 1) {
                    return 1;
                }
                return n * factorial_Functional(n - 1);
            }
    // Problems on Functional Recursion
        // Function to reverse the array using recursion
        void reverseArray(std::vector<int> &arr, int start, int end) {
            // Base case: If the start index is greater than or equal to the end index
            if (start >= end) {
                return;
            }

            // Swap the elements at the start and end indexes
            std::swap(arr[start], arr[end]);

            // Recursive call for the next elements
            reverseArray(arr, start + 1, end - 1);
        }
        // Check the string is a palindrome or not
        bool isPalindrome(int i, const std::string &s) {
            // Base case: If index 'i' has reached or passed the middle of the string
            if (i >= s.size() / 2) {
                return true;
            }

            // Check if characters at index 'i' and 's.size() - i - 1' are different
            if (s[i] != s[s.size() - i - 1]) {
                return false;
            }

            // Recursive call to check the next characters
            return isPalindrome(i + 1, s);
        }
    // Multiple Recursion Calls
        - N th Fibonacci Number
            int fibonacci(int n) {
                // Base cases
                if (n <= 1) {
                    return n;
                }
                // Recursive call
                return fibonacci(n - 1) + fibonacci(n - 2);
            }

    // Recursion on Subsequences
        void generateAllSubsequences(int index, std::vector<int>& arr, std::vector<int>& current, std::vector<std::vector<int>>& result) {
            // Base case: if index reaches the end of the array
            if (index == arr.size()) {
                result.push_back(current);
                return;
            }

            // Include the current element and move to the next index
            current.push_back(arr[index]);
            generateAllSubsequences(index + 1, arr, current, result);

            // Backtrack: remove the last added element to explore the next possibility
            current.pop_back();

            // Exclude the current element and move to the next index
            generateAllSubsequences(index + 1, arr, current, result);
        }

        std::vector<std::vector<int>> getAllSubsequences(std::vector<int>& arr) {
            std::vector<std::vector<int>> result;
            std::vector<int> current;
            generateAllSubsequences(0, arr, current, result);
            return result;
        }
    // All Kind of Patterns in Recursion
        // Print all subsequence whose sum is K
            void findSubsequencesWithSumK(int index, std::vector<int>& current, int currentSum, std::vector<int>& arr, int targetSum, std::vector<std::vector<int>>& result) {
                // Base case: if index reaches the end of the array
                if (index == arr.size()) {
                    // Check if the current sum equals the target sum
                    if (currentSum == targetSum) {
                        result.push_back(current);
                    }
                    return;
                }

                // Include the current element and update the sum
                current.push_back(arr[index]);
                findSubsequencesWithSumK(index + 1, current, currentSum + arr[index], arr, targetSum, result);

                // Backtrack: remove the last added element to explore the next possibility
                current.pop_back();

                // Exclude the current element and move to the next index
                findSubsequencesWithSumK(index + 1, current, currentSum, arr, targetSum, result);
            }
        // Print any one subsequence whose sum is K
            bool findAnyOneSubsequenceWithSumK(int index, std::vector<int>& arr, std::vector<int>& current, int currentSum, int targetSum) {
                if (index >= arr.size()) {
                    if (currentSum == targetSum) {
                        // Print the subsequence
                        std::cout << "{ ";
                        for (int val : current) {
                            std::cout << val << " ";
                        }
                        std::cout << "}\n";
                        return true;
                    }
                    return false;
                }

                // Include the current element
                current.push_back(arr[index]);
                currentSum += arr[index];
                if (findAnyOneSubsequenceWithSumK(index + 1, arr, current, currentSum, targetSum)) {
                    return true; // Return immediately if found
                }

                // Backtrack: remove the last element and subtract from the sum
                current.pop_back();
                currentSum -= arr[index];

                // Exclude the current element
                if (findAnyOneSubsequenceWithSumK(index + 1, arr, current, currentSum, targetSum)) {
                    return true;
                }

                return false;
            }
        // Count all Subsequence whose sum = K
            int countSubsequencesWithSumK(int index, int currentSum, std::vector<int>& arr, int targetSum) {
                if (index >= arr.size()) {
                    return currentSum == targetSum ? 1 : 0;
                }

                // Include the current element
                currentSum += arr[index];
                int countLeft = countSubsequencesWithSumK(index + 1, currentSum, arr, targetSum);
                // Backtrack: remove the contribution of the current element
                currentSum -= arr[index];
                // Exclude the current element
                int countRight = countSubsequencesWithSumK(index + 1, currentSum, arr, targetSum);

                return countLeft + countRight;
            }
    // Mergesort
        void merge(vector<int>& arr, int l, int mid, int r) {
            int leftSize = mid - l + 1;  // Size of left subarray
            int rightSize = r - mid;     // Size of right subarray

            vector<int> leftArray(leftSize);  // Temporary left subarray
            vector<int> rightArray(rightSize);  // Temporary right subarray

            // Copy data into temporary arrays
            for (int i = 0; i < leftSize; i++) {
                leftArray[i] = arr[l + i];
            }
            for (int j = 0; j < rightSize; j++) {
                rightArray[j] = arr[mid + 1 + j];
            }

            // Merge the two subarrays back into the original array
            int i = 0, j = 0, k = l;
            while (i < leftSize && j < rightSize) {
                if (leftArray[i] <= rightArray[j]) {
                    arr[k] = leftArray[i];
                    i++;
                } else {
                    arr[k] = rightArray[j];
                    j++;
                }
                k++;
            }

            // Copy remaining elements of leftArray, if any
            while (i < leftSize) {
                arr[k] = leftArray[i];
                i++;
                k++;
            }

            // Copy remaining elements of rightArray, if any
            while (j < rightSize) {
                arr[k] = rightArray[j];
                j++;
                k++;
            }
        }

        // Merge Sort function to sort an array
        void mergeSort(vector<int>& arr, int l, int r) {
            if (l < r) {
                int mid = l + (r - l) / 2;  // Find the middle point

                // Recursively divide the array into two halves
                mergeSort(arr, l, mid);  // Sort the first half
                mergeSort(arr, mid + 1, r);  // Sort the second half

                // Merge the sorted halves
                merge(arr, l, mid, r);
            }
        }
        
    // Quick Sort
        int partition(vector<int>& arr, int low, int high) {
            int pivot = arr[high];  // Taking the last element as pivot
            int i = low - 1;  // Index of smaller element
            
            // Rearranging elements such that elements smaller than pivot are on the left
            // and elements greater than pivot are on the right
            for (int j = low; j < high; j++) {
                if (arr[j] <= pivot) {
                    i++;  // Increment index of smaller element
                    swap(arr[i], arr[j]);  // Swap if element is smaller than or equal to pivot
                }
            }

            // Swap the pivot element with the element at index i + 1
            swap(arr[i + 1], arr[high]);
            
            return i + 1;  // Return the partition index
        }

        // Quick Sort function
        void quickSort(vector<int>& arr, int low, int high) {
            if (low < high) {
                // Get the partition index such that all elements to the left are smaller than pivot
                // and all elements to the right are larger than pivot
                int pi = partition(arr, low, high);

                // Recursively apply Quick Sort to the left and right subarrays
                quickSort(arr, low, pi - 1);  // Left subarray
                quickSort(arr, pi + 1, high);  // Right subarray
            }
        }
    // Combination Sum I
        void findCombinations(int i, vector<int>& arr, int target, vector<vector<int>>& ans, vector<int>& ds) {
            int n = arr.size(); // Size of the input array

            // Base case: If target becomes 0, add the current combination
            if (target == 0) {
                ans.push_back(ds);
                return;
            }

            // If index reaches the end of the array
            if (i == n) {
                return;
            }

            // If the current element can be included (it does not exceed the target)
            if (arr[i] <= target) {
                ds.push_back(arr[i]); // Choose the current element
                findCombinations(i, arr, target - arr[i], ans, ds); // Stay at the same index (allow repeated use)
                ds.pop_back(); // Backtrack (remove the element)
            }

            // Move to the next element
            findCombinations(i + 1, arr, target, ans, ds);
        }
    // Combination Sum II
        void findCombinations(int index, int target, vector<int>& arr, vector<vector<int>>& ans, vector<int>& ds) {
            // Base case: if the target becomes 0, add the current combination
            if (target == 0) {
                ans.push_back(ds);
                return;
            }

            for (int i = index; i < arr.size(); i++) {
                // Skip duplicates
                if (i > index && arr[i] == arr[i - 1]) {
                    continue;
                }

                // Break if the current element exceeds the target
                if (arr[i] > target) {
                    break;
                }

                // Include the current element in the combination
                ds.push_back(arr[i]);
                // Recur with reduced target and next index (i + 1)
                findCombinations(i + 1, target - arr[i], arr, ans, ds);
                // Backtrack: remove the last added element
                ds.pop_back();
            }
        }
    // Subset Sum I 
        void subsetSums(int index, int currentSum, vector<int>& arr, vector<int>& result) {
            // Base case: if we have traversed the entire array, add the current sum to the result
            if (index == arr.size()) {
                result.push_back(currentSum);
                return;
            }

            // Include the current element in the subset sum
            subsetSums(index + 1, currentSum + arr[index], arr, result);

            // Exclude the current element from the subset sum
            subsetSums(index + 1, currentSum, arr, result);
        } 

        
    // Subset Sum II  
        void backtrack(int start, vector<int>& nums, vector<int>& path, vector<vector<int>>& result) {
            result.push_back(path);  // Add the current subset to the result
            for (int i = start; i < nums.size(); ++i) {
                // Skip duplicates
                if (i > start && nums[i] == nums[i - 1]) {
                    continue;
                }
                // Include nums[i] in the subset
                path.push_back(nums[i]);
                // Recurse to the next element
                backtrack(i + 1, nums, path, result);
                // Backtrack by removing the last added element
                path.pop_back();
            }
        }
    // Print all Permutations of String/array I
        void generatePermutations(vector<int>& nums, vector<int>& current, vector<bool>& used, vector<vector<int>>& result) {
            if (current.size() == nums.size()) {
                result.push_back(current); // Add a complete permutation to the result
                return;
            }
            
            for (int i = 0; i < nums.size(); ++i) {
                // Skip this element if it's already used
                if (used[i]) continue;

                // Skip duplicates: ensure this is the first occurrence of the current number
                if (i > 0 && nums[i] == nums[i - 1] && !used[i - 1]) continue;

                // Mark this element as used
                used[i] = true;
                current.push_back(nums[i]);

                // Recurse with the current element included
                generatePermutations(nums, current, used, result);

                // Backtrack: unmark the element and remove from the current permutation
                used[i] = false;
                current.pop_back();
            }
        }      
    // Print all Permutations of String/array II
        void generatePermutations(vector<int>& nums, int start, vector<vector<int>>& result) {
            if (start == nums.size()) {
                result.push_back(nums); // Add the current permutation to the result
                return;
            }

            for (int i = start; i < nums.size(); ++i) {
                // Swap the current element with the element at index 'start'
                swap(nums[start], nums[i]);
                // Recurse with the next index
                generatePermutations(nums, start + 1, result);
                // Backtrack by swapping the elements back
                swap(nums[start], nums[i]);
            }
        }
    // N-Queens
        bool isSafe(int row, int col, vector<string>& board, int n) {
            
            // Check upper diagonal on the left side
            i = row - 1;
            int j = col - 1;
            while (i >= 0 && j >= 0) {
                if (board[i][j] == 'Q') return false;
                --i;
                --j;
            } 

            // Check this row on the left side
            int i = col - 1;
            while (i >= 0) {
                if (board[row][i] == 'Q') return false;
                --i;
            }

            // Check lower diagonal on the left side
            i = row + 1;
            j = col - 1;
            while (i < n && j >= 0) {
                if (board[i][j] == 'Q') return false;
                ++i;
                --j;
            }

            return true;
        }
        void solveNQueens(int col, vector<string>& board, vector<vector<string>>& result, int n) {
            if (col == n) {
                result.push_back(board);
                return;
            }

            for (int row = 0; row < n; ++row) {
                if (isSafe(row, col, board, n)) {
                    // Place the queen
                    board[row][col] = 'Q';

                    // Recurse to place the rest of the queens
                    solveNQueens(col + 1, board, result, n);

                    // Backtrack and remove the queen
                    board[row][col] = '.';
                }
            }
        }

        // Aprroach 2 (without isSafe - use the 3maps)
        void solveNQueens(int col, vector<string>& board, vector<vector<string>>& result, vector<bool>& columns, vector<bool>& majorDiagonal, vector<bool>& minorDiagonal, int n) {
            if (col == n) {
                result.push_back(board);
                return;
            }

            for (int row = 0; row < n; ++row) {
                // Calculate the indices for major and minor diagonals
                int majorIdx = row - col + n - 1; // Adjusted to keep it non-negative
                int minorIdx = row + col;

                // Check if this cell is under attack
                if (!columns[row] && !majorDiagonal[majorIdx] && !minorDiagonal[minorIdx]) {
                    // Place the queen
                    board[row][col] = 'Q';
                    columns[row] = majorDiagonal[majorIdx] = minorDiagonal[minorIdx] = true;

                    // Recurse to place the rest of the queens
                    solveNQueens(col + 1, board, result, columns, majorDiagonal, minorDiagonal, n);

                    // Backtrack: remove the queen
                    board[row][col] = '.';
                    columns[row] = majorDiagonal[majorIdx] = minorDiagonal[minorIdx] = false;
                }
            }
        }
    // Sudoko Solver
        // Function to check if a number can be placed in a given cell
        bool isValid(vector<vector<int>>& board, int row, int col, int num) {
            // Check if the number is not in the current row
            for (int i = 0; i < 9; i++) {
                if (board[row][i] == num) {
                    return false;
                }
            }
            
            // Check if the number is not in the current column
            for (int i = 0; i < 9; i++) {
                if (board[i][col] == num) {
                    return false;
                }
            }

            // Check if the number is not in the 3x3 subgrid
            int startRow = row - row % 3, startCol = col - col % 3;
            for (int i = 0; i < 3; i++) {
                for (int j = 0; j < 3; j++) {
                    if (board[startRow + i][startCol + j] == num) {
                        return false;
                    }
                }
            }

            return true;
        }
        // Function to solve the Sudoku board using backtracking
        bool solveSudoku(vector<vector<int>>& board) {
            for (int row = 0; row < 9; row++) {
                for (int col = 0; col < 9; col++) {
                    if (board[row][col] == 0) {  // Find an empty cell
                        for (int num = 1; num <= 9; num++) {  // Try numbers 1-9
                            if (isValid(board, row, col, num)) {
                                board[row][col] = num;  // Place the number
                                
                                if (solveSudoku(board)) {  // Recur
                                    return true;
                                }
                                
                                board[row][col] = 0;  // Backtrack
                            }
                        }
                        return false;  // Trigger backtracking
                    }
                }
            }
            return true;  // Puzzle solved
        }
    // M-Coloring Problem
        // Function to check if the current color assignment is safe
        bool isSafe(int node, vector<int>& color, vector<vector<int>>& graph, int n, int col) {
            for (int k = 0; k < n; k++) {
                if (k != node && graph[node][k] == 1 && color[k] == col) {
                    return false;  // Adjacent node has the same color
                }
            }
            return true;
        }

        // Function to solve the M-Coloring Problem using backtracking
        bool solve(int node, vector<int>& color, int m, int n, vector<vector<int>>& graph) {
            if (node == n) {  // All nodes have been colored
                return true;
            }

            for (int i = 1; i <= m; i++) {  // Try assigning colors from 1 to M
                if (isSafe(node, color, graph, n, i)) {
                    color[node] = i;  // Assign color i to node

                    // Recursively color the next node
                    if (solve(node + 1, color, m, n, graph)) {
                        return true;
                    }

                    // Backtrack
                    color[node] = 0;
                }
            }

            return false;  // No valid color assignment found
        }
        
    // Palindrome Partitioning
        bool isPalindrome(string& s, int start, int end) {
            while (start < end) {
                if (s[start] != s[end]) {
                    return false;
                }
                start++;
                end--;
            }
            return true;
        }
        // Recursive function to find all palindrome partitionings
        void findPartitions(int start, string& s, vector<string>& currentPartition, vector<vector<string>>& result) {
            if (start >= s.size()) {
                result.push_back(currentPartition);  // Found a valid partitioning
                return;
            }

            for (int end = start; end < s.size(); end++) {
                // Check if the substring s[start:end] is a palindrome
                if (isPalindrome(s, start, end)) {
                    // Add the substring to the current partition
                    currentPartition.push_back(s.substr(start, end - start + 1));

                    // Recur for the remaining string
                    findPartitions(end + 1, s, currentPartition, result);

                    // Backtrack and remove the last added substring
                    currentPartition.pop_back();
                }
            }
        }
    // Rate in Maze
        void solve(int r, int c, vector<vector<int>>& arr, int n, vector<string>& ans, string move, vector<vector<int>>& vis) {
            if (r == n - 1 && c == n - 1) {
                ans.push_back(move);
                return;
            }

            // Directions: Down, Left, Right, Up (DLRU)

            // Down
            if (r + 1 < n && !vis[r + 1][c] && arr[r + 1][c] == 1) {
                vis[r + 1][c] = 1;
                solve(r + 1, c, arr, n, ans, move + "D", vis);
                vis[r + 1][c] = 0; // Backtrack
            }
            // Left
            if (c - 1 >= 0 && !vis[r][c - 1] && arr[r][c - 1] == 1) {
                vis[r][c - 1] = 1;
                solve(r, c - 1, arr, n, ans, move + "L", vis);
                vis[r][c - 1] = 0; // Backtrack
            }
            // Right
            if (c + 1 < n && !vis[r][c + 1] && arr[r][c + 1] == 1) {
                vis[r][c + 1] = 1;
                solve(r, c + 1, arr, n, ans, move + "R", vis);
                vis[r][c + 1] = 0; // Backtrack
            }
            // Up
            if (r - 1 >= 0 && !vis[r - 1][c] && arr[r - 1][c] == 1) {
                vis[r - 1][c] = 1;
                solve(r - 1, c, arr, n, ans, move + "U", vis);
                vis[r - 1][c] = 0; // Backtrack
            }
        }
        
    // Kth Permutations
        string getKthPermutation(int n, int k) {
            int fact = 1;
            vector<int> nums;

            // Populate the nums vector and compute (n-1)!
            for (int i = 1; i < n; i++) {
                fact *= i;
                nums.push_back(i);
            }
            nums.push_back(n); // Add the last number

            string ans = "";
            k = k - 1; // Convert k to zero-based index

            while (true) {
                // Determine the index of the current number in nums
                int index = k / fact;
                ans += to_string(nums[index]);
                nums.erase(nums.begin() + index);

                if (nums.empty()) break; // All elements are used

                // Update k and fact
                k %= fact;
                fact /= nums.size();
            }

            return ans;
        }
    // Count Inversion in array
        int mergeAndCount(vector<int>& arr, int left, int mid, int right) {
            vector<int> leftArr(arr.begin() + left, arr.begin() + mid + 1);
            vector<int> rightArr(arr.begin() + mid + 1, arr.begin() + right + 1);

            int i = 0, j = 0, k = left;
            int inversions = 0;

            // Merge the two halves while counting inversions
            while (i < leftArr.size() && j < rightArr.size()) {
                if (leftArr[i] <= rightArr[j]) {
                    arr[k++] = leftArr[i++];
                } else {
                    arr[k++] = rightArr[j++];
                    // Count inversions: remaining elements in leftArr are all greater
                    inversions += leftArr.size() - i;
                }
            }

            // Copy any remaining elements
            while (i < leftArr.size()) {
                arr[k++] = leftArr[i++];
            }
            while (j < rightArr.size()) {
                arr[k++] = rightArr[j++];
            }

            return inversions;
        }
        // Recursive function to implement merge sort and count inversions
        int mergeSortAndCount(vector<int>& arr, int left, int right) {
            int inversions = 0;
            if (left < right) {
                int mid = left + (right - left) / 2;
                inversions += mergeSortAndCount(arr, left, mid);
                inversions += mergeSortAndCount(arr, mid + 1, right);
                inversions += mergeAndCount(arr, left, mid, right);
            }
            return inversions;
        }

    // Subsequence vs Subset vs Permutation vs Combination
        void findSubsequences(int idx, vector<int>& nums, vector<int>& temp, vector<vector<int>>& result) {
            if (idx == nums.size()) {
                result.push_back(temp); // Add current subsequence
                return;
            }
            // Include the current element
            temp.push_back(nums[idx]);
            findSubsequences(idx + 1, nums, temp, result);
            temp.pop_back();
            // Exclude the current element
            findSubsequences(idx + 1, nums, temp, result);
        }

        void findSubsets(int idx, vector<int>& nums, vector<int>& temp, vector<vector<int>>& result) {
            result.push_back(temp); // Add current subset
            for (int i = idx; i < nums.size(); ++i) {
                temp.push_back(nums[i]);
                findSubsets(i + 1, nums, temp, result);
                temp.pop_back();
            }
        }

        void findPermutations(int idx, vector<int>& nums, vector<vector<int>>& result) {
            if (idx == nums.size()) {
                result.push_back(nums); // Add current permutation
                return;
            }
            for (int i = idx; i < nums.size(); ++i) {
                swap(nums[idx], nums[i]);
                findPermutations(idx + 1, nums, result);
                swap(nums[idx], nums[i]); // Backtrack
            }
        }

        void findCombinations(int idx, int k, vector<int>& nums, vector<int>& temp, vector<vector<int>>& result) {
            if (temp.size() == k) {
                result.push_back(temp); // Add current combination
                return;
            }
            for (int i = idx; i < nums.size(); ++i) {
                temp.push_back(nums[i]);
                findCombinations(i + 1, k, nums, temp, result);
                temp.pop_back(); // Backtrack
            }
        }

// DP
## DP 1: One Dimensional ##
    // Q1. Stairs

        /*
        Q.1 -> You are climbing a staircase and it takes A steps to reach the top.
        Each time you can either climb 1 or 2 steps. In how many distinct ways can you climb to the top?
        Return the number of distinct ways modulo 1000000007

        Note :

        Problem Constraints
            1 <= A <= 10^5

        Input Format
            The first and the only argument contains an integer A, the number of steps.  

        Output Format
            Return an integer, representing the number of ways to reach the top.

        Input 1:
            A = 2

        Output 1:
            2

        Input 2:
            A = 3

        Output 2:
            3

        */

        // CODE
        const int mod = 1000000007;
        int ways(int N, vector<int> &dp){
            if(N<=1){
                return 1;
            }
            if(dp[N] != -1){
                return dp[N];
            }
            dp[N] = (ways(N-1, dp) % mod + ways(N-2, dp) % mod) % mod;
            return dp[N];
        }
        int Solution::climbStairs(int A) {
            vector<int> dp(A+1, -1);
            return ways(A, dp);
        }
    // Q2. Fibonacci Number
        /*
        Q.2 -> Given a positive integer A, write a program to find the Ath Fibonacci number.
        In a Fibonacci series, each term is the sum of the previous two terms and the first two terms of the series are 0 and 1. i.e. f(0) = 0 and f(1) = 1. Hence, f(2) = 1, f(3) = 2, f(4) = 3 and so on.

        NOTE: 0th term is 0. 1th term is 1 and so on.

        Problem Constraints
            0 <= A <= 44

        Input Format
            First and only argument is an integer A.  

        Output Format
            Return an integer denoting the Ath Fibonacci number.

        Input 1:
            A = 4

        Output 1:
            3

        Input 2:
            A = 6

        Output 2:
            8

        */

        // CODE
        int fibonacci_no(int N, vector<int> &F){
            if(N<=1){
                return N;
            }
            if (F[N] !=-1){
                return F[N];
            }
            F[N] = fibonacci_no(N-1, F) + fibonacci_no(N-2, F);
            return F[N];
        }
    // Q3. Minimum Number of Squares
        /*
        Q.3 -> Given an integer A. Return minimum count of numbers, sum of whose squares is equal to A.

        Note :

        Problem Constraints
        1 <= A <= 105

        Input Format
            First and only argument is an integer A

        Output Format
            Return an integer denoting the minimum count.

        Input 1:
            A = 6

        Output 1:
            3

        Input 2:
            A = 5

        Output 2:
            2

        */

        // CODE
        /*
        int Solution::countMinSquares(int A) {
            // Create a dp array to store the minimum number of squares for each number up to A
            vector<int> dp(A + 1, A); // Initialize with a large value (A is the maximum number of squares needed)
            
            // Base case
            dp[0] = 0; // 0 can be formed with 0 squares
            
            // Fill the dp array
            for (int i = 1; i <= A; ++i) {
                for (int j = 1; j * j <= i; ++j) {
                    dp[i] = min(dp[i], dp[i - j * j] + 1); // Use the square of j
                }
            }
            
            // Return the result for A
            return dp[A];
        }
        */
        int (icount_minnt A, vector<int>& dp){
            if (A == 0) return 0;
            if (A < 0) return INT_MAX; // Represents invalid state

            if(dp[A] != -1) return dp[A];
            int minCount = INT_MAX;

            // Try all perfect squares less than or equal to n
            for (int i = 1; i * i <= A; ++i) {
                int remaining = A - i * i;
                int result = count_min(remaining, dp);
                if (result != INT_MAX) {
                    minCount = min(minCount, 1 + result);
                }
            }

            return dp[A] = minCount;
        }

        int Solution::countMinSquares(int A) {
            vector<int> dp(A + 1, -1);
            return count_min(A, dp);
        }
    // Q1. Maximum Sum Value
        /*
        Q.1 -> You are given an array A of N integers and three integers B, C, and D.
        You have to find the maximum value of A[i]*B + A[j]*C + A[k]*D, where 1 <= i <= j <= k <= N.

        Note :

        Problem Constraints
            1 <= N <= 105
            -10000 <= A[i], B, C, D <= 10000

        Input Format
            First argument is an array A
            Second argument is an integer B
            Third argument is an integer C
            Fourth argument is an integer D

        Output Format
            Return an Integer S, i.e maximum value of (A[i] * B + A[j] * C + A[k] * D), where 1 <= i <= j <= k <= N.

        Input 1:
            A = [1, 5, -3, 4, -2]
            B = 2
            C = 1
            D = -1

        Output 1:
            18

        Input 2:
            A = [3, 2, 1]
            B = 1
            C = -10
            D = 3

        Output 2:
            -4

        */

        // CODE
        int Solution::solve(vector<int> &A, int B, int C, int D) {
            int N = A.size();
            
            // Step 1: Calculate `left` array
            vector<int> left(N);
            left[0] = A[0] * B;
            for (int i = 1; i < N; i++) {
                left[i] = max(left[i - 1], A[i] * B);
            }

            // Step 2: Calculate `mid` array
            vector<int> mid(N);
            mid[0] = left[0] + A[0] * C;
            for (int j = 1; j < N; j++) {
                mid[j] = max(mid[j - 1], left[j] + A[j] * C);
            }

            // Step 3: Calculate `right` array
            vector<int> right(N);
            right[0] = mid[0] + A[0] * D;
            for (int k = 1; k < N; k++) {
                right[k] = max(right[k - 1], mid[k] + A[k] * D);
            }

            // The answer is the maximum value in `right`
            return right[N - 1];
        }

        // Recursive function to calculate the maximum value
        int recursiveMax(int n, int step, const vector<int>& A, int B, int C, int D, vector<vector<int>>& memo) {
            // Base Case
            if (n == 0) return INT_MIN; // Invalid case, no elements left
            
            // If already computed, return the memoized result
            if (memo[n][step] != INT_MIN) return memo[n][step];

            // Compute based on the current step
            int currentMax = INT_MIN;

            if (step == 1) {
                // Maximize A[i] * B
                currentMax = A[n - 1] * B;
            } else if (step == 2) {
                // Maximize A[i] * B + A[j] * C where j >= i
                for (int j = n; j <= A.size(); ++j) {
                    currentMax = max(currentMax, recursiveMax(j, 1, A, B, C, D, memo) + A[j - 1] * C);
                }
            } else if (step == 3) {
                // Maximize A[i] * B + A[j] * C + A[k] * D where k >= j
                for (int k = n; k <= A.size(); ++k) {
                    currentMax = max(currentMax, recursiveMax(k, 2, A, B, C, D, memo) + A[k - 1] * D);
                }
            }

            // Memoize and return the result
            memo[n][step] = currentMax;
            return currentMax;
        }

        int maxSumValue(const vector<int>& A, int B, int C, int D) {
            int N = A.size();
            vector<vector<int>> memo(N + 1, vector<int>(4, INT_MIN));

            // Start recursion from step 3 (final step) and the first index
            return recursiveMax(1, 3, A, B, C, D, memo);
        }

    // Q2. Max Product Subarray
        /*
        Q.2 -> Given an integer array A of size N. Find the contiguous subarray within the given array (containing at least one number) which has the largest product.
        Return an integer corresponding to the maximum product possible.

        NOTE: Answer will fit in 32-bit integer value.

        Problem Constraints
            1 <= N <= 5 * 105
            -100 <= A[i] <= 100

        Input Format
            First and only argument is an integer array A.

        Output Format
            Return an integer corresponding to the maximum product possible.

        Input 1:
            A = [4, 2, -5, 1]

        Output 1:
            8

        Input 2:
            A = [-3, 0, -5, 0]

        Output 2:
            0

        */

        // CODE
        int Solution::maxProduct(const vector<int> &A) {
                if (A.empty()) return 0;

            int maxProduct = A[0];
            int minProduct = A[0];
            int result = A[0];

            for (int i = 1; i < A.size(); i++) {
                int current = A[i];

                // If current is negative, swap maxProduct and minProduct
                if (current < 0) {
                    swap(maxProduct, minProduct);
                }

                // Update maxProduct and minProduct
                maxProduct = max(current, maxProduct * current);
                minProduct = min(current, minProduct * current);

                // Update result with the maximum product found so far
                result = max(result, maxProduct);
            }

            return result;

        }

        int maxProductHelper(const vector<int> &A, int i, vector<int> &dpMax, vector<int> &dpMin) {
            if (i == 0) {
                dpMax[i] = A[i];
                dpMin[i] = A[i];
                return dpMax[i];
            }

            // If already computed
            if (dpMax[i] != INT_MIN) return dpMax[i];

            // Recursive calls for maxProduct and minProduct
            maxProductHelper(A, i - 1, dpMax, dpMin);

            int current = A[i];

            // Compute max and min product ending at index i
            dpMax[i] = max({current, current * dpMax[i - 1], current * dpMin[i - 1]});
            dpMin[i] = min({current, current * dpMax[i - 1], current * dpMin[i - 1]});

            return dpMax[i];
        }


## DP 2: Two Dimensional ##
    // Fins Nth Catalan No
        // Function to compute the first 'n' Catalan numbers
        vector<int> computeCatalanNumbers(int n) {
            // Create a DP array to store Catalan numbers
            vector<int> catalan(n + 1, 0);

            // Base cases
            catalan[0] = 1; // C_0 = 1
            catalan[1] = 1; // C_1 = 1

            // Compute Catalan numbers from C_2 to C_n
            for (int i = 2; i <= n; i++) {
                for (int j = 0; j < i; j++) {
                    catalan[i] += catalan[j] * catalan[i - j - 1];
                }
            }

            return catalan;
        }

        // Recursive function to compute the nth Catalan number
        int catalan(int n) {
            // Base cases
            if (n <= 1) return 1;

            int result = 0;

            // Calculate Catalan number using the recursive formula
            for (int i = 0; i < n; ++i) {
                result += catalan(i) * catalan(n - i - 1);
            }

            return result;
        }
    // Q1. Unique Paths in a Grid
        /*
        Q.1 -> Given a grid of size n * m, lets assume you are starting at (1,1) and your goal is to reach (n, m). 
        At any instance, if you are on (x, y), you can either go to (x, y + 1) or (x + 1, y).

        Now consider if some obstacles are added to the grids. 
        Return the total number unique paths from (1, 1) to (n, m).

        Note: 
        1. An obstacle is marked as 1 and empty space is marked 0 respectively in the grid.
        2. Given Source Point and Destination points are 1-based index.

        Problem Constraints
            1 <= n, m <= 100
            A[i][j] = 0 or 1

        Input Format
            Firts and only argument A is a 2D array of size n * m.

        Output Format
            Return an integer denoting the number of unique paths from (1, 1) to (n, m).

        Input 1:
        A = [
                [0, 0, 0]
                [0, 1, 0]
                [0, 0, 0]
            ]

        Output 1:
            2

        Input 2:
        A = [
                [0, 0, 0]
                [1, 1, 1]
                [0, 0, 0]
            ]

        Output 2:
            0

        */

        // CODE
        int Solution::uniquePathsWithObstacles(vector<vector<int> > &A) {
            int n = A.size();
            int m = A[0].size();
            
            // If starting or ending point is an obstacle
            if (A[0][0] == 1 || A[n - 1][m - 1] == 1) return 0;
            
            vector<vector<int>> dp(n, vector<int>(m, 0));
            
            // Initialize the starting point
            dp[0][0] = 1;
            
            // Fill in the first row
            for (int j = 1; j < m; ++j) {
                if (A[0][j] == 1) dp[0][j] = 0;
                else dp[0][j] = dp[0][j - 1];
            }
            
            // Fill in the first column
            for (int i = 1; i < n; ++i) {
                if (A[i][0] == 1) dp[i][0] = 0;
                else dp[i][0] = dp[i - 1][0];
            }
            
            // Fill in the rest of the dp table
            for (int i = 1; i < n; ++i) {
                for (int j = 1; j < m; ++j) {
                    if (A[i][j] == 1) dp[i][j] = 0;
                    else dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                }
            }
            
            // The answer is in the bottom-right corner
            return dp[n - 1][m - 1];
        }
    // Q2. Max Sum Without Adjacent Elements
        /*
        Q.2 -> Given a 2 x N grid of integers, A, your task is to choose numbers from the grid such that sum of these numbers is maximized. 
        However, you cannot choose two numbers that are adjacent horizontally, vertically, or diagonally. 
        Return the maximum possible sum.

        Note: You are allowed to choose more than 2 numbers from the grid.

        Problem Constraints
            1 <= N <= 20000
            1 <= A[i] <= 2000

        Input Format
            The first and the only argument of input contains a 2d matrix, A.

        Output Format
            Return an integer, representing the maximum possible sum.

        Input 1:
        A = [   
                [1]
                [2]    
            ]
        Output 1:
            2

        Input 2:
        A = [   
                [1, 2, 3, 4]
                [2, 3, 4, 5]    
            ]

        Output 2:
            8

        */

        // CODE
        int Solution::adjacent(vector<vector<int> > &A) {
            int N = A[0].size();
            if (N == 0) return 0;

            // Create the maxCol array to hold the maximum of each column
            vector<int> maxCol(N);
            for (int j = 0; j < N; ++j) {
                maxCol[j] = max(A[0][j], A[1][j]);
            }
            
            // Edge cases
            if (N == 1) return maxCol[0];
            if (N == 2) return max(maxCol[0], maxCol[1]);

            // DP array to store maximum sums up to each column
            vector<int> dp(N);
            dp[0] = maxCol[0];
            dp[1] = max(maxCol[0], maxCol[1]);
            
            for (int j = 2; j < N; ++j) {
                dp[j] = max(dp[j - 1], dp[j - 2] + maxCol[j]);
            }
            
            return dp[N - 1];
        }
    // Q3. N digit numbers
        /*
        Q.3 -> Find out the number of A digit positive numbers, whose digits on being added equals to a given number B.
        Note that a valid number starts from digits 1-9 except the number 0 itself. i.e. leading zeroes are not allowed.
        Since the answer can be large, output answer modulo 1000000007

        Note :

        Problem Constraints
            1 <= A <= 1000
            1 <= B <= 10000

        Input Format
            First argument is the integer A
            Second argument is the integer B 

        Output Format
            Return a single integer, the answer to the problem

        Input 1:
            A = 2
            B = 4

        Output 1:
            4

        Input 2:
            A = 1
            B = 3

        Output 2:
            1

        */

        // CODE
        int Solution::solve(int A, int B) {
            const int MOD = 1000000007;
            vector<vector<int>> dp(A + 1, vector<int>(B + 1, 0));
            
            // Base case: 0 digits with sum 0
            dp[0][0] = 1;
            
            // Filling the DP table
            for (int i = 1; i <= A; ++i) {
                for (int j = 0; j <= B; ++j) {
                    for (int d = (i == 1 ? 1 : 0); d <= 9; ++d) {  // Leading digit cannot be zero
                        if (j >= d) {
                            dp[i][j] = (dp[i][j] + dp[i - 1][j - d]) % MOD;
                        }
                    }
                }
            }
            
            return dp[A][B];
        }
    // Q4. Unique Binary Search Trees II
        /*
        Q.4 -> Given an integer A, how many structurally unique BST's (binary search trees) exist that can store values 1...A?

        Problem Constraints
            1 <= A <=18

        Input Format
            First and only argument is the integer A 

        Output Format
            Return a single integer, the answer to the problem

        Input 1:
            1

        Output 1:
            1

        Input 2:
            2

        Output 2:
            2

        */

        // CODE
        int Solution::numTrees(int A) {
            if (A == 0) return 1;
            
            vector<int> dp(A + 1, 0);
            dp[0] = 1;
            dp[1] = 1;
            
            for (int n = 2; n <= A; ++n) {
                for (int i = 1; i <= n; ++i) {
                    dp[n] += dp[i - 1] * dp[n - i];
                }
            }
            
            return dp[A];

        }
    // Q1. Min Sum Path in Matrix
        /*
        Q.1 -> Given a M x N grid A of integers, find a path from top left to bottom right which minimizes the sum of all numbers along its path.
        Return the minimum sum of the path.

        NOTE: You can only move either down or right at any point in time.

        Problem Constraints
            1 <= M, N <= 2000
            -1000 <= A[i][j] <= 1000

        Input Format
            First and only argument is a 2-D grid A.

        Output Format
            Return an integer denoting the minimum sum of the path.

        Input 1:
        A = [
            [1, 3, 2]
            [4, 3, 1]
            [5, 6, 1]
            ]

        Output 1:
            8

        Input 2:
        A = [
            [1, -3, 2]
            [2, 5, 10]
            [5, -5, 1]
            ]


        Output 2:
            -1

        */

        // CODE
        int Solution::minPathSum(vector<vector<int> > &A) {
            int M = A.size();
            int N = A[0].size();
            
            vector<vector<int>> dp(M, vector<int>(N, 0));
            
            // Initialize the top-left cell
            dp[0][0] = A[0][0];
            
            // Fill the first row
            for (int j = 1; j < N; j++) {
                dp[0][j] = dp[0][j - 1] + A[0][j];
            }
            
            // Fill the first column
            for (int i = 1; i < M; i++) {
                dp[i][0] = dp[i - 1][0] + A[i][0];
            }
            
            // Fill the rest of the dp table
            for (int i = 1; i < M; i++) {
                for (int j = 1; j < N; j++) {
                    dp[i][j] = A[i][j] + min(dp[i - 1][j], dp[i][j - 1]);
                }
            }
            
            // The minimum path sum is in the bottom-right corner
            return dp[M - 1][N - 1];
        }
    // Q2. Min Sum Path in Triangle
        /*
        Q.2 -> Given a triangle, find the minimum path sum from top to bottom. Each step you may move to adjacent numbers on the row below.
        Adjacent numbers for jth column of ith row is jth and (j+1)th column of (i + 1)th row

        Note :
            

        Problem Constraints
            |A| <= 1000
            A[i] <= 1000

        Input Format
            First and only argument is the vector of vector A defining the given triangle    

        Output Format
            Return the minimum sum

        Input 1:
        
        A = [ 
                [2],
                [3, 4],
            [6, 5, 7],
            [4, 1, 8, 3]
            ]

          
        A = [ 
                [2],
                [3, 4],
                [6, 5, 7],
                [4, 1, 8, 3]
            ]
        Output 1:
            11

        Input 2:
            A = [ [1] ]

        Output 2:
            1

        */

        // CODE
        int Solution::minimumTotal(vector<vector<int> > &A) {
            // Do not write main() function.
            // Do not read input, instead use the arguments to the function.
            // Do not print the output, instead return values as specified
            // Still have a doubt. Checkout www.interviewbit.com/pages/sample_codes/ for more details

            int n = A.size();
            
            // Starting from the second last row, move upwards
            for (int i = n - 2; i >= 0; i--) {
                for (int j = 0; j < A[i].size(); j++) {
                    // Update the current cell with the minimum sum of the path to reach the bottom
                    A[i][j] += min(A[i + 1][j], A[i + 1][j + 1]);
                }
            }
            
            // The top element now contains the minimum path sum
            return A[0][0];
        }
    // Q3. Intersecting Chords in a Circle
        /*
        Q.3 -> Given a number A, return number of ways you can draw A chords in a circle with 2 x A points such that no 2 chords intersect.
        Two ways are different if there exists a chord which is present in one way and not in other.
        Return the answer modulo 109 + 7.

        Note :

        Problem Constraints
            1 <= A <= 103

        Input Format
            The first and the only argument contains the integer A.

        Output Format
            Return an integer answering the query as described in the problem statement.

        Input 1:
            A=1

        Output 1:
            1

        Input 2:
            A=2

        Output 2:
            2

        */

        // CODE
        int Solution::chordCnt(int A) {
            const int MOD = 1000000007;
            vector<long long> catalan(A + 1, 0);
            catalan[0] = 1;  // Base case: C_0 = 1

            for (int i = 1; i <= A; i++) {
                for (int j = 0; j < i; j++) {
                    catalan[i] = (catalan[i] + (catalan[j] * catalan[i - 1 - j]) % MOD) % MOD;
                }
            }

            return (int)catalan[A];
        }
    // Q4. Max Rectangle in Binary Matrix
        /*
        Q.4 -> Given a 2-D binary matrix A of size N x M filled with 0's and 1's, find the largest rectangle containing only ones and return its area.

        Note :

        Problem Constraints
            1 <= N, M <= 100

        Input Format
            The first argument is a 2-D binary array A.

        Output Format
            Return an integer denoting the area of the largest rectangle containing only ones.

        Input 1:
            A = [
            [1, 1, 1]
            [0, 1, 1]
            [1, 0, 0] 
            ]

        Output 1:
            4

        Input 2:
            A = [
            [0, 1, 0]
            [1, 1, 1]
            ] 

        Output 2:
            3

        */

        // CODE
        int maxHistogramArea(vector<int>& heights) {
            stack<int> s;
            int maxArea = 0;
            int n = heights.size();
            
            for (int i = 0; i <= n; i++) {
                int h = (i == n ? 0 : heights[i]);
                while (!s.empty() && heights[s.top()] >= h) {
                    int height = heights[s.top()];
                    s.pop();
                    int width = s.empty() ? i : i - s.top() - 1;
                    maxArea = max(maxArea, height * width);
                }
                s.push(i);
            }
            return maxArea;
        }
        int Solution::maximalRectangle(vector<vector<int> > &A) {
            if (A.empty() || A[0].empty()) return 0;
            
            int N = A.size();
            int M = A[0].size();
            vector<int> heights(M, 0);
            int maxRectangle = 0;
            
            for (int i = 0; i < N; i++) {
                for (int j = 0; j < M; j++) {
                    heights[j] = (A[i][j] == 1) ? heights[j] + 1 : 0;
                }
                maxRectangle = max(maxRectangle, maxHistogramArea(heights));
            }
            
            return maxRectangle;
        }
        // Solution 2 
        int largestRectangleArea(vector<int>& heights) {
            stack<int> st;
            int maxArea = 0;
            int n = heights.size();

            for (int i = 0; i <= n; ++i) {
                int h = (i == n) ? 0 : heights[i];
                while (!st.empty() && h < heights[st.top()]) {
                    int height = heights[st.top()];
                    st.pop();
                    int width = st.empty() ? i : i - st.top() - 1;
                    maxArea = max(maxArea, height * width);
                }
                st.push(i);
            }

            return maxArea;
        }
        int maximalRectangle(vector<vector<char>>& matrix) {
            if (matrix.empty() || matrix[0].empty()) return 0;

            int maxArea = 0;
            int cols = matrix[0].size();
            vector<int> heights(cols, 0);

            for (const auto& row : matrix) {
                for (int j = 0; j < cols; ++j) {
                    // Update the height of the histogram based on the matrix row
                    heights[j] = (row[j] == '1') ? heights[j] + 1 : 0;
                }
                // Calculate the largest rectangle for the current histogram
                maxArea = max(maxArea, largestRectangleArea(heights));
            }

            return maxArea;
        }
## DP 3: Knapsack ##
    // Subset Sum = K
        bool subsetSumRecursive(vector<int>& A, int n, int k) {
            // Base cases
            if (k == 0) return true;  // Subset with sum 0 is always possible (empty subset)
            if (n == 0) return false; // No elements left to choose from

            // Recursive cases
            // Exclude the current element
            bool exclude = subsetSumRecursive(A, n - 1, k);

            // Include the current element (only if it doesn't exceed the remaining sum)
            bool include = false;
            if (A[n - 1] <= k) {
                include = subsetSumRecursive(A, n - 1, k - A[n - 1]);
            }

            return include || exclude; // Return true if either is true
        }
    // Q1. Fractional Knapsack
        /*
        Q.1 -> Given two integer arrays A and B of size N each which represent values and weights associated with N items respectively.
        Also given an integer C which represents knapsack capacity.
        Find out the maximum total value that we can fit in the knapsack. If the maximum total value is ans, then return ans  100 , i.e., floor of (ans  100).

        NOTE:
            You can break an item for maximizing the total value of the knapsack

        Problem Constraints
            1 <= N <= 105
            1 <= A[i], B[i] <= 103
            1 <= C <= 103

        Input Format
            First argument is an integer array A of size N denoting the values on N items.
            Second argument is an integer array B of size N denoting the weights on N items.
            Third argument is an integer C denoting the knapsack capacity.

        Output Format
            Return a single integer denoting the maximum total value of A such that sum of the weights of this subset is smaller than or equal to C.

        Input 1:
            A = [60, 100, 120]
            B = [10, 20, 30]
            C = 50

        Output 1:
            24000

        Input 2:
            A = [10, 20, 30, 40]
            B = [12, 13, 15, 19]
            C = 10

        Output 2:
            2105

        */

        // CODE
        bool descending(pair<double, int>& A, pair<double, int>& B) {
            return (A.first > B.first);
        }

        int Solution::solve(vector<int> &A, vector<int> &B, int C) {
            vector<pair<double, int>> ratio;
            double ans = 0.0;

            // Calculate value-to-weight ratio for each item
            for (int i = 0; i < A.size(); i++) {
                double r = (double)A[i] / B[i];
                ratio.push_back({r, i});
            }

            // Sort items based on the ratio in descending order
            sort(ratio.begin(), ratio.end(), descending);

            // Fill the knapsack
            for (int i = 0; i < A.size(); i++) {
                int index = ratio[i].second;
                if (B[index] <= C) {
                    // If the entire item fits, take it
                    ans += A[index];
                    C -= B[index];
                } else {
                    // Take as much as possible from the current item
                    ans += ratio[i].first * C;
                    break;
                }
            }

            // Return floor(ans * 100)
            return (int)(ans * 1000) / 10;
        }

    // Q2. 0-1 Knapsack
        /*
        Q.2 -> Given two integer arrays A and B of size N each which represent values and weights associated with N items respectively.
        Also given an integer C which represents knapsack capacity.
        Find out the maximum value subset of A such that sum of the weights of this subset is smaller than or equal to C.

        NOTE:
            You cannot break an item, either pick the complete item, or dont pick it (0-1 property).

        Problem Constraints
            1 <= N <= 103
            1 <= C <= 103
            1 <= A[i], B[i] <= 103

        Input Format
            First argument is an integer array A of size N denoting the values on N items.
            Second argument is an integer array B of size N denoting the weights on N items.
            Third argument is an integer C denoting the knapsack capacity.

        Output Format
            Return a single integer denoting the maximum value subset of A such that sum of the weights of this subset is smaller than or equal to C.

        Input 1:
            A = [60, 100, 120]
            B = [10, 20, 30]
            C = 50

        Output 1:
            220

        Input 2:
            A = [10, 20, 30, 40]
            B = [12, 13, 15, 19]
            C = 10

        Output 2:
            0

        */

        // CODE
        int Solution::solve(vector<int> &A, vector<int> &B, int C) {
            int N = A.size();
            // DP table: dp[i][j] represents max value with the first i items and capacity j
            vector<vector<int>> dp(N + 1, vector<int>(C + 1, 0));

            // Fill DP table
            for (int i = 1; i <= N; ++i) {
                for (int w = 1; w <= C; ++w) {
                    if (B[i - 1] <= w) {
                        // Max value by including or excluding the current item
                        dp[i][w] = max(dp[i - 1][w], A[i - 1] + dp[i - 1][w - B[i - 1]]);
                    } else {
                        // Cannot include the current item
                        dp[i][w] = dp[i - 1][w];
                    }
                }
            }

            // The result is stored in dp[N][C]
            return dp[N][C];
        }

        int knapsackMemoization(int ind, int W, vector<int>& wt, vector<int>& val, vector<vector<int>>& dp) {
            if (ind == 0) {
                return (wt[0] <= W) ? val[0] : 0;
            }
            if (dp[ind][W] != -1) {
                return dp[ind][W];
            }

            // Option to not take the current item
            int non_take = 0 + knapsackMemoization(ind - 1, W, wt, val, dp);

            // Option to take the current item (only if it fits)
            int take = INT_MIN;
            if (wt[ind] <= W) {
                take = val[ind] + knapsackMemoization(ind - 1, W - wt[ind], wt, val, dp);
            }

            return dp[ind][W] = max(take, non_take);
        }
    // Q3. Unbounded Knapsack
        /*
        Q.3 ->Given a knapsack weight A and a set of items with certain value B[i] and weight C[i], we need to calculate maximum amount that could fit in this quantity.
        This is different from classical Knapsack problem, here we are allowed to use unlimited number of instances of an item. 

        Problem Constraints
            1 <= A <= 1000
            1 <= |B| <= 1000
            1 <= B[i] <= 1000
            1 <= C[i] <= 1000

        Input Format
            First argument is the Weight of knapsack A
            Second argument is the vector of values B
            Third argument is the vector of weights C

        Output Format
            Return the maximum value that fills the knapsack completely

        Input 1:
            A = 10
            B = [5]
            C = [10]

        Output 1:
            5

        Input 2:
            A = 10
            B = [6, 7]
            C = [5, 5]

        Output 2:
            14

        */

        // Function to solve the unbounded knapsack problem
        int knapsackUtil(vector<int>& wt, vector<int>& val, int ind, int W, vector<vector<int>>& dp) {
            // Base case: if we're at the first item
            if (ind == 0) {
                // Calculate and return the maximum value for the given weight limit
                return (W / wt[0]) * val[0];
            }
            
            // If the result for this index and weight limit is already calculated, return it
            if (dp[ind][W] != -1)
                return dp[ind][W];
                
            // Calculate the maximum value without taking the current item
            int notTaken = 0 + knapsackUtil(wt, val, ind - 1, W, dp);
            
            // Calculate the maximum value by taking the current item
            int taken = INT_MIN;
            if (wt[ind] <= W)
                taken = val[ind] + knapsackUtil(wt, val, ind, W - wt[ind], dp);
                
            // Store the maximum value in the DP table and return it
            return dp[ind][W] = max(notTaken, taken);
        }

        // Function to solve the unbounded knapsack problem
        int unboundedKnapsack(int n, int W, vector<int>& val, vector<int>& wt) {
            vector<vector<int>> dp(n, vector<int>(W + 1, -1)); // Create a DP table
            
            // Call the utility function to calculate the maximum value
            return knapsackUtil(wt, val, n - 1, W, dp);
        }
        
        // CODE
        int Solution::solve(int A, vector<int> &B, vector<int> &C) {
            // A represents the knapsack capacity
            int N = B.size();
            vector<int> dp(A + 1, 0); // dp[j] stores max value for capacity j

            // Iterate over all capacities from 0 to A
            for (int i = 0; i < N; ++i) { // Loop over each item
                for (int j = C[i]; j <= A; ++j) { // Start from C[i] up to capacity A
                    dp[j] = max(dp[j], B[i] + dp[j - C[i]]);
                }
            }

            // Maximum value for capacity A is stored in dp[A]
            return dp[A];
        }
    // Q1. Buying Candies
        /*
        Q.1 -> 
        Rishik likes candies a lot. So, he went to a candy-shop to buy candies.
        The shopkeeper showed him N packets each containg A[i] candies for cost of C[i] nibbles, each candy in that packet has a sweetness B[i]. The shopkeeper puts the condition that Rishik can buy as many complete candy-packets as he wants but he can't buy a part of the packet.
        Rishik has D nibbles, can you tell him the maximum amount of sweetness he can get from candy-packets he will buy?

        Note :

        Problem Constraints
            1 <= N <= 700
            1 <= A[i] <= 1000
            1 <= B[i] <= 1000
            1 <= C[i],D <= 1000

        Input Format
            First argument of input is an integer array A
            Second argument of input is an integer array B
            Third argument of input is an integer array C
            Fourth argument of input is an integer D 

        Output Format
            Return a single integer denoting maximum sweetness of the candies that he can buy

        Input 1:
            A = [1, 2, 3]
            B = [2, 2, 10]
            C = [2, 3, 9]
            D = 8

        Output 1:
            10

        Input 2:
            A = [2]
            B = [5]
            C = [10]
            D = 99

        Output 2:
            90

        */

        int maxSweetnessHelper(vector<int>& A, vector<int>& B, vector<int>& C, int D, int index, vector<vector<int>>& dp) {
            // Base case: no more packets or no more nibbles
            if (index == A.size() || D == 0) {
                return 0;
            }

            // Check if already computed
            if (dp[index][D] != -1) {
                return dp[index][D];
            }

            // Option 1: Exclude the current packet
            int exclude = maxSweetnessHelper(A, B, C, D, index + 1, dp);

            // Option 2: Include the current packet (if we can afford it)
            int include = 0;
            if (C[index] <= D) {
                int packetSweetness = A[index] * B[index];
                include = packetSweetness + maxSweetnessHelper(A, B, C, D - C[index], index, dp);
            }

            // Take the maximum of include and exclude
            dp[index][D] = max(exclude, include);
            return dp[index][D];
        }
        int maxSweetness(vector<int>& A, vector<int>& B, vector<int>& C, int D) {
            int N = A.size();
            // Initialize memoization table with -1
            vector<vector<int>> dp(N, vector<int>(D + 1, -1));

            // Start recursion
            return maxSweetnessHelper(A, B, C, D, 0, dp);
        }

        // CODE
        int Solution::solve(vector<int> &A, vector<int> &B, vector<int> &C, int D) {
        vector< vector< int > > maxSweetness(2, vector< int >(D+1, 0));
            int row = 0;
            for(int i=0;i<A.size();i++){
                for(int j=1;j<=D;j++){
                    if(j >= C[i]){
                        maxSweetness[row ^ 1][j] = max( maxSweetness[row][j], max( maxSweetness[row ^ 1][j-1], A[i]*B[i] + maxSweetness[row ^ 1][j - C[i]] ) );
                    }else{
                        maxSweetness[row ^ 1][j] = max(maxSweetness[row][j], maxSweetness[row ^ 1][j-1]);
                    } 
                }
                row ^= 1;
            }

            return maxSweetness[row][D];
        }
    // Q2. Tushar's Birthday Party
        /*
        Q.2 -> As it is Tushar's Birthday on March 1st, he decided to throw a party to all his friends at TGI Fridays in Pune. Given are the eating capacity of each friend, filling capacity of each dish and cost of each dish. A friend is satisfied if the sum of the filling capacity of dishes he ate is equal to his capacity. Find the minimum cost such that all of Tushar's friends are satisfied (reached their eating capacity).

        NOTE:
        Each dish is supposed to be eaten by only one person. Sharing is not allowed.
        Each friend can take any dish unlimited number of times.
        There always exists a dish with filling capacity 1 so that a solution always exists.

        Problem Constraints
            |A| <= 1000
            |B| <= 1000
            |C| <= 1000

        Input Format
            First Argument is vector A, denoting eating capacities
            Second Argument is vector B, denoting filling capacities
            Third Argument is vector C, denoting cost

        Output Format
            Return a single integer, the answer to the problem

        Input 1:
            A = [2, 4, 6]
            B = [2, 1, 3]
            C = [2, 5, 3]

        Output 1:
            12

        Input 2:
            A = [2]
            B = [1]
            C = [2]

        Output 2:
            4

        */

        // CODE
        int Solution::solve(const vector<int> &A, const vector<int> &B, const vector<int> &C) {
            int maxCapacity = *max_element(A.begin(), A.end());
            vector<int> dp(maxCapacity + 1, INT_MAX);
            dp[0] = 0;  // Cost to achieve capacity 0 is 0

            // Populate the DP table for minimum cost to achieve capacity i
            for (int i = 1; i <= maxCapacity; ++i) {
                for (int j = 0; j < B.size(); ++j) {
                    if (i >= B[j]) {
                        if (dp[i - B[j]] != INT_MAX) {
                            dp[i] = min(dp[i], dp[i - B[j]] + C[j]);
                        }
                    }
                }
            }

            int totalCost = 0;
            for (int capacity : A) {
                totalCost += dp[capacity];
            }

            return totalCost;
        }
    // Q3. Ways to send the signal
        /*
        Q.3 -> You are trying to send signals to aliens using a linear array of A laser lights. You don't know much about how the aliens are going to percieve the signals, but what you know is that if two consecutive lights are on then the aliens might take it as a sign of danger and destroy the earth.
        Find and return the total number of ways in which you can send a signal without compromising the safty of the earth. Return the ans % 109 + 7.

        Note :

        Problem Constraints
            1 <= A <= 105

        Input Format
            The only argument given is integer A.   

        Output Format
            Return the ans%(109+7).

        Input 1:
            A = 2

        Output 1:
            3

        Input 2:
            A = 3

        Output 2:
            5

        */

        // CODE
        int Solution::solve(int A) {
            const int MOD = 1000000007;
            if (A == 1) return 2;
            if (A == 2) return 3;

            // Initialize base cases
            long long prev2 = 2;  // dp[1]
            long long prev1 = 3;  // dp[2]
            long long current = 0;

            // Compute dp[A] using the recurrence relation
            for (int i = 3; i <= A; ++i) {
                current = (prev1 + prev2) % MOD;
                prev2 = prev1;
                prev1 = current;
            }

            return current;
        }
        
        long long solve(int n, vector<long long> &dp) {
            // Base cases
            if (n == 1) return 2;  // Single light: "O", "X"
            if (n == 2) return 3;  // Two lights: "OX", "XO", "XX"

            // If already calculated, return the result
            if (dp[n] != -1) return dp[n];

            // Recursive relation: dp[n] = dp[n-1] + dp[n-2]
            dp[n] = (solve(n - 1, dp) + solve(n - 2, dp)) % MOD;
            return dp[n];
        }
## DP 4: Applications of Knapsack ##
    // Q1. Cutting a Rod
        /*
        Q.1 -> Given a rod of length N units and an array A of size N denotes prices that contains prices of all pieces of size 1 to N.
        Find and return the maximum value that can be obtained by cutting up the rod and selling the pieces.

        Note :
            

        Problem Constraints
            1 <= N <= 1000
            0 <= A[i] <= 106

        Input Format
            First and only argument is an integer array A of size N.

        Output Format
            Return an integer denoting the maximum value that can be obtained by cutting up the rod and selling the pieces.

        Input 1:
            A = [3, 4, 1, 6, 2]

        Output 1:
            15

        Input 2:
            A = [1, 5, 2, 5, 6]

        Output 2:
            11


        */

        // CODE
        int Solution::solve(vector<int> &A) {
            int N = A.size();
            vector<int> dp(N + 1, 0);

            // dp[i] will store the maximum value obtainable for a rod of length i
            for (int i = 1; i <= N; ++i) {
                for (int j = 1; j <= i; ++j) {
                    dp[i] = max(dp[i], A[j - 1] + dp[i - j]);
                }
            }

            return dp[N];
        }

        int getMaxProfit(int ind, int length, vector<int> &A, vector<vector<int>> &dp) {
            // Base cases
            if (length == 0) return 0;  // No rod left
            if (ind == A.size()) return 0;  // No pieces left to consider

            // If already computed, return the result
            if (dp[ind][length] != -1) return dp[ind][length];

            // Recursive case: Two choices - take or skip
            int take = 0;
            if (length >= ind + 1) {  // If we can take the current piece
                take = A[ind] + getMaxProfit(ind, length - (ind + 1), A, dp);
            }
            int skip = getMaxProfit(ind + 1, length, A, dp);

            // Store the result and return the maximum
            return dp[ind][length] = max(take, skip);
        }
    // Q2. Coin Sum Infinite
        /*
        Q.2 -> You are given a set of coins A. In how many ways can you make sum B assuming you have infinite amount of each coin in the set.

        NOTE:
            Coins in set A will be unique. Expected space complexity of this problem is O(B).
            The answer can overflow. So, return the answer % (106 + 7).

        Note :
            

        Problem Constraints
            1 <= A <= 500
            1 <= A[i] <= 1000
            1 <= B <= 50000

        Input Format
            First argument is an integer array A representing the set.
            Second argument is an integer B.    

        Output Format
            Return an integer denoting the number of ways

        Input 1:
            A = [1, 2, 3]
            B = 4

        Output 1:
            4

        Input 2:
            A = [10]
            B = 10

        Output 2:
            1

        */

        // CODE
        int Solution::coinchange2(vector<int> &A, int B) {
            const int MOD = 1000007;
            vector<int> dp(B + 1, 0);
            dp[0] = 1; // Base case: there is 1 way to make sum 0 (use no coins)

            for (int coin : A) {
                for (int i = coin; i <= B; ++i) {
                    dp[i] = (dp[i] + dp[i - coin]) % MOD;
                }
            }

            return dp[B];
        }

        int getWays(int ind, int sum, vector<int> &A, vector<vector<int>> &dp) {
            // Base cases
            if (sum == 0) return 1; // 1 way to make sum 0 (use no coins)
            if (ind == A.size()) return 0; // No coins left
            if (sum < 0) return 0; // Invalid case

            // If already computed, return the result
            if (dp[ind][sum] != -1) return dp[ind][sum];

            // Recursive case: take or skip the current coin
            int take = 0, skip = 0;

            // Take the current coin if possible
            if (sum >= A[ind]) {
                take = getWays(ind, sum - A[ind], A, dp) % MOD;
            }

            // Skip the current coin
            skip = getWays(ind + 1, sum, A, dp) % MOD;

            // Store the result and return
            return dp[ind][sum] = (take + skip) % MOD;
        }
    // Q3. 0-1 Knapsack II
        /*
        Q.3 -> Given two integer arrays A and B of size N each which represent values and weights associated with N items respectively.
        Also given an integer C which represents knapsack capacity.
        Find out the maximum value subset of A such that sum of the weights of this subset is smaller than or equal to C.

        NOTE: You cannot break an item, either pick the complete item, or dont pick it (0-1 property).

        Problem Constraints
            1 <= N <= 500
            1 <= C, B[i] <= 106
            1 <= A[i] <= 50

        Input Format
            First argument is an integer array A of size N denoting the values on N items.
            Second argument is an integer array B of size N denoting the weights on N items.
            Third argument is an integer C denoting the knapsack capacity.

        Output Format
            Return a single integer denoting the maximum value subset of A such that sum of the weights of this subset is smaller than or equal to C.

        Input 1:
            A = [6, 10, 12]
            B = [10, 20, 30]
            C = 50

        Output 1:
            22

        Input 2:
            A = [1, 3, 2, 4]
            B = [12, 13, 15, 19]
            C = 10

        Output 2:
            0

        */

        // CODE
        int Solution::solve(vector<int> &A, vector<int> &B, int C) {
            vector<int> dp(C + 1, 0);  // dp[j] stores the maximum value for knapsack capacity j

            int N = A.size();
            for (int i = 0; i < N; ++i) {
                // Iterate from right to left to avoid overwriting results for the current item
                for (int j = C; j >= B[i]; --j) {
                    dp[j] = max(dp[j], dp[j - B[i]] + A[i]);
                }
            }

            return dp[C];
        }

        int knapsackHelper(int ind, int capacity, vector<int> &A, vector<int> &B, vector<vector<int>> &dp) {
            // Base cases
            if (ind == A.size()) return 0; // No more items to consider
            if (capacity == 0) return 0;   // No remaining capacity

            // If already computed, return stored result
            if (dp[ind][capacity] != -1) return dp[ind][capacity];

            // Option 1: Don't pick the current item
            int skip = knapsackHelper(ind + 1, capacity, A, B, dp);

            // Option 2: Pick the current item (if weight allows)
            int pick = 0;
            if (B[ind] <= capacity) {
                pick = A[ind] + knapsackHelper(ind + 1, capacity - B[ind], A, B, dp);
            }

            // Store and return the maximum of the two choices
            return dp[ind][capacity] = max(skip, pick);
        }

        int knapsack(vector<int> &A, vector<int> &B, int C) {
            int N = A.size();

            // DP table initialized to -1
            vector<vector<int>> dp(N, vector<int>(C + 1, -1));

            // Start recursion
            return knapsackHelper(0, C, A, B, dp);
        }
    // Q1. Distinct Subsequences
        /*
        Q.1 -> Given two sequences A and B, count number of unique ways in sequence A, to form a subsequence that is identical to the sequence B.
        Subsequence : A subsequence of a string is a new string which is formed from the original string by deleting some (can be none) of the characters without disturbing the relative positions of the remaining characters. (ie, "ACE" is a subsequence of "ABCDE" while "AEC" is not).

        Note :
            

        Problem Constraints
            1 <= length(A), length(B) <= 700

        Input Format
            The first argument of input contains a string A.
            The second argument of input contains a string B. 

        Output Format
            Return an integer representing the answer as described in the problem statement.

        Input 1:
            A = "abc"
            B = "abc"

        Output 1:
            1

        Input 2:
            A = "rabbbit" 
            B = "rabbit" 

        Output 2:
            3

        */

        // CODE
        int Solution::numDistinct(string A, string B) {
            int n = A.size(), m = B.size();
            vector<vector<long long>> dp(n + 1, vector<long long>(m + 1, 0));
            const int MOD = 1000000007;

            // Base case: An empty string B can be formed in one way for any prefix of A
            for (int i = 0; i <= n; ++i) {
                dp[i][0] = 1;
            }

            for (int i = 1; i <= n; ++i) {
                for (int j = 1; j <= m; ++j) {
                    // If characters match
                    if (A[i - 1] == B[j - 1]) {
                        dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % MOD;
                    } else {
                        // If characters do not match
                        dp[i][j] = dp[i - 1][j];
                    }
                }
            }

            return dp[n][m];
        }

        int countSubsequences(int i, int j, const string &A, const string &B, vector<vector<int>> &dp) {
            // Base Cases
            if (j == B.size()) return 1; // Entire B is matched
            if (i == A.size()) return 0; // Exhausted A but B is not matched

            // If already computed, return the result
            if (dp[i][j] != -1) return dp[i][j];

            // Recursive Choices
            if (A[i] == B[j]) {
                // Two options: Use A[i] or skip it
                dp[i][j] = countSubsequences(i + 1, j + 1, A, B, dp) // Match A[i] with B[j]
                        + countSubsequences(i + 1, j, A, B, dp);   // Skip A[i]
            } else {
                // Skip A[i] if characters don't match
                dp[i][j] = countSubsequences(i + 1, j, A, B, dp);
            }

            return dp[i][j];
        }

        // Main function
        int distinctSubsequences(string A, string B) {
            int N = A.size(), M = B.size();

            // DP table initialized with -1
            vector<vector<int>> dp(N, vector<int>(M, -1));

            // Start recursion from the beginning of both strings
            return countSubsequences(0, 0, A, B, dp);
        }
    // Q2. Length of Longest Fibonacci Subsequence
        /*
        Q.2 -> Given a strictly increasing array A of positive integers forming a sequence.
        A sequence X1, X2, X3, ..., XN is fibonacci like if
            N > =3
            Xi + Xi+1 = Xi+2 for all i+2 <= N
        Find and return the length of the longest Fibonacci-like subsequence of A.
        If one does not exist, return 0.

        NOTE: A subsequence is derived from another sequence A by deleting any number of elements (including none) from A, without changing the order of the remaining elements.

        Problem Constraints
            3 <= length of the array <= 1000
            1 <= A[i] <= 109

        Input Format
            The only argument given is the integer array A.

        Output Format
            Return the length of the longest Fibonacci-like subsequence of A.
            If one does not exist, return 0.

        Input 1:
            A = [1, 2, 3, 4, 5, 6, 7, 8]

        Output 1:
            5

        Input 2:
            A = [1, 3, 7, 11, 12, 14, 18]

        Output 2:
            3

        */

        // CODE
        int Solution::solve(vector<int> &A) {
            int n = A.size();
            if (n < 3) return 0; // No possible Fibonacci-like sequence if size < 3

            unordered_map<int, int> index; // Maps element values to their indices
            for (int i = 0; i < n; ++i) {
                index[A[i]] = i;
            }

            // A map to store lengths of Fibonacci-like subsequences ending at indices (i, j)
            unordered_map<int, int> dp;
            int maxLen = 0;

            // Try to form Fibonacci-like sequences ending with A[j] and A[k]
            for (int k = 2; k < n; ++k) {
                for (int j = 0; j < k; ++j) {
                    int prev = A[k] - A[j]; // This should be the preceding element in the sequence
                    if (prev < A[j] && index.find(prev) != index.end()) {
                        int i = index[prev]; // i < j < k
                        int len = dp[i * n + j] + 1; // Extend previous sequence ending at (i, j)
                        dp[j * n + k] = len;
                        maxLen = max(maxLen, len + 2); // Length must be at least 3
                    }
                }
            }

            return maxLen >= 3 ? maxLen : 0; // Return 0 if no valid sequence found
        }
    // Q3. Let's Party
        /*
        Q.3 -> In Danceland, one person can party either alone or can pair up with another person.
        Can you find in how many ways they can party if there are A people in Danceland?

        Note: Return your answer modulo 10003, as the answer can be large.

        Problem Constraints
            1 <= A <= 105

        Input Format
            Given only argument A of type Integer, number of people in Danceland.

        Output Format
            Return an integer denoting the number of ways people of Danceland can party.

        Input 1:
            A = 3

        Output 1:
            4

        Input 2:
            A = 5

        Output 2:
            26

        */

        // CODE
        int Solution::solve(int A) {
            const int MOD = 10003;
            if (A <= 2) return A; // Base cases: 1 -> 1 way, 2 -> 2 ways

            vector<int> dp(A + 1);
            dp[1] = 1; // 1 person -> 1 way
            dp[2] = 2; // 2 people -> 2 ways (either alone or paired)

            for (int i = 3; i <= A; ++i) {
                dp[i] = (dp[i - 1] + (long long)(i - 1) * dp[i - 2]) % MOD;
            }

            return dp[A];
        }

## DP Extra ##
    // DP Introduction
    // Fibonacci
        // Top-Down Approach (Memoization)
            int fibonacciHelper(int n, std::vector<int>& memo) {
                if (n <= 1) return n;  // Base case

                if (memo[n] != -1) return memo[n]; // Return the cached value if available

                // Store the result in memo array and return it
                return memo[n] = fibonacciHelper(n - 1, memo) + fibonacciHelper(n - 2, memo);
            }
            int fibonacci(int n) {
                std::vector<int> memo(n + 1, -1); // Create a memoization array initialized to -1
                return fibonacciHelper(n, memo);
            }
        // Bottom-Up Approach (Tabulation)
            int fibonacci(int n) {
                if (n <= 1) return n;  // Base case

                std::vector<int> dp(n + 1, 0); // Create a DP array of size (n+1)
                dp[0] = 0;
                dp[1] = 1;

                for (int i = 2; i <= n; ++i) {
                    dp[i] = dp[i - 1] + dp[i - 2]; // Recurrence relation
                }

                return dp[n];
            }
        //  Optimized Space Bottom-Up Approach
            int fibonacci(int n) {
                if (n <= 1) return n; // Base case

                int prev2 = 0; // dp[i-2]
                int prev1 = 1; // dp[i-1]
                int current = prev1 + prev2;

                for (int i = 2; i <= n; ++i) {
                    current = prev1 + prev2; // Calculate current Fibonacci number
                    prev2 = prev1;           // Update prev2 to prev1
                    prev1 = current;        // Update prev1 to current
                }

                return current;
            }
    // Climbing Stairs
        // recursive
            int climbStairs(int n) {
                if (n <= 1) return 1; // Base cases: 1 way to reach 0th or 1st step

                // Recursive calls: reaching the nth step
                return climbStairs(n - 1) + climbStairs(n - 2);
            }
        // Tabulation (Bottom-Up DP)
            int climbStairs(int n) {
                if (n <= 1) return 1; // Base case

                std::vector<int> dp(n + 1, 0); // Create a DP array
                dp[0] = 1; // 1 way to stay at the ground (0th step)
                dp[1] = 1; // 1 way to reach the 1st step

                for (int i = 2; i <= n; ++i) {
                    dp[i] = dp[i - 1] + dp[i - 2]; // Sum of ways to reach the previous two steps
                }

                return dp[n];
            }
        // Space Optimization
            int climbStairs(int n) {
                if (n <= 1) return 1; // Base cases

                int prev2 = 1; // Represents the number of ways to reach the (n-2)th step
                int prev1 = 1; // Represents the number of ways to reach the (n-1)th step
                int current;

                for (int i = 2; i <= n; ++i) {
                    current = prev1 + prev2; // Current step ways = sum of the previous two steps
                    prev2 = prev1; // Move the window forward
                    prev1 = current; // Update prev1
                }

                return current;
            }
    // Frog jump
        // memoization
            int frogJumpHelper(int i, const std::vector<int>& heights, std::vector<int>& dp) {
                if (i == 0) return 0; // Base case: no cost to stay at the first stone

                if (dp[i] != -1) return dp[i]; // Return memoized result

                int oneStep = frogJumpHelper(i - 1, heights, dp) + abs(heights[i] - heights[i - 1]);
                int twoSteps = INT_MAX;
                if (i > 1) {
                    twoSteps = frogJumpHelper(i - 2, heights, dp) + abs(heights[i] - heights[i - 2]);
                }

                return dp[i] = min(oneStep, twoSteps); // Memoize and return
            }

        // Tabulation
            int frogJump(int n, const std::vector<int>& heights) {
                std::vector<int> dp(n, 0);
                dp[0] = 0; // Starting point, no energy needed

                for (int i = 1; i < n; ++i) {
                    int oneStep = dp[i - 1] + abs(heights[i] - heights[i - 1]);
                    int twoSteps = (i > 1) ? dp[i - 2] + abs(heights[i] - heights[i - 2]) : INT_MAX;
                    dp[i] = std::min(oneStep, twoSteps);
                }

                return dp[n - 1]; // Minimum energy to reach the last stone
            }
        // Spcace Optimization
            int frogJump(int n, const std::vector<int>& heights) {
                int prev1 = 0, prev2 = 0; // Base cases

                for (int i = 1; i < n; ++i) {
                    int oneStep = prev1 + abs(heights[i] - heights[i - 1]);
                    int twoSteps = (i > 1) ? prev2 + abs(heights[i] - heights[i - 2]) : INT_MAX;
                    int current = std::min(oneStep, twoSteps);

                    prev2 = prev1; // Move window
                    prev1 = current;
                }

                return prev1; // Minimum energy to reach the last stone
            }
    // Frog Jump With K distance
        // Memoization
            int frogJumpHelper(int i, const std::vector<int>& heights, int k, std::vector<int>& dp) {
                if (i == 0) return 0; // Base case: no cost at the first stone

                if (dp[i] != -1) return dp[i]; // Return memoized result

                int minCost = INT_MAX;
                for (int j = 1; j <= k; ++j) {
                    if (i - j >= 0) {
                        int jumpCost = frogJumpHelper(i - j, heights, k, dp) + abs(heights[i] - heights[i - j]);
                        minCost = std::min(minCost, jumpCost);
                    }
                }

                return dp[i] = minCost; // Memoize and return
            }
        // tabulation
            int frogJump(int n, const std::vector<int>& heights, int k) {
                std::vector<int> dp(n, 0);
                dp[0] = 0; // Starting point, no energy needed

                for (int i = 1; i < n; ++i) {
                    int minCost = INT_MAX;
                    for (int j = 1; j <= k; ++j) {
                        if (i - j >= 0) {
                            int jumpCost = dp[i - j] + abs(heights[i] - heights[i - j]);
                            minCost = std::min(minCost, jumpCost);
                        }
                    }
                    dp[i] = minCost;
                }

                return dp[n - 1]; // Minimum energy to reach the last stone
            }

    // Maximum Sum of Non-Adjacent Elements I (House Robber)
        // Memoization
            int maxRob(int index, vector<int>& nums, vector<int>& dp) {
                if(index == 0){
                    return nums[0]
                }
                if (index < 0) return 0;

                if (dp[index] != -1) return dp[index];

                // Rob the current house or skip it
                int take = nums[index] + maxRob(index - 2, nums, dp);
                int non_take = 0 + maxRob(index - 1, nums, dp);
                dp[index] = max(take, non_take);
                return dp[index];
            }
        // Tabulation
            int houseRobberTab(vector<int>& nums) {
                if (nums.empty()) return 0;
                int n = nums.size();
                vector<int> dp(n, 0);

                dp[0] = nums[0];
                int neg = 0;

                for (int i = 1; i < n; i++) {
                    int take = nums[i];
                    if(i>1){ take += dp[i-2]; }

                    int non_take = 0 + dp[i-1]

                    dp[i] = max(take, non_take);
                }
                return dp[n - 1];
            }
        // space Optimization
            int houseRobber_Space_Opt(vector<int>& nums) {
                if (nums.empty()) return 0;
                int n = nums.size();

                int prev1 = nums[0];
                int prev2 = 0;

                for (int i = 1; i < n; i++) {

                    int take = nums[i];
                    if(i>1){ take += prev2;}

                    int non_take = 0 + prev1;

                    int curr = max(take, non_take);

                    prev2 = prev1;
                    prev1 = curr;
                }
                return prev1;
            }
    // Maximum Sum of Non-Adjacent Elements II (House Robber II)
        // Last House is Adjacent to the First House
            int houseRobber_Space_Opt(vector<int>& nums) {
                if (nums.empty()) return 0;
                int n = nums.size();

                int prev1 = nums[0];
                int prev2 = 0;

                for (int i = 1; i < n; i++) {

                    int take = nums[i];
                    if(i>1){ take += prev2;}

                    int non_take = 0 + prev1;

                    int curr = max(take, non_take);

                    prev2 = prev1;
                    prev1 = curr;
                }
                return prev1;
            }
            long long int solve(vector<int>& nums){
                vector<int> temp1, temp2;
                int n = nums.size();

                for(int i=0; i<n; i++){
                    if(i!= 0){
                        temp1.push_back(nums[i]);
                    }
                    if(i!=n-1){
                        temp2.push_back(nums[i]);
                    }
                }

                return max(houseRobber_Space_Opt(temp1), houseRobber_Space_Opt(temp2));
            }   
    // 2D DP
    // Ninja's Training
        // Recursive function to find the maximum points
            int f(int day, int last, vector<vector<int>>& arr) {
                // Base case: When on the first day (day == 0)
                if (day == 0) {
                    int maxPoints = INT_MIN;
                    for (int i = 0; i < 3; i++) {
                        if (i != last) {  // Ensure the last activity is not repeated
                            maxPoints = max(maxPoints, arr[day][i]);
                        }
                    }
                    return maxPoints;
                }

                // Recursively find the maximum points for the current day
                int maxPoints = INT_MIN;
                for (int i = 0; i < 3; i++) {
                    if (i != last) {  // Choose activity different from the last activity
                        int points = arr[day][i] + f(day - 1, i, arr);
                        maxPoints = max(maxPoints, points);
                    }
                }

                return maxPoints;
            }
        // Memoization
            int f(int day, int last, vector<vector<int>>& arr, vector<vector<int>>& dp) {
                // Base case: When on the first day (day == 0)
                if (day == 0) {
                    int maxPoints = INT_MIN;
                    for (int i = 0; i < 3; i++) {
                        if (i != last) {  // Ensure the last activity is not repeated
                            maxPoints = max(maxPoints, arr[day][i]);
                        }
                    }
                    return maxPoints;
                }

                // Check if the result for this state has already been computed
                if (dp[day][last] != -1) {
                    return dp[day][last];
                }

                // Recursively find the maximum points for the current day
                int maxPoints = INT_MIN;
                for (int i = 0; i < 3; i++) {
                    if (i != last) {  // Choose activity different from the last activity
                        int points = arr[day][i] + f(day - 1, i, arr, dp);
                        maxPoints = max(maxPoints, points);
                    }
                }

                // Store the result in the dp array
                return dp[day][last] = maxPoints;
            }
        // tabulation
            int ninjaTraining(int n, vector<vector<int>>& arr) {
                // dp table where dp[day][last] stores the maximum points for day 'day' with 'last' activity chosen on the previous day
                vector<vector<int>> dp(n, vector<int>(4, 0));

                // Base case: Fill values for the first day (day = 0)
                dp[0][0] = max(arr[0][1], arr[0][2]); // If last activity was 0, choose max between activities 1 and 2
                dp[0][1] = max(arr[0][0], arr[0][2]); // If last activity was 1, choose max between activities 0 and 2
                dp[0][2] = max(arr[0][0], arr[0][1]); // If last activity was 2, choose max between activities 0 and 1
                dp[0][3] = max({arr[0][0], arr[0][1], arr[0][2]}); // If no previous activity (initial state)

                // Fill the dp table for remaining days
                for (int day = 1; day < n; day++) {
                    for (int last = 0; last < 4; last++) { // Iterate over possible 'last' activities
                        dp[day][last] = INT_MIN;
                        for (int i = 0; i < 3; i++) { // Iterate over activities for the current day
                            if (i != last) { // Choose a different activity from 'last'
                                int points = arr[day][i] + dp[day - 1][i];
                                dp[day][last] = max(dp[day][last], points);
                            }
                        }
                    }
                }

                // The result is the maximum points on the last day with any 'last' activity
                return dp[n - 1][3];
            }
        // Space Optimization
            int ninjaTraining(int n, vector<vector<int>>& arr) {
                // Previous day vector to store max points for activities on the previous day
                vector<int> prev(4, 0);

                // Base case initialization (day 0)
                prev[0] = max(arr[0][1], arr[0][2]); // If last activity was 0
                prev[1] = max(arr[0][0], arr[0][2]); // If last activity was 1
                prev[2] = max(arr[0][0], arr[0][1]); // If last activity was 2
                prev[3] = max({arr[0][0], arr[0][1], arr[0][2]}); // No previous activity

                // Iterate over days starting from day 1
                for (int day = 1; day < n; day++) {
                    vector<int> curr(4, 0); // Current day's maximum points for each 'last' state
                    for (int last = 0; last < 4; last++) {
                        curr[last] = INT_MIN;
                        for (int i = 0; i < 3; i++) {
                            if (i != last) { // Ensure different activity is chosen from 'last'
                                int points = arr[day][i] + prev[i];
                                curr[last] = max(curr[last], points);
                            }
                        }
                    }
                    prev = curr; // Move to the next day
                }

                // The result is the maximum points on the last day with any 'last' activity
                return prev[3];
            }
    // Total Unique Path from (0,0) to (m-1,n-1)
        // Memoization
            int uniquePathsMemo(int m, int n, int i, int j, vector<vector<int>>& dp) {
                // Base case: If we reach the bottom-right cell
                if (i == m - 1 && j == n - 1) return 1;
                // If we go out of bounds
                if (i >= m || j >= n) return 0;
                // If the result is already computed
                if (dp[i][j] != -1) return dp[i][j];

                // Recursively calculate unique paths by moving right and down
                return dp[i][j] = uniquePathsMemo(m, n, i + 1, j, dp) + uniquePathsMemo(m, n, i, j + 1, dp);
            }
        // Tabulation
            int uniquePathsTabulation(int m, int n) {
                vector<vector<int>> dp(m, vector<int>(n, 0));

                // Base case: There is only one way to reach cells in the first row or first column
                for (int i = 0; i < m; i++) dp[i][0] = 1;
                for (int j = 0; j < n; j++) dp[0][j] = 1;

                // Fill the dp table
                for (int i = 1; i < m; i++) {
                    for (int j = 1; j < n; j++) {
                        dp[i][j] = dp[i - 1][j] + dp[i][j - 1]; // Sum of paths from top and left
                    }
                }

                return dp[m - 1][n - 1]; // Bottom-right cell has the answer
            }
        // Space Optimized
            int uniquePathsSpaceOptimized(int m, int n) {
                vector<int> prev(n, 1); // Initialize a 1D array for the previous row

                for (int i = 1; i < m; i++) {
                    vector<int> curr(n, 1); // Current row
                    for (int j = 1; j < n; j++) {
                        curr[j] = prev[j] + curr[j - 1]; // Paths from top (prev[j]) and left (curr[j-1])
                    }
                    prev = curr; // Move to the next row
                }

                return prev[n - 1]; // Result is in the last cell
            }

    // Total Unique Path from (0,0) to (m-1,n-1) With Obstacle
        // Memoization
            int uniquePathsWithObstaclesMemo(int m, int n, int i, int j, vector<vector<int>>& obstacleGrid, vector<vector<int>>& dp) {
                // Base cases
                if (i >= m || j >= n || obstacleGrid[i][j] == 1) return 0; // Out of bounds or obstacle
                if (i == m - 1 && j == n - 1) return 1; // Reached the bottom-right corner

                // If the result is already computed
                if (dp[i][j] != -1) return dp[i][j];

                // Recursively calculate unique paths by moving right and down
                return dp[i][j] = uniquePathsWithObstaclesMemo(m, n, i + 1, j, obstacleGrid, dp) +
                                uniquePathsWithObstaclesMemo(m, n, i, j + 1, obstacleGrid, dp);
            }
        // Tabulation
            int uniquePathsWithObstaclesTabulation(vector<vector<int>>& obstacleGrid) {
                int m = obstacleGrid.size(), n = obstacleGrid[0].size();
                vector<vector<int>> dp(m, vector<int>(n, 0));

                // Base case initialization
                for (int i = 0; i < m && obstacleGrid[i][0] == 0; i++) dp[i][0] = 1; // First column
                for (int j = 0; j < n && obstacleGrid[0][j] == 0; j++) dp[0][j] = 1; // First row

                // Fill the dp table
                for (int i = 1; i < m; i++) {
                    for (int j = 1; j < n; j++) {
                        if (obstacleGrid[i][j] == 0) { // Only proceed if there is no obstacle
                            dp[i][j] = dp[i - 1][j] + dp[i][j - 1];
                        }
                    }
                }

                return dp[m - 1][n - 1]; // Bottom-right cell has the answer
            }
        // Space Optimization
            int uniquePathsWithObstaclesSpaceOptimized(vector<vector<int>>& obstacleGrid) {
                int m = obstacleGrid.size(), n = obstacleGrid[0].size();
                vector<int> dp(n, 0);

                // Base case initialization for the first row
                dp[0] = obstacleGrid[0][0] == 0 ? 1 : 0;

                // Fill the dp array
                for (int i = 0; i < m; i++) {
                    for (int j = 0; j < n; j++) {
                        if (obstacleGrid[i][j] == 1) {
                            dp[j] = 0; // If there's an obstacle, no paths lead to this cell
                        } else if (j > 0) {
                            dp[j] += dp[j - 1]; // Add paths from the left cell
                        }
                    }
                }

                return dp[n - 1]; // Result is in the last cell
            }
    // Min Path Sum in a Grid
        // Memoization
            int minPathSumMemo(int m, int n, vector<vector<int>>& grid, vector<vector<int>>& dp) {
                // Base case: When at the starting cell
                if (m == 0 && n == 0) return grid[0][0];
                // If out of bounds
                if (m < 0 || n < 0) return INT_MAX;

                // If the result for this state has already been computed
                if (dp[m][n] != -1) return dp[m][n];

                // Recursively find the minimum path sum by moving up or left
                int up = minPathSumMemo(m - 1, n, grid, dp);
                int left = minPathSumMemo(m, n - 1, grid, dp);

                // Store and return the minimum path sum at this cell
                return dp[m][n] = grid[m][n] + min(up, left);
            }
        // Tabulation
            int minPathSumTabulation(vector<vector<int>>& grid) {
                int m = grid.size();
                int n = grid[0].size();
                vector<vector<int>> dp(m, vector<int>(n, 0));

                // Base case: Initialize the starting point
                dp[0][0] = grid[0][0];

                // Initialize the first row
                for (int j = 1; j < n; j++) {
                    dp[0][j] = dp[0][j - 1] + grid[0][j];
                }

                // Initialize the first column
                for (int i = 1; i < m; i++) {
                    dp[i][0] = dp[i - 1][0] + grid[i][0];
                }

                // Fill the dp table
                for (int i = 1; i < m; i++) {
                    for (int j = 1; j < n; j++) {
                        dp[i][j] = grid[i][j] + min(dp[i - 1][j], dp[i][j - 1]);
                    }
                }

                return dp[m - 1][n - 1];
            }

        // space_optimization
            int minPathSumOptimized(vector<vector<int>>& grid) {
                int m = grid.size();
                int n = grid[0].size();
                vector<int> dp(n, 0);  // Stores results for the previous row
                vector<int> curr(n, 0); // Stores results for the current row

                // Initialize the first row
                dp[0] = grid[0][0];
                for (int j = 1; j < n; j++) {
                    dp[j] = dp[j - 1] + grid[0][j];
                }

                // Fill dp and curr arrays for each row
                for (int i = 1; i < m; i++) {
                    curr[0] = dp[0] + grid[i][0]; // Update the first column for the current row
                    for (int j = 1; j < n; j++) {
                        curr[j] = grid[i][j] + min(dp[j], curr[j - 1]);
                    }
                    dp = curr; // Move current row results to dp for the next iteration
                }

                return dp[n - 1];
            }
    // Triangle
        // Memoization
            int minPathSumMemo(int i, int j, vector<vector<int>>& triangle, vector<vector<int>>& dp) {
                // Base case: if we reach the last row
                if (i == triangle.size() - 1) return triangle[i][j];

                // If the subproblem is already solved
                if (dp[i][j] != -1) return dp[i][j];

                // Recursive relation to find the minimum path sum from (i, j)
                int down = triangle[i][j] + minPathSumMemo(i + 1, j, triangle, dp);
                int diag = triangle[i][j] + minPathSumMemo(i + 1, j + 1, triangle, dp);

                return dp[i][j] = min(down, diag);
            }
        // Tabulation
            int minPathSumTabulation(vector<vector<int>>& triangle) {
                int n = triangle.size();
                vector<vector<int>> dp(n, vector<int>(n, 0));

                // Initialize the last row of the dp table
                for (int j = 0; j < n; j++) {
                    dp[n - 1][j] = triangle[n - 1][j];
                }

                // Fill the dp table from bottom to top
                for (int i = n - 2; i >= 0; i--) {
                    for (int j = 0; j <= i; j++) {
                        int d = triangle[i][j] + dp[i + 1][j];
                        int dg = triangle[i][j] + dp[i + 1][j + 1];
                        dp[i][j] = min(d, dg);
                    }
                }

                // The result is stored at the top of the triangle
                return dp[0][0];
            }
        // Space Optimization
            int minPathSumSpaceOptimized(vector<vector<int>>& triangle) {
                int n = triangle.size();
                vector<int> front(n, 0);
                vector<int> curr(n, 0);
                // Initialize dp with the last row of the triangle
                for (int j = 0; j < n; j++) {
                    front[j] = triangle[n - 1][j];
                }
                // Fill front from bottom to top
                for (int i = n - 2; i >= 0; i--) {
                    for (int j = 0; j <= i; j++) {
                        int d = triangle[i][j] + front[j];
                        int dg = triangle[i][j] + front[j + 1];
                        curr[j] = min(d, dg);
                    }
                    front = curr
                }

                return front[0]; // The result is stored at the top of the triangle
            }
    // Minimum & Maximum Falling path sum
        // memoization
            // Helper function for memoization
            int maxFallingPathSumFromBottom(int i, int j, vector<vector<int>>& matrix, vector<vector<int>>& dp) {
                int n = matrix.size();
                int m = matrix[0].size();

                // Base case: If we reach the first row, return the value at (i, j)
                if (i == 0) return matrix[i][j];

                // If the result is already computed
                if (dp[i][j] != -1) return dp[i][j];

                // Move to the cell above
                int up = matrix[i][j] + maxFallingPathSumFromBottom(i - 1, j, matrix, dp);
                int ldg = matrix[i][j] + maxFallingPathSumFromBottom(i - 1, j - 1, matrix, dp);
                int rdg = matrix[i][j] + maxFallingPathSumFromBottom(i - 1, j + 1, matrix, dp);
                // Store the result in dp array
                return dp[i][j] = max(up, max(ldg, rdg));
            }

            int maxFallingPathSum(vector<vector<int>>& matrix) {
                int n = matrix.size();
                int m = matrix[0].size();
                vector<vector<int>> dp(n, vector<int>(m, -1));

                // Compute the maximum path sum ending at any cell in the last row
                int result = INT_MIN;
                for (int j = 0; j < m; j++) {
                    result = max(result, maxFallingPathSumFromBottom(n - 1, j, matrix, dp));
                }
                return result;
            }
        // Tabulation
            int maxFallingPathSum(vector<vector<int>>& matrix) {
                int n = matrix.size();
                int m = matrix[0].size();

                // dp table to store the maximum falling path sum for each cell
                vector<vector<int>> dp(n, vector<int>(m, 0));

                // Initialize the first row of dp with the values from the matrix
                for (int j = 0; j < m; j++) {
                    dp[0][j] = matrix[0][j];
                }

                // Fill the dp table from the second row to the last row
                for (int i = 1; i < n; i++) {
                    for (int j = 0; j < m; j++) {
                        // Calculate the maximum falling path sum for cell (i, j)
                        int up = matrix[i][j] + dp[i - 1][j]; // directly above
                        int ldg = matrix[i][j] + ((j > 0) ? dp[i - 1][j - 1] : INT_MIN); // above-left
                        int rdg = matrix[i][j] + ((j < m - 1) ? dp[i - 1][j + 1] : INT_MIN); // above-right
                        dp[i][j] = max(up, max(ldg, rdg));
                    }
                }

                // The result is the maximum value in the last row of dp
                int result = INT_MIN;
                for (int j = 0; j < m; j++) {
                    result = max(result, dp[n - 1][j]);
                }

                return result;
            }
        // Space optimization
            int maxFallingPathSum(vector<vector<int>>& matrix) {
                int n = matrix.size();
                int m = matrix[0].size();

                // dp array to store the maximum falling path sum for each cell in the current row
                vector<int> dp(m, 0);

                // Initialize the dp array with the first row of the matrix
                for (int j = 0; j < m; j++) {
                    dp[j] = matrix[0][j];
                }

                // Fill the dp array from the second row to the last row
                for (int i = 1; i < n; i++) {
                    // Create a temporary array to store the previous row values
                    vector<int> temp(m, 0);
                    
                    for (int j = 0; j < m; j++) {
                        // Calculate the maximum falling path sum for cell (i, j)
                        int up = matrix[i][j] + dp[j]; // directly above
                        int ldg = matrix[i][j] + ((j > 0) ? dp[j - 1] : INT_MIN); // above-left
                        int rdg = matrix[i][j] + ((j < m - 1) ? dp[j + 1] : INT_MIN); // above-right
                        
                        // Store the maximum of the three values in the temp array
                        temp[j] = max(up, max(ldg, rdg));
                    }

                    // Update dp with the newly computed values from the temp array
                    dp = temp;
                }

                // The result is the maximum value in the last row of dp
                int result = INT_MIN;
                for (int j = 0; j < m; j++) {
                    result = max(result, dp[j]);
                }

                return result;
            }
    // Cherry Pickup II - Ninja and his Friends (3D DP)
        // Memoization
            int maxChocoUtil(int i, int j1, int j2, int n, int m, vector<vector<int>> &grid, vector<vector<vector<int>>> &dp) {
                // Check if the positions (j1, j2) are valid
                if (j1 < 0 || j1 >= m || j2 < 0 || j2 >= m)
                    return -1e9; // A very large negative value to represent an invalid position

                // Base case: If we are at the last row, return the chocolate at the positions (j1, j2)
                if (i == n - 1) {
                    if (j1 == j2)
                        return grid[i][j1];
                    else
                        return grid[i][j1] + grid[i][j2];
                }

                // If the result for this state is already computed, return it
                if (dp[i][j1][j2] != -1)
                    return dp[i][j1][j2];

                int maxi = INT_MIN;
                
                // Try all possible moves (up, left, right) for both positions (j1, j2)
                for (int di = -1; di <= 1; di++) {
                    for (int dj = -1; dj <= 1; dj++) {
                        int ans;
                        
                        if (j1 == j2)
                            ans = grid[i][j1] + maxChocoUtil(i + 1, j1 + di, j2 + dj, n, m, grid, dp);
                        else
                            ans = grid[i][j1] + grid[i][j2] + maxChocoUtil(i + 1, j1 + di, j2 + dj, n, m, grid, dp);
                        
                        // Update the maximum result
                        maxi = max(maxi, ans);
                    }
                }
                
                // Store the maximum result for this state in dp
                return dp[i][j1][j2] = maxi;
            }

        // Tabulation
            int maximumChocolates(int n, int m, vector<vector<int>> &grid) {
                // Create a 3D DP array to store computed results
                vector<vector<vector<int>>> dp(n, vector<vector<int>>(m, vector<int>(m, 0)));

                // Initialize the DP array for the last row
                for (int j1 = 0; j1 < m; j1++) {
                    for (int j2 = 0; j2 < m; j2++) {
                        if (j1 == j2)
                            dp[n - 1][j1][j2] = grid[n - 1][j1];
                        else
                            dp[n - 1][j1][j2] = grid[n - 1][j1] + grid[n - 1][j2];
                    }
                }

                // Outer nested loops for traversing the DP array from the second-to-last row up to the first row
                for (int i = n - 2; i >= 0; i--) {
                    for (int j1 = 0; j1 < m; j1++) {
                        for (int j2 = 0; j2 < m; j2++) {
                            int maxi = INT_MIN;

                            // Inner nested loops to try out 9 options (diagonal moves)
                            for (int di = -1; di <= 1; di++) {
                                for (int dj = -1; dj <= 1; dj++) {
                                    int ans;

                                    if (j1 == j2)
                                        ans = grid[i][j1];
                                    else
                                        ans = grid[i][j1] + grid[i][j2];

                                    // Check if the move is valid (within the grid boundaries)
                                    if ((j1 + di < 0 || j1 + di >= m) || (j2 + dj < 0 || j2 + dj >= m))
                                        ans += -1e9; // A very large negative value to represent an invalid move
                                    else
                                        ans += dp[i + 1][j1 + di][j2 + dj]; // Include the DP result from the next row

                                    maxi = max(ans, maxi); // Update the maximum result
                                }
                            }
                            dp[i][j1][j2] = maxi; // Store the maximum result for this state in the DP array
                        }
                    }
                }

                // The maximum chocolates that can be collected is stored at the top-left corner of the DP array
                return dp[0][0][m - 1];
            }
        // Space Optimization
            int maximumChocolates(int n, int m, vector<vector<int>> &grid) {
                // Create two 2D vectors 'front' and 'cur' to store computed results
                vector<vector<int>> front(m, vector<int>(m, 0));
                vector<vector<int>> cur(m, vector<int>(m, 0));

                // Initialize 'front' for the last row
                for (int j1 = 0; j1 < m; j1++) {
                    for (int j2 = 0; j2 < m; j2++) {
                        if (j1 == j2)
                            front[j1][j2] = grid[n - 1][j1];
                        else
                            front[j1][j2] = grid[n - 1][j1] + grid[n - 1][j2];
                    }
                }

                // Outer nested loops for traversing the DP array from the second-to-last row up to the first row
                for (int i = n - 2; i >= 0; i--) {
                    for (int j1 = 0; j1 < m; j1++) {
                        for (int j2 = 0; j2 < m; j2++) {
                            int maxi = INT_MIN;

                            // Inner nested loops to try out 9 options (diagonal moves)
                            for (int di = -1; di <= 1; di++) {
                                for (int dj = -1; dj <= 1; dj++) {
                                    int ans;

                                    if (j1 == j2)
                                        ans = grid[i][j1];
                                    else
                                        ans = grid[i][j1] + grid[i][j2];

                                    // Check if the move is valid (within the grid boundaries)
                                    if ((j1 + di < 0 || j1 + di >= m) || (j2 + dj < 0 || j2 + dj >= m))
                                        ans += -1e9; // A very large negative value to represent an invalid move
                                    else
                                        ans += front[j1 + di][j2 + dj]; // Include the value from the 'front' array

                                    maxi = max(ans, maxi); // Update the maximum result
                                }
                            }
                            cur[j1][j2] = maxi; // Store the maximum result for this state in the 'cur' array
                        }
                    }
                    front = cur; // Update 'front' with the values from 'cur' for the next iteration
                }

                // The maximum chocolates that can be collected is stored at the top-left corner of the 'front' array
                return front[0][m - 1];
            }

    // DP ON SubSeqence
    // Subset Sum Equal to Target
        // Memoization
            // Function to check if there is a subset of 'arr' with a sum equal to 'target'
            bool subsetSumUtil(int ind, int target, vector<int>& arr, vector<vector<int>>& dp) {
                // If the target sum is 0, we have found a subset
                if (target == 0)
                    return true;

                // If we have reached the first element in 'arr'
                if (ind == 0)
                    return arr[0] == target;

                // If the result for this subproblem has already been computed, return it
                if (dp[ind][target] != -1)
                    return dp[ind][target];

                // Try not taking the current element into the subset
                bool notTaken = subsetSumUtil(ind - 1, target, arr, dp);

                // Try taking the current element into the subset if it doesn't exceed the target
                bool taken = false;
                if (arr[ind] <= target)
                    taken = subsetSumUtil(ind - 1, target - arr[ind], arr, dp);

                // Store the result in the dp array to avoid recomputation
                return dp[ind][target] = notTaken || taken;
            }
        // Tabulation
            bool subsetSumToK(int n, int k, vector<int> &arr) {
                // Initialize a 2D DP array with dimensions (n x k+1) to store subproblem results
                vector<vector<bool>> dp(n, vector<bool>(k + 1, false));

                // Base case: If the target sum is 0, we can always achieve it by taking no elements
                for (int i = 0; i < n; i++) {
                    dp[i][0] = true;
                }

                // Base case: If the first element of 'arr' is less than or equal to 'k', set dp[0][arr[0]] to true
                if (arr[0] <= k) {
                    dp[0][arr[0]] = true;
                }

                // Fill the DP array iteratively
                for (int ind = 1; ind < n; ind++) {
                    for (int target = 1; target <= k; target++) {
                        // If we don't take the current element, the result is the same as the previous row
                        bool notTaken = dp[ind - 1][target];

                        // If we take the current element, subtract its value from the target and check the previous row
                        bool taken = false;
                        if (arr[ind] <= target) {
                            taken = dp[ind - 1][target - arr[ind]];
                        }

                        // Store the result in the DP array for the current subproblem
                        dp[ind][target] = notTaken || taken;
                    }
                }

                // The final result is stored in dp[n-1][k]
                return dp[n - 1][k];
            }
        // Space OPtimization
            bool subsetSumToK(int n, int k, vector<int> &arr) {
                // Initialize a vector 'prev' to store the previous row of the DP table
                vector<bool> prev(k + 1, false);

                // Base case: If the target sum is 0, we can always achieve it by taking no elements
                prev[0] = true;

                // Base case: If the first element of 'arr' is less than or equal to 'k', set prev[arr[0]] to true
                if (arr[0] <= k) {
                    prev[arr[0]] = true;
                }

                // Iterate through the elements of 'arr' and update the DP table
                for (int ind = 1; ind < n; ind++) {
                    // Initialize a new row 'cur' to store the current state of the DP table
                    vector<bool> cur(k + 1, false);

                    // Base case: If the target sum is 0, we can achieve it by taking no elements
                    cur[0] = true;

                    for (int target = 1; target <= k; target++) {
                        // If we don't take the current element, the result is the same as the previous row
                        bool notTaken = prev[target];

                        // If we take the current element, subtract its value from the target and check the previous row
                        bool taken = false;
                        if (arr[ind] <= target) {
                            taken = prev[target - arr[ind]];
                        }

                        // Store the result in the current DP table row for the current subproblem
                        cur[target] = notTaken || taken;
                    }

                    // Update 'prev' with the current row 'cur' for the next iteration
                    prev = cur;
                }

                // The final result is stored in prev[k]
                return prev[k];
            }

    // Partition Equal Subset Sum
        // Memoization.
            bool subsetSumUtil(int ind, int target, vector<int>& arr, vector<vector<int>>& dp) {
                // Base case: If the target sum is 0, we found a valid partition
                if (target == 0)
                    return true;

                // Base case: If we have considered all elements and the target is still not 0, return false
                if (ind == 0)
                    return arr[0] == target;

                // If the result for this state is already calculated, return it
                if (dp[ind][target] != -1)
                    return dp[ind][target];

                // Recursive cases
                // 1. Exclude the current element
                bool notTaken = subsetSumUtil(ind - 1, target, arr, dp);

                // 2. Include the current element if it doesn't exceed the target
                bool taken = false;
                if (arr[ind] <= target)
                    taken = subsetSumUtil(ind - 1, target - arr[ind], arr, dp);

                // Store the result in the DP table and return
                return dp[ind][target] = notTaken || taken;
            }
            // Function to check if the array can be partitioned into two equal subsets
            bool canPartition(int n, vector<int>& arr) {
                int totSum = 0;

                // Calculate the total sum of the array
                for (int i = 0; i < n; i++) {
                    totSum += arr[i];
                }

                // If the total sum is odd, it cannot be partitioned into two equal subsets
                if (totSum % 2 == 1)
                    return false;
                else {
                    int k = totSum / 2;

                    // Create a DP table with dimensions n x k+1 and initialize with -1
                    vector<vector<int>> dp(n, vector<int>(k + 1, -1));

                    // Call the subsetSumUtil function to check if it's possible to partition
                    return subsetSumUtil(n - 1, k, arr, dp);
                }
            }
        // Tabulation
            bool canPartition(int n, vector<int>& arr) {
                int totSum = 0;

                // Calculate the total sum of the array
                for (int i = 0; i < n; i++) {
                    totSum += arr[i];
                }

                // If the total sum is odd, it cannot be partitioned into two equal subsets
                if (totSum % 2 == 1)
                    return false;
                else {
                    int k = totSum / 2;

                    // Create a DP table with dimensions n x k+1, initialized with false
                    vector<vector<bool>> dp(n, vector<bool>(k + 1, false));

                    // Base case: If the target sum is 0, it can be achieved by not selecting any elements
                    for (int i = 0; i < n; i++) {
                        dp[i][0] = true;
                    }

                    // Initialize the first row based on the first element of the array
                    if (arr[0] <= k)
                        dp[0][arr[0]] = true;

                    // Fill in the DP table using a bottom-up approach
                    for (int ind = 1; ind < n; ind++) {
                        for (int target = 1; target <= k; target++) {
                            // Exclude the current element
                            bool notTaken = dp[ind - 1][target];

                            // Include the current element if it doesn't exceed the target
                            bool taken = false;
                            if (arr[ind] <= target)
                                taken = dp[ind - 1][target - arr[ind]];

                            // Update the DP table
                            dp[ind][target] = notTaken || taken;
                        }
                    }

                    // The final result is in the last cell of the DP table
                    return dp[n - 1][k];
                }
            }
        // Space Optimization
            // Function to check if it's possible to partition the array into two subsets with equal sum
            bool canPartition(int n, vector<int>& arr) {
                int totSum = 0;

                // Calculate the total sum of the array
                for (int i = 0; i < n; i++) {
                    totSum += arr[i];
                }

                // If the total sum is odd, it cannot be partitioned into two equal subsets
                if (totSum % 2 == 1)
                    return false;
                else {
                    int k = totSum / 2;

                    // Create a vector to represent the previous row of the DP table
                    vector<bool> prev(k + 1, false);

                    // Base case: If the target sum is 0, it can be achieved by not selecting any elements
                    prev[0] = true;

                    // Initialize the first row based on the first element of the array
                    if (arr[0] <= k)
                        prev[arr[0]] = true;

                    // Fill in the DP table using a bottom-up approach
                    for (int ind = 1; ind < n; ind++) {
                        // Create a vector to represent the current row of the DP table
                        vector<bool> cur(k + 1, false);
                        cur[0] = true;

                        for (int target = 1; target <= k; target++) {
                            // Exclude the current element
                            bool notTaken = prev[target];

                            // Include the current element if it doesn't exceed the target
                            bool taken = false;
                            if (arr[ind] <= target)
                                taken = prev[target - arr[ind]];

                            // Update the current row of the DP table
                            cur[target] = notTaken || taken;
                        }

                        // Set the current row as the previous row for the next iteration
                        prev = cur;
                    }

                    // The final result is in the last cell of the previous row of the DP table
                    return prev[k];
                }
            }
    // Partition A Set Into Two Subsets With Minimum Absolute Sum Difference | S1-s2 = D
        // Memoization
            // Function to solve the subset sum problem with memoization
            bool subsetSumUtil(int ind, int target, vector<int>& arr, vector<vector<int>>& dp) {
                // Base case: If the target sum is 0, return true
                if (target == 0)
                    return dp[ind][target] = true;

                // Base case: If we have considered all elements and the target is still not 0, return false
                if (ind == 0)
                    return dp[ind][target] = (arr[0] == target);

                // If the result for this state is already calculated, return it
                if (dp[ind][target] != -1)
                    return dp[ind][target];

                // Recursive cases
                // 1. Exclude the current element
                bool notTaken = subsetSumUtil(ind - 1, target, arr, dp);

                // 2. Include the current element if it doesn't exceed the target
                bool taken = false;
                if (arr[ind] <= target)
                    taken = subsetSumUtil(ind - 1, target - arr[ind], arr, dp);

                // Store the result in the DP table and return
                return dp[ind][target] = notTaken || taken;
            }
            // Function to find the minimum absolute difference between two subset sums
            int minSubsetSumDifference(vector<int>& arr, int n) {
                int totSum = 0;

                // Calculate the total sum of the array
                for (int i = 0; i < n; i++) {
                    totSum += arr[i];
                }

                // Initialize a DP table to store the results of the subset sum problem
                vector<vector<int>> dp(n, vector<int>(totSum + 1, -1));

                // Calculate the subset sum for each possible sum from 0 to the total sum
                for (int i = 0; i <= totSum; i++) {
                    bool dummy = subsetSumUtil(n - 1, i, arr, dp);
                }

                int mini = 1e9;
                for (int i = 0; i <= totSum; i++) {
                    if (dp[n - 1][i] == true) {
                        int diff = abs(i - (totSum - i));
                        mini = min(mini, diff);
                    }
                }
                return mini;
            }
        // Tabulation
            int minSubsetSumDifference(vector<int>& arr, int n) {
                int totSum = 0;

                // Calculate the total sum of the array
                for (int i = 0; i < n; i++) {
                    totSum += arr[i];
                }

                // Initialize a DP table to store the results of the subset sum problem
                vector<vector<bool>> dp(n, vector<bool>(totSum + 1, false));

                // Base case: If no elements are selected (sum is 0), it's a valid subset
                for (int i = 0; i < n; i++) {
                    dp[i][0] = true;
                }

                // Initialize the first row based on the first element of the array
                if (arr[0] <= totSum)
                    dp[0][totSum] = true;

                // Fill in the DP table using a bottom-up approach
                for (int ind = 1; ind < n; ind++) {
                    for (int target = 1; target <= totSum; target++) {
                        // Exclude the current element
                        bool notTaken = dp[ind - 1][target];

                        // Include the current element if it doesn't exceed the target
                        bool taken = false;
                        if (arr[ind] <= target)
                            taken = dp[ind - 1][target - arr[ind]];

                        dp[ind][target] = notTaken || taken;
                    }
                }

                int mini = 1e9;
                for (int i = 0; i <= totSum; i++) {
                    if (dp[n - 1][i] == true) {
                        // Calculate the absolute difference between two subset sums
                        int diff = abs(i - (totSum - i));
                        mini = min(mini, diff);
                    }
                }
                return mini;
            }
        // Space Optimization
            int minSubsetSumDifference(vector<int>& arr, int n) {
                int totSum = 0;

                // Calculate the total sum of the array
                for (int i = 0; i < n; i++) {
                    totSum += arr[i];
                }

                // Initialize a boolean vector 'prev' to represent the previous row of the DP table
                vector<bool> prev(totSum + 1, false);

                // Base case: If no elements are selected (sum is 0), it's a valid subset
                prev[0] = true;

                // Initialize the first row based on the first element of the array
                if (arr[0] <= totSum)
                    prev[arr[0]] = true;

                // Fill in the DP table using a bottom-up approach
                for (int ind = 1; ind < n; ind++) {
                    // Create a boolean vector 'cur' to represent the current row of the DP table
                    vector<bool> cur(totSum + 1, false);
                    cur[0] = true;

                    for (int target = 1; target <= totSum; target++) {
                        // Exclude the current element
                        bool notTaken = prev[target];

                        // Include the current element if it doesn't exceed the target
                        bool taken = false;
                        if (arr[ind] <= target)
                            taken = prev[target - arr[ind]];

                        cur[target] = notTaken || taken;
                    }

                    // Set 'cur' as the 'prev' for the next iteration
                    prev = cur;
                }

                int mini = 1e9;
                for (int i = 0; i <= totSum; i++) {
                    if (prev[i] == true) {
                        // Calculate the absolute difference between two subset sums
                        int diff = abs(i - (totSum - i));
                        mini = min(mini, diff);
                    }
                }
                return mini;
            }
    // Counts Subsets with Sum K 
        // Memoization
            int findWaysUtil(int ind, int target, vector<int>& arr, vector<vector<int>>& dp) {
                // Base case: If the target sum is 0, we found a valid subset
                if (target == 0)
                    return 1;

                // Base case: If we have considered all elements and the target is still not 0, return 0
                if (ind == 0)
                    return (arr[0] == target) ? 1 : 0;

                // If the result for this state is already calculated, return it
                if (dp[ind][target] != -1)
                    return dp[ind][target];

                // Recursive cases
                // 1. Exclude the current element
                int notTaken = findWaysUtil(ind - 1, target, arr, dp);

                // 2. Include the current element if it doesn't exceed the target
                int taken = 0;
                if (arr[ind] <= target)
                    taken = findWaysUtil(ind - 1, target - arr[ind], arr, dp);

                // Store the result in the DP table and return
                return dp[ind][target] = notTaken + taken;
            }
            // Function to count the number of subsets with a given sum
            int findWays(vector<int>& num, int k) {
                int n = num.size();
                vector<vector<int>> dp(n, vector<int>(k + 1, -1));
                return findWaysUtil(n - 1, k, num, dp);
            }
        // Tabulation
            int findWays(vector<int>& num, int k) {
                int n = num.size();

                // Create a 2D DP table with dimensions n x k+1, initialized with zeros
                vector<vector<int>> dp(n, vector<int>(k + 1, 0));

                // Base case: If the target sum is 0, there is one valid subset (the empty subset)
                for (int i = 0; i < n; i++) {
                    dp[i][0] = 1;
                }

                // Initialize the first row based on the first element of the array
                if (num[0] <= k) {
                    dp[0][num[0]] = 1;
                }

                // Fill in the DP table using a bottom-up approach
                for (int ind = 1; ind < n; ind++) {
                    for (int target = 1; target <= k; target++) {
                        // Exclude the current element
                        int notTaken = dp[ind - 1][target];

                        // Include the current element if it doesn't exceed the target
                        int taken = 0;
                        if (num[ind] <= target) {
                            taken = dp[ind - 1][target - num[ind]];
                        }

                        // Update the DP table
                        dp[ind][target] = notTaken + taken;
                    }
                }

                // The final result is in the last cell of the DP table
                return dp[n - 1][k];
            }
        // Space Optimization
            int findWays(vector<int>& num, int k) {
                int n = num.size();

                // Initialize a vector 'prev' to represent the previous row of the DP table
                vector<int> prev(k + 1, 0);

                // Base case: If the target sum is 0, there is one valid subset (the empty subset)
                prev[0] = 1;

                // Initialize the first row based on the first element of the array
                if (num[0] <= k) {
                    prev[num[0]] = 1;
                }

                // Fill in the DP table using a bottom-up approach
                for (int ind = 1; ind < n; ind++) {
                    // Create a vector 'cur' to represent the current row of the DP table
                    vector<int> cur(k + 1, 0);

                    cur[0] = 1;

                    for (int target = 1; target <= k; target++) {
                        // Exclude the current element
                        int notTaken = prev[target];

                        // Include the current element if it doesn't exceed the target
                        int taken = 0;
                        if (num[ind] <= target) {
                            taken = prev[target - num[ind]];
                        }

                        // Update the current row of the DP table
                        cur[target] = notTaken + taken;
                    }

                    // Set 'cur' as 'prev' for the next iteration
                    prev = cur;
                }

                // The final result is in the last cell of the 'prev' vector
                return prev[k];
            }
    // Count Partitions with Given Difference 
        // Memoization
            int mod =(int)1e9+7;
            int countPartitionsUtil(int ind, int target, vector<int>& arr, vector<vector <int>> &dp){
                if(ind == 0){
                    if(target==0 && arr[0]==0)
                        return 2;
                    if(target==0 || target == arr[0])
                        return 1;
                    return 0;
                }
                
                if(dp[ind][target]!=-1)
                    return dp[ind][target];
                    
                int notTaken = countPartitionsUtil(ind-1,target,arr,dp);
                
                int taken = 0;
                if(arr[ind]<=target)
                    taken = countPartitionsUtil(ind-1,target-arr[ind],arr,dp);
                    
                return dp[ind][target]= (notTaken + taken)%mod;
            }
            int countPartitions(int d, vector<int>& arr){
                int n = arr.size();
                int totSum = 0;
                for(int i=0; i<arr.size();i++){
                    totSum += arr[i];
                }
                
                //Checking for edge cases
                if(totSum-d<0) return 0;
                if((totSum-d)%2==1) return 0;
                
                int s2 = (totSum-d)/2;
                
                vector<vector<int>> dp(n,vector<int>(s2+1,-1));
                return countPartitionsUtil(n-1,s2,arr,dp);
            }
        // Tabulation
            int mod =(int)1e9+7;
            int findWays(vector<int> &num, int tar){
                int n = num.size();

                vector<vector<int>> dp(n,vector<int>(tar+1,0));
                
                if(num[0] == 0) dp[0][0] =2;  // 2 cases -pick and not pick
                else dp[0][0] = 1;  // 1 case - not pick
                
                if(num[0]!=0 && num[0]<=tar) dp[0][num[0]] = 1;  // 1 case -pick
                
                for(int ind = 1; ind<n; ind++){
                    for(int target= 0; target<=tar; target++){
                        
                        int notTaken = dp[ind-1][target];
                
                        int taken = 0;
                            if(num[ind]<=target)
                                taken = dp[ind-1][target-num[ind]];
                    
                        dp[ind][target]= (notTaken + taken)%mod;
                    }
                }
                return dp[n-1][tar];
            }
            int countPartitions(int n, int d, vector<int>& arr){
                int totSum = 0;
                for(int i=0; i<n;i++){
                    totSum += arr[i];
                }
                
                //Checking for edge cases
                if(totSum-d <0 || (totSum-d)%2 ) return 0;
                
                return findWays(arr,(totSum-d)/2);
            }
        // Space Optimization
            int mod =(int)1e9+7;
            int findWays(vector<int> &num, int tar){
                int n = num.size();

                vector<int> prev(tar+1,0);
                
                if(num[0] == 0) prev[0] =2;  // 2 cases -pick and not pick
                else prev[0] = 1;  // 1 case - not pick
                
                if(num[0]!=0 && num[0]<=tar) prev[num[0]] = 1;  // 1 case -pick
                
                for(int ind = 1; ind<n; ind++){
                    vector<int> cur(tar+1,0);
                    for(int target= 0; target<=tar; target++){
                        int notTaken = prev[target];
                
                        int taken = 0;
                            if(num[ind]<=target)
                                taken = prev[target-num[ind]];
                    
                        cur[target]= (notTaken + taken)%mod;
                    }
                    prev = cur;
                }
                return prev[tar];
            }
            int countPartitions(int n, int d, vector<int>& arr){
                int totSum = 0;
                for(int i=0; i<n;i++){
                    totSum += arr[i];
                }
                
                //Checking for edge cases
                if(totSum-d <0 || (totSum-d)%2 ) return 0;
                
                return findWays(arr,(totSum-d)/2);
            }
    // 0/1 Knapsack Problem ## IMP ##
        // Memoization
           int knapsackMemoization(int ind, int W, vector<int>& wt, vector<int>& val, vector<vector<int>>& dp) {
                if (ind == 0) {
                    return (wt[0] <= W) ? val[0] : 0;
                }
                if (dp[ind][W] != -1) {
                    return dp[ind][W];
                }

                // Option to not take the current item
                int non_take = 0 + knapsackMemoization(ind - 1, W, wt, val, dp);

                // Option to take the current item (only if it fits)
                int take = INT_MIN;
                if (wt[ind] <= W) {
                    take = val[ind] + knapsackMemoization(ind - 1, W - wt[ind], wt, val, dp);
                }

                return dp[ind][W] = max(take, non_take);
            }
        // Tabulation
            int knapsackTabulation(int W, vector<int>& wt, vector<int>& val) {
                int n = wt.size();
                vector<vector<int>> dp(n, vector<int>(W + 1, 0));

                // Base case initialization
                for (int w = 0; w <= W; w++) {
                    if (wt[0] <= w) {
                        dp[0][w] = val[0]; // If only one item is considered
                    }
                }

                // Build the dp table
                for (int ind = 1; ind < n; ind++) {
                    for (int w = 0; w <= W; w++) {
                        int non_take = 0 + dp[ind - 1][w]; // Option to not take the current item
                        int take = INT_MIN;
                        if (wt[ind] <= w) {
                            take = val[ind] + dp[ind - 1][w - wt[ind]]; // Option to take the item
                        }
                        dp[ind][w] = max(take, non_take);
                    }
                }

                return dp[n - 1][W];
            }
        // Space Optimization
            int knapsackTabulation(int W, vector<int>& wt, vector<int>& val) {
                int n = wt.size();
                vector<int> prev(W+1, 0);
                vector<int> cur(W+1, 0);
                vector<vector<int>> dp(n, vector<int>(W + 1, 0));

                // Base case initialization
                for (int w = 0; w <= W; w++) {
                    if (wt[0] <= w) {
                        prev[w] = val[0]; // If only one item is considered
                    }
                }

                // Build the dp table
                for (int ind = 1; ind < n; ind++) {
                    for (int w = 0; w <= W; w++) {
                        int non_take = 0 + prev[w]; // Option to not take the current item
                        int take = INT_MIN;
                        if (wt[ind] <= w) {
                            take = val[ind] + prev[w - wt[ind]]; // Option to take the item
                        }
                        curr[w] = max(take, non_take);
                    }
                    prev = curr;
                }

                return dp[n - 1][W];
            }
        // Space OPtimization (single row)
            int knapsackTabulation(int W, vector<int>& wt, vector<int>& val) {
                int n = wt.size();
                vector<int> prev(W + 1, 0);

                // Base case initialization
                for (int w = 0; w <= W; w++) {
                    if (wt[0] <= w) {
                        prev[w] = val[0]; // If only one item is considered
                    }
                }

                // Build the dp table using just the `prev` array
                for (int ind = 1; ind < n; ind++) {
                    for (int w = W; w >= 0; w--) {  // Traverse backwards to avoid overwriting needed values
                        int non_take = 0 + prev[w]; // Option to not take the current item
                        int take = INT_MIN;
                        if (wt[ind] <= w) {
                            take = val[ind] + prev[w - wt[ind]]; // Option to take the item
                        }
                        prev[w] = max(take, non_take);
                    }
                }

                return prev[W];
            }
    // Minimum Coins
        // Memoization
            // Function to calculate the minimum number of elements to form the target sum
            int minimumElementsUtil(vector<int>& arr, int ind, int T, vector<vector<int>>& dp){

                // Base case: If we're at the first element
                if(ind == 0){
                    // Check if the target sum is divisible by the first element
                    if(T % arr[0] == 0)
                        return T / arr[0]; // If yes, return the quotient as the answer
                    else
                        return 1e9; // Otherwise, return a very large value to indicate it's not possible
                }
                
                // If the result for this index and target sum is already calculated, return it
                if(dp[ind][T] != -1)
                    return dp[ind][T];
                    
                // Calculate the minimum elements needed without taking the current element
                int notTaken = 0 + minimumElementsUtil(arr, ind - 1, T, dp);
                
                // Calculate the minimum elements needed by taking the current element
                int taken = 1e9; // Initialize 'taken' to a very large value
                if(arr[ind] <= T)
                    taken = 1 + minimumElementsUtil(arr, ind, T - arr[ind], dp);
                    
                // Store the minimum of 'notTaken' and 'taken' in the DP array and return it
                return dp[ind][T] = min(notTaken, taken);
            }
            // Function to find the minimum number of elements needed to form the target sum
            int minimumElements(vector<int>& arr, int T){
                
                int n = arr.size();
                
                // Create a DP (Dynamic Programming) table with n rows and T+1 columns and initialize it with -1
                vector<vector<int>> dp(n, vector<int>(T + 1, -1));
                
                // Call the utility function to calculate the answer
                int ans =  minimumElementsUtil(arr, n - 1, T, dp);
                
                // If 'ans' is still very large, it means it's not possible to form the target sum
                if(ans >= 1e9)
                    return -1;
                return ans; // Return the minimum number of elements needed
            }
        // Tabulation
            // Function to find the minimum number of elements needed to form the target sum
            int minimumElements(vector<int>& arr, int T) {
                int n = arr.size();
                
                // Create a 2D DP (Dynamic Programming) table with n rows and T+1 columns
                vector<vector<int>> dp(n, vector<int>(T + 1, 0));
                
                // Initialize the first row of the DP table
                for (int i = 0; i <= T; i++) {
                    if (i % arr[0] == 0)
                        dp[0][i] = i / arr[0];
                    else
                        dp[0][i] = 1e9; // Set it to a very large value if not possible
                }
                
                // Fill the DP table using a bottom-up approach
                for (int ind = 1; ind < n; ind++) {
                    for (int target = 0; target <= T; target++) {
                        // Calculate the minimum elements needed without taking the current element
                        int notTake = dp[ind - 1][target];
                        
                        // Calculate the minimum elements needed by taking the current element
                        int take = 1e9; // Initialize 'take' to a very large value
                        if (arr[ind] <= target)
                            take = 1 + dp[ind][target - arr[ind]];
                            
                        // Store the minimum of 'notTake' and 'take' in the DP table
                        dp[ind][target] = min(notTake, take);
                    }
                }
                
                // The answer is in the bottom-right cell of the DP table
                int ans = dp[n - 1][T];
                
                // If 'ans' is still very large, it means it's not possible to form the target sum
                if (ans >= 1e9)
                    return -1;
                
                return ans; // Return the minimum number of elements needed
            }
        // Space Optimization
            // Function to find the minimum number of elements needed to form the target sum
            int minimumElements(vector<int>& arr, int T) {
                int n = arr.size();
                
                // Create two vectors to store the previous and current DP states
                vector<int> prev(T + 1, 0);
                vector<int> cur(T + 1, 0);
                
                // Initialize the first row of the DP table
                for (int i = 0; i <= T; i++) {
                    if (i % arr[0] == 0)
                        prev[i] = i / arr[0];
                    else
                        prev[i] = 1e9; // Set it to a very large value if not possible
                }
                
                // Fill the DP table using a bottom-up approach
                for (int ind = 1; ind < n; ind++) {
                    for (int target = 0; target <= T; target++) {
                        // Calculate the minimum elements needed without taking the current element
                        int notTake = prev[target];
                        
                        // Calculate the minimum elements needed by taking the current element
                        int take = 1e9; // Initialize 'take' to a very large value
                        if (arr[ind] <= target)
                            take = 1 + cur[target - arr[ind]];
                            
                        // Store the minimum of 'notTake' and 'take' in the current DP state
                        cur[target] = min(notTake, take);
                    }
                    // Update the previous DP state with the current state for the next iteration
                    prev = cur;
                }
                
                // The answer is in the last row of the DP table
                int ans = prev[T];
                
                // If 'ans' is still very large, it means it's not possible to form the target sum
                if (ans >= 1e9)
                    return -1;
                
                return ans; // Return the minimum number of elements needed
            }

    // Target Sum (Asign Signs [+ -]) | s1-s2 = Target
        // Memoization
            // Function to count partitions of the array into subsets with a given target sum
            int countPartitionsUtil(int ind, int target, vector<int>& arr, vector<vector<int>>& dp) {
                // Base cases
                if (ind == 0) {
                    if (target == 0 && arr[0] == 0)
                        return 2; // Two ways to partition: include or exclude the element
                    if (target == 0 || target == arr[0])
                        return 1; // One way to partition: include or exclude the element
                    return 0; // No way to partition
                }
                
                // If the result for this index and target sum is already calculated, return it
                if (dp[ind][target] != -1)
                    return dp[ind][target];
                    
                // Calculate the number of ways without taking the current element
                int notTaken = countPartitionsUtil(ind - 1, target, arr, dp);
                
                // Calculate the number of ways by taking the current element
                int taken = 0;
                if (arr[ind] <= target)
                    taken = countPartitionsUtil(ind - 1, target - arr[ind], arr, dp);
                    
                // Store the sum of ways in the DP array and return it
                return dp[ind][target] = (notTaken + taken);
            }
            // Function to count the number of ways to achieve the target sum
            int targetSum(int n, int target, vector<int>& arr) {
                int totSum = 0;
                for (int i = 0; i < arr.size(); i++) {
                    totSum += arr[i];
                }
                
                // Checking for edge cases
                if (totSum - target < 0)
                    return 0; // Not possible to achieve the target sum
                if ((totSum - target) % 2 == 1)
                    return 0; // The difference between the total sum and target sum must be even
                
                int s2 = (totSum - target) / 2; // Calculate the required sum for each subset
                
                vector<vector<int>> dp(n, vector<int>(s2 + 1, -1)); // Initialize DP table
                return countPartitionsUtil(n - 1, s2, arr, dp); // Call the helper function
            }
        // Tabulation
            const int mod = (int)1e9 + 7;
            // Function to count the number of ways to achieve the target sum
            int findWays(vector<int> &num, int tar) {
                int n = num.size();

                vector<vector<int>> dp(n, vector<int>(tar + 1, 0));

                if (num[0] == 0)
                    dp[0][0] = 2;  // 2 cases - pick and not pick
                else
                    dp[0][0] = 1;  // 1 case - not pick

                if (num[0] != 0 && num[0] <= tar)
                    dp[0][num[0]] = 1;  // 1 case - pick

                for (int ind = 1; ind < n; ind++) {
                    for (int target = 0; target <= tar; target++) {

                        int notTaken = dp[ind - 1][target];

                        int taken = 0;
                        if (num[ind] <= target)
                            taken = dp[ind - 1][target - num[ind]];

                        dp[ind][target] = (notTaken + taken) % mod;
                    }
                }
                return dp[n - 1][tar];
            }
            // Function to calculate the number of ways to achieve the target sum
            int targetSum(int n, int target, vector<int>& arr) {
                int totSum = 0;
                for (int i = 0; i < n; i++) {
                    totSum += arr[i];
                }

                // Checking for edge cases
                if (totSum - target < 0 || (totSum - target) % 2 != 0)
                    return 0;  // Not possible to achieve the target sum

                return findWays(arr, (totSum - target) / 2);
            }
        // Space Optimization
            const int mod = (int)1e9 + 7;
            // Function to count the number of ways to achieve the target sum
            int findWays(vector<int> &num, int tar) {
                int n = num.size();

                vector<int> prev(tar + 1, 0);

                if (num[0] == 0)
                    prev[0] = 2;  // 2 cases - pick and not pick
                else
                    prev[0] = 1;  // 1 case - not pick

                if (num[0] != 0 && num[0] <= tar)
                    prev[num[0]] = 1;  // 1 case - pick

                for (int ind = 1; ind < n; ind++) {
                    vector<int> cur(tar + 1, 0);
                    for (int target = 0; target <= tar; target++) {
                        int notTaken = prev[target];

                        int taken = 0;
                        if (num[ind] <= target)
                            taken = prev[target - num[ind]];

                        cur[target] = (notTaken + taken) % mod;
                    }
                    prev = cur;
                }
                return prev[tar];
            }
            // Function to calculate the number of ways to achieve the target sum
            int targetSum(int n, int target, vector<int>& arr) {
                int totSum = 0;
                for (int i = 0; i < n; i++) {
                    totSum += arr[i];
                }

                // Checking for edge cases
                if (totSum - target < 0 || (totSum - target) % 2 != 0)
                    return 0;  // Not possible to achieve the target sum

                return findWays(arr, (totSum - target) / 2);
            }
    // Coin Change II
        // Memoization
            // Function to count the number of ways to make change for a given target sum
            long countWaysToMakeChangeUtil(vector<int>& arr, int ind, int T, vector<vector<long>>& dp) {
                // Base case: if we're at the first element
                if (ind == 0) {
                    // Check if the target sum is divisible by the first element
                    return (T % arr[0] == 0);
                }
                
                // If the result for this index and target sum is already calculated, return it
                if (dp[ind][T] != -1)
                    return dp[ind][T];
                    
                // Calculate the number of ways without taking the current element
                long notTaken = countWaysToMakeChangeUtil(arr, ind - 1, T, dp);
                
                // Calculate the number of ways by taking the current element
                long taken = 0;
                if (arr[ind] <= T)
                    taken = countWaysToMakeChangeUtil(arr, ind, T - arr[ind], dp);
                    
                // Store the sum of ways in the DP table and return it
                return dp[ind][T] = notTaken + taken;
            }
            // Function to count the number of ways to make change for the target sum
            long countWaysToMakeChange(vector<int>& arr, int n, int T) {
                vector<vector<long>> dp(n, vector<long>(T + 1, -1)); // Create a DP table
                
                // Call the utility function to calculate the answer
                return countWaysToMakeChangeUtil(arr, n - 1, T, dp);
            }
        // Tabulation
            // Function to count the number of ways to make change for a given target sum
            long countWaysToMakeChange(vector<int>& arr, int n, int T) {
                vector<vector<long>> dp(n, vector<long>(T + 1, 0)); // Create a DP table

                // Initializing base condition
                for (int i = 0; i <= T; i++) {
                    if (i % arr[0] == 0)
                        dp[0][i] = 1;
                    // Else condition is automatically fulfilled,
                    // as dp array is initialized to zero
                }

                for (int ind = 1; ind < n; ind++) {
                    for (int target = 0; target <= T; target++) {
                        long notTaken = dp[ind - 1][target];

                        long taken = 0;
                        if (arr[ind] <= target)
                            taken = dp[ind][target - arr[ind]];

                        dp[ind][target] = notTaken + taken;
                    }
                }

                return dp[n - 1][T];
            }

        // Space Optimization
            // Function to count the number of ways to make change for a given target sum
            long countWaysToMakeChange(vector<int>& arr, int n, int T) {
                vector<long> prev(T + 1, 0);  // Create a vector to store the previous DP state

                // Initialize base condition
                for (int i = 0; i <= T; i++) {
                    if (i % arr[0] == 0)
                        prev[i] = 1;  // There is one way to make change for multiples of the first coin
                    // Else condition is automatically fulfilled,
                    // as the prev vector is initialized to zero
                }

                for (int ind = 1; ind < n; ind++) {
                    vector<long> cur(T + 1, 0);  // Create a vector to store the current DP state
                    for (int target = 0; target <= T; target++) {
                        long notTaken = prev[target];  // Number of ways without taking the current coin

                        long taken = 0;
                        if (arr[ind] <= target)
                            taken = cur[target - arr[ind]];  // Number of ways by taking the current coin
                            
                        cur[target] = notTaken + taken;  // Total number of ways for the current target
                    }
                    prev = cur;  // Update the previous DP state with the current state for the next coin
                }

                return prev[T];  // Return the total number of ways to make change for the target
            }
    // Unbounded Knapsack
        // Memoization
            // Function to solve the unbounded knapsack problem
            int knapsackUtil(vector<int>& wt, vector<int>& val, int ind, int W, vector<vector<int>>& dp) {
                // Base case: if we're at the first item
                if (ind == 0) {
                    // Calculate and return the maximum value for the given weight limit
                    return (W / wt[0]) * val[0];
                }
                
                // If the result for this index and weight limit is already calculated, return it
                if (dp[ind][W] != -1)
                    return dp[ind][W];
                    
                // Calculate the maximum value without taking the current item
                int notTaken = 0 + knapsackUtil(wt, val, ind - 1, W, dp);
                
                // Calculate the maximum value by taking the current item
                int taken = INT_MIN;
                if (wt[ind] <= W)
                    taken = val[ind] + knapsackUtil(wt, val, ind, W - wt[ind], dp);
                    
                // Store the maximum value in the DP table and return it
                return dp[ind][W] = max(notTaken, taken);
            }

            // Function to solve the unbounded knapsack problem
            int unboundedKnapsack(int n, int W, vector<int>& val, vector<int>& wt) {
                vector<vector<int>> dp(n, vector<int>(W + 1, -1)); // Create a DP table
                
                // Call the utility function to calculate the maximum value
                return knapsackUtil(wt, val, n - 1, W, dp);
            }

        // Tabulation
            int unboundedKnapsack(int n, int W, vector<int>& val, vector<int>& wt) {
                vector<vector<int>> dp(n, vector<int>(W + 1, 0)); // Create a DP table

                // Base Condition
                for (int i = wt[0]; i <= W; i++) {
                    dp[0][i] = (i / wt[0]) * val[0]; // Calculate the maximum value for the first item
                }

                for (int ind = 1; ind < n; ind++) {
                    for (int cap = 0; cap <= W; cap++) {
                        int notTaken = 0 + dp[ind - 1][cap]; // Maximum value without taking the current item

                        int taken = INT_MIN;
                        if (wt[ind] <= cap)
                            taken = val[ind] + dp[ind][cap - wt[ind]]; // Maximum value by taking the current item

                        dp[ind][cap] = max(notTaken, taken); // Store the maximum value in the DP table
                    }
                }

                return dp[n - 1][W]; // Return the maximum value considering all items and the knapsack capacity
            }
        // Space Optimization
            // Function to solve the unbounded knapsack problem
            int unboundedKnapsack(int n, int W, vector<int>& val, vector<int>& wt) {
                vector<int> cur(W + 1, 0); // Create a vector to store the current DP state

                // Base Condition
                for (int i = wt[0]; i <= W; i++) {
                    cur[i] = (i / wt[0]) * val[0]; // Calculate the maximum value for the first item
                }

                for (int ind = 1; ind < n; ind++) {
                    for (int cap = 0; cap <= W; cap++) {
                        int notTaken = cur[cap]; // Maximum value without taking the current item

                        int taken = INT_MIN;
                        if (wt[ind] <= cap)
                            taken = val[ind] + cur[cap - wt[ind]]; // Maximum value by taking the current item

                        cur[cap] = max(notTaken, taken); // Store the maximum value in the current DP state
                    }
                }

                return cur[W]; // Return the maximum value considering all items and the knapsack capacity
            }

    // Rod Cutting Problem | infinite supply of N rods with price same as unbounded kanpsack
        // Memoization
            // Function to solve the unbounded knapsack problem
            int knapsackUtil(vector<int>& wt, vector<int>& val, int ind, int W, vector<vector<int>>& dp) {
                // Base case: if we're at the first item
                if (ind == 0) {
                    // Calculate and return the maximum value for the given weight limit
                    return (W / wt[0]) * val[0];
                }
                
                // If the result for this index and weight limit is already calculated, return it
                if (dp[ind][W] != -1)
                    return dp[ind][W];
                    
                // Calculate the maximum value without taking the current item
                int notTaken = 0 + knapsackUtil(wt, val, ind - 1, W, dp);
                
                // Calculate the maximum value by taking the current item
                int taken = INT_MIN;
                if (wt[ind] <= W)
                    taken = val[ind] + knapsackUtil(wt, val, ind, W - wt[ind], dp);
                    
                // Store the maximum value in the DP table and return it
                return dp[ind][W] = max(notTaken, taken);
            }
            // Function to solve the unbounded knapsack problem
            int unboundedKnapsack(int n, int W, vector<int>& val, vector<int>& wt) {
                vector<vector<int>> dp(n, vector<int>(W + 1, -1)); // Create a DP table
                
                // Call the utility function to calculate the maximum value
                return knapsackUtil(wt, val, n - 1, W, dp);
            }
        // Tabulation
            // Function to solve the unbounded knapsack problem
            int unboundedKnapsack(int n, int W, vector<int>& val, vector<int>& wt) {
                vector<vector<int>> dp(n, vector<int>(W + 1, 0)); // Create a DP table

                // Base Condition
                for (int i = wt[0]; i <= W; i++) {
                    dp[0][i] = (i / wt[0]) * val[0]; // Calculate the maximum value for the first item
                }

                for (int ind = 1; ind < n; ind++) {
                    for (int cap = 0; cap <= W; cap++) {
                        int notTaken = 0 + dp[ind - 1][cap]; // Maximum value without taking the current item

                        int taken = INT_MIN;
                        if (wt[ind] <= cap)
                            taken = val[ind] + dp[ind][cap - wt[ind]]; // Maximum value by taking the current item

                        dp[ind][cap] = max(notTaken, taken); // Store the maximum value in the DP table
                    }
                }

                return dp[n - 1][W]; // Return the maximum value considering all items and the knapsack capacity
            }
        // Space Optimization
            // Function to solve the unbounded knapsack problem
            int unboundedKnapsack(int n, int W, vector<int>& val, vector<int>& wt) {
                vector<int> cur(W + 1, 0); // Create a vector to store the current DP state

                // Base Condition
                for (int i = wt[0]; i <= W; i++) {
                    cur[i] = (i / wt[0]) * val[0]; // Calculate the maximum value for the first item
                }

                for (int ind = 1; ind < n; ind++) {
                    for (int cap = 0; cap <= W; cap++) {
                        int notTaken = cur[cap]; // Maximum value without taking the current item

                        int taken = INT_MIN;
                        if (wt[ind] <= cap)
                            taken = val[ind] + cur[cap - wt[ind]]; // Maximum value by taking the current item

                        cur[cap] = max(notTaken, taken); // Store the maximum value in the current DP state
                    }
                }

                return cur[W]; // Return the maximum value considering all items and the knapsack capacity
            }
    // DP on Strings
    // Longest Common Subsequence ## VVIP ##
        // Memoization
            int lcsUtil(string& s1, string& s2, int ind1, int ind2, vector<vector<int>>& dp) {
                // Base case: If either string reaches the end, return 0
                if (ind1 < 0 || ind2 < 0)
                    return 0;

                // If the result for this pair of indices is already calculated, return it
                if (dp[ind1][ind2] != -1)
                    return dp[ind1][ind2];

                // If the characters at the current indices match, increment the LCS length
                if (s1[ind1] == s2[ind2])
                    return dp[ind1][ind2] = 1 + lcsUtil(s1, s2, ind1 - 1, ind2 - 1, dp);
                else
                    // If the characters don't match, consider two options: moving either left or up in the strings
                    return dp[ind1][ind2] = max(lcsUtil(s1, s2, ind1, ind2 - 1, dp), lcsUtil(s1, s2, ind1 - 1, ind2, dp));
            }

            // Function to calculate the length of the Longest Common Subsequence
            int lcs(string s1, string s2) {
                int n = s1.size();
                int m = s2.size();

                vector<vector<int>> dp(n, vector<int>(m, -1)); // Create a DP table
                return lcsUtil(s1, s2, n - 1, m - 1, dp);
            }
        // Tabulation
            // Function to find the length of the Longest Common Subsequence (LCS)
            int lcs(string s1, string s2) {
                int n = s1.size();
                int m = s2.size();

                vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1)); // Create a DP table

                // Initialize the base cases
                for (int i = 0; i <= n; i++) {
                    dp[i][0] = 0;
                }
                for (int i = 0; i <= m; i++) {
                    dp[0][i] = 0;
                }

                // Fill in the DP table to calculate the length of LCS
                for (int ind1 = 1; ind1 <= n; ind1++) {
                    for (int ind2 = 1; ind2 <= m; ind2++) {
                        if (s1[ind1 - 1] == s2[ind2 - 1])
                            dp[ind1][ind2] = 1 + dp[ind1 - 1][ind2 - 1]; // Characters match, increment LCS length
                        else
                            dp[ind1][ind2] = max(dp[ind1 - 1][ind2], dp[ind1][ind2 - 1]); // Characters don't match, consider the maximum from left or above
                    }
                }

                return dp[n][m]; // Return the length of the Longest Common Subsequence
            }
        // Space Optimization
            // Function to find the length of the Longest Common Subsequence (LCS)
            int lcs(string s1, string s2) {
                int n = s1.size();
                int m = s2.size();

                // Initialize two vectors to store the current and previous rows of the DP table
                vector<int> prev(m + 1, 0), cur(m + 1, 0);

                // Base case is covered as we have initialized the prev and cur vectors to 0.

                for (int ind1 = 1; ind1 <= n; ind1++) {
                    for (int ind2 = 1; ind2 <= m; ind2++) {
                        if (s1[ind1 - 1] == s2[ind2 - 1])
                            cur[ind2] = 1 + prev[ind2 - 1]; // Characters match, increment LCS length
                        else
                            cur[ind2] = max(prev[ind2], cur[ind2 - 1]); // Characters don't match, consider the maximum from above or left
                    }
                    prev = cur; // Update the previous row with the current row
                }

                return prev[m]; // Return the length of the Longest Common Subsequence
            }

    // Print Longest Common Subsequence ## VVIP ##
        // Memoization
        // Tabulation
        // Space Optimization
            void lcs(string s1, string s2) {

                int n = s1.size();
                int m = s2.size();

                vector < vector < int >> dp(n + 1, vector < int > (m + 1, 0));
                for (int i = 0; i <= n; i++) {
                    dp[i][0] = 0;
                }
                for (int i = 0; i <= m; i++) {
                    dp[0][i] = 0;
                }

                for (int ind1 = 1; ind1 <= n; ind1++) {
                    for (int ind2 = 1; ind2 <= m; ind2++) {
                    if (s1[ind1 - 1] == s2[ind2 - 1])
                        dp[ind1][ind2] = 1 + dp[ind1 - 1][ind2 - 1];
                    else
                        dp[ind1][ind2] = 0 + max(dp[ind1 - 1][ind2], dp[ind1][ind2 - 1]);
                    }
                }

                int len = dp[n][m];
                int i = n;
                int j = m;

                int index = len - 1;
                string str = "";
                for (int k = 1; k <= len; k++) {
                    str += "$"; // dummy string
                }

                while (i > 0 && j > 0) {
                    if (s1[i - 1] == s2[j - 1]) {
                        str[index] = s1[i - 1];
                        index--;
                        i--;
                        j--;
                    } else if (s1[i - 1] > s2[j - 1]) {
                        i--;
                    } else j--;
                }
                cout << str;
            }
    // Longest common Substring
        // Memoization
        // Tabulation
            // Function to find the length of the Longest Common Substring (LCS)
            int lcs(string &s1, string &s2){
                int n = s1.size();
                int m = s2.size();
                
                // Create a 2D DP table with dimensions (n+1) x (m+1)
                vector> dp(n+1, vector(m+1, 0));

                int ans = 0; // Initialize the answer variable

                for(int i = 1; i <= n; i++){
                    for(int j = 1; j <= m; j++){
                        if(s1[i-1] == s2[j-1]){
                            int val = 1 + dp[i-1][j-1]; // Characters match, increment substring length
                            dp[i][j] = val; // Update the DP table
                            ans = max(ans, val); // Update the maximum substring length found so far
                        }
                        else
                            dp[i][j] = 0; // Characters don't match, substring length becomes 0
                    }
                }
                
                return ans; // Return the length of the Longest Common Substring
            }
        // Space Optimization
            int lcs(string &s1, string &s2){
                int n = s1.size();
                int m = s2.size();
                
                // Initialize two vectors to store previous and current row values
                vector<int> prev(m+1, 0); // Stores values of the previous row
                vector<int> cur(m+1, 0);  // Stores values of the current row

                int ans = 0; // Initialize the answer variable to store the maximum LCS length found
                
                // Loop through both strings
                for(int i = 1; i <= n; i++){
                    for(int j = 1; j <= m; j++){
                        if(s1[i-1] == s2[j-1]){
                            int val = 1 + prev[j-1]; // Characters match, increment substring length
                            cur[j] = val; // Update the current row with the new value
                            ans = max(ans, val); // Update the maximum substring length found so far
                        }
                        else
                            cur[j] = 0; // Characters don't match, substring length becomes 0
                    }
                    prev = cur; // Update the previous row with the values of the current row
                }
                
                return ans; // Return the length of the Longest Common Substring
            }
    // Longest Palindromic Subsequence | Longest Common Subsequence(s1, rev(s1))
        // Memoization
        // Tabulation
            // Function to calculate the length of the Longest Common Subsequence
            int lcs(string s1, string s2) {
                int n = s1.size();
                int m = s2.size();

                // Create a 2D DP array to store the length of the LCS
                vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));

                // Initialize the first row and first column to 0
                for (int i = 0; i <= n; i++) {
                    dp[i][0] = 0;
                }
                for (int i = 0; i <= m; i++) {
                    dp[0][i] = 0;
                }

                // Fill in the DP array
                for (int ind1 = 1; ind1 <= n; ind1++) {
                    for (int ind2 = 1; ind2 <= m; ind2++) {
                        if (s1[ind1 - 1] == s2[ind2 - 1])
                            dp[ind1][ind2] = 1 + dp[ind1 - 1][ind2 - 1];
                        else
                            dp[ind1][ind2] = max(dp[ind1 - 1][ind2], dp[ind1][ind2 - 1]);
                    }
                }

                // The value at dp[n][m] contains the length of the LCS
                return dp[n][m];
            }

            // Function to calculate the length of the Longest Palindromic Subsequence
            int longestPalindromeSubsequence(string s) {
                // Create a reversed copy of the string
                string t = s;
                reverse(s.begin(), s.end());

                // Call the LCS function to find the length of the Longest Common Subsequence
                return lcs(s, t);
            }
        // Space Optimization
            // Function to calculate the length of the Longest Common Subsequence
            int lcs(string s1, string s2) {
                int n = s1.size();
                int m = s2.size();

                // Create two arrays to store the previous and current rows of DP values
                vector<int> prev(m + 1, 0), cur(m + 1, 0);

                // Base Case is covered as we have initialized the prev and cur to 0.

                for (int ind1 = 1; ind1 <= n; ind1++) {
                    for (int ind2 = 1; ind2 <= m; ind2++) {
                        if (s1[ind1 - 1] == s2[ind2 - 1])
                            cur[ind2] = 1 + prev[ind2 - 1];
                        else
                            cur[ind2] = max(prev[ind2], cur[ind2 - 1]);
                    }
                    // Update the prev array with the current values
                    prev = cur;
                }

                // The value at prev[m] contains the length of the LCS
                return prev[m];
            }

            // Function to calculate the length of the Longest Palindromic Subsequence
            int longestPalindromeSubsequence(string s) {
                // Create a reversed copy of the string
                string t = s;
                reverse(s.begin(), s.end());

                // Call the LCS function to find the length of the Longest Common Subsequence
                return lcs(s, t);
            }
    // Minimum Insertions to Make String Palindrome| N - Longest Palindromic Subsequence(s)
        // Memoization
        // Tabulation
            // Function to calculate the length of the Longest Common Subsequence
            int lcs(string s1, string s2) {
                int n = s1.size();
                int m = s2.size();

                vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));

                // Initialize the first row and first column to 0
                for (int i = 0; i <= n; i++) {
                    dp[i][0] = 0;
                }
                for (int i = 0; i <= m; i++) {
                    dp[0][i] = 0;
                }

                for (int ind1 = 1; ind1 <= n; ind1++) {
                    for (int ind2 = 1; ind2 <= m; ind2++) {
                        if (s1[ind1 - 1] == s2[ind2 - 1])
                            dp[ind1][ind2] = 1 + dp[ind1 - 1][ind2 - 1];
                        else
                            dp[ind1][ind2] = max(dp[ind1 - 1][ind2], dp[ind1][ind2 - 1]);
                    }
                }

                return dp[n][m];
            }

            // Function to calculate the length of the Longest Palindromic Subsequence
            int longestPalindromeSubsequence(string s) {
                string t = s;
                reverse(s.begin(), s.end());
                return lcs(s, t);
            }

            // Function to calculate the minimum insertions required to make a string palindrome
            int minInsertion(string s) {
                int n = s.size();
                int k = longestPalindromeSubsequence(s);

                // The minimum insertions required is the difference between the string length and its longest palindromic subsequence length
                return n - k;
            }
        // Space Optimization
            int lcs(string s1, string s2) {
                int n = s1.size();
                int m = s2.size();

                // Create two arrays to store the previous and current rows of DP values
                vector<int> prev(m + 1, 0), cur(m + 1, 0);

                // Base Case is covered as we have initialized the prev and cur to 0.

                for (int ind1 = 1; ind1 <= n; ind1++) {
                    for (int ind2 = 1; ind2 <= m; ind2++) {
                        if (s1[ind1 - 1] == s2[ind2 - 1])
                            cur[ind2] = 1 + prev[ind2 - 1];
                        else
                            cur[ind2] = max(prev[ind2], cur[ind2 - 1]);
                    }
                    // Update the prev array with the current values
                    prev = cur;
                }

                // The value at prev[m] contains the length of the LCS
                return prev[m];
            }

            // Function to calculate the length of the Longest Palindromic Subsequence
            int longestPalindromeSubsequence(string s) {
                string t = s;
                reverse(s.begin(), s.end());
                return lcs(s, t);
            }

            // Function to calculate the minimum insertions required to make a string palindrome
            int minInsertion(string s) {
                int n = s.size();
                int k = longestPalindromeSubsequence(s);

                // The minimum insertions required is the difference between the string length and its longest palindromic subsequence length
                return n - k;
            }

    // Minimum Insertions/Deletions to Convert String A to String B | N - LCS(s1, s2) + M - LCS(s1, s2)
        // Memoization
        // Tabulation
            // Function to calculate the length of the Longest Common Subsequence
            int lcs(string s1, string s2) {
                int n = s1.size();
                int m = s2.size();

                vector<vector<int>> dp(n + 1, vector<int>(m + 1, -1));

                // Initialize the first row and first column to 0
                for (int i = 0; i <= n; i++) {
                    dp[i][0] = 0;
                }
                for (int i = 0; i <= m; i++) {
                    dp[0][i] = 0;
                }

                for (int ind1 = 1; ind1 <= n; ind1++) {
                    for (int ind2 = 1; ind2 <= m; ind2++) {
                        if (s1[ind1 - 1] == s2[ind2 - 1])
                            dp[ind1][ind2] = 1 + dp[ind1 - 1][ind2 - 1];
                        else
                            dp[ind1][ind2] = max(dp[ind1 - 1][ind2], dp[ind1][ind2 - 1]);
                    }
                }

                return dp[n][m];
            }

            // Function to calculate the minimum operations required to convert str1 to str2
            int canYouMake(string str1, string str2) {
                int n = str1.size();
                int m = str2.size();
                
                // Calculate the length of the longest common subsequence between str1 and str2
                int k = lcs(str1, str2);
                
                // Calculate the minimum operations required to convert str1 to str2
                return (n - k) + (m - k);
            }

        // Space Optimization
            // Function to calculate the length of the Longest Common Subsequence
            int lcs(string s1, string s2) {
                int n = s1.size();
                int m = s2.size();

                // Create two arrays to store the previous and current rows of DP values
                vector<int> prev(m + 1, 0), cur(m + 1, 0);

                // Base Case is covered as we have initialized the prev and cur to 0.

                for (int ind1 = 1; ind1 <= n; ind1++) {
                    for (int ind2 = 1; ind2 <= m; ind2++) {
                        if (s1[ind1 - 1] == s2[ind2 - 1])
                            cur[ind2] = 1 + prev[ind2 - 1];
                        else
                            cur[ind2] = max(prev[ind2], cur[ind2 - 1]);
                    }
                    // Update the prev array with the current values
                    prev = cur;
                }

                // The value at prev[m] contains the length of the LCS
                return prev[m];
            }

            // Function to calculate the minimum operations required to convert str1 to str2
            int canYouMake(string str1, string str2) {
                int n = str1.size();
                int m = str2.size();
                
                // Calculate the length of the longest common subsequence between str1 and str2
                int k = lcs(str1, str2);
                
                // Calculate the minimum operations required to convert str1 to str2
                return (n - k) + (m - k);
            }
    // Shortest Common Supersequence | L = N - LCS(s1, s2) + M - LCS(s1, s2) + LCS(s1, s2)
        // Memoization
        // Tabulation
            string shortestSupersequence(string s1, string s2){

                int n = s1.size();
                int m = s2.size();

                vector < vector < int >> dp(n + 1, vector < int > (m + 1, 0));
                for (int i = 0; i <= n; i++) {
                    dp[i][0] = 0;
                }
                for (int i = 0; i <= m; i++) {
                    dp[0][i] = 0;
                }

                for (int ind1 = 1; ind1 <= n; ind1++) {
                    for (int ind2 = 1; ind2 <= m; ind2++) {
                        if (s1[ind1 - 1] == s2[ind2 - 1])
                            dp[ind1][ind2] = 1 + dp[ind1 - 1][ind2 - 1];
                        else
                            dp[ind1][ind2] = 0 + max(dp[ind1 - 1][ind2], dp[ind1][ind2 - 1]);
                    }
                }

                int len = dp[n][m];
                int i = n;
                int j = m;

                int index = len - 1;
                string ans = "";

                while (i > 0 && j > 0) {
                    if (s1[i - 1] == s2[j - 1]) {
                        ans += s1[i-1];
                        index--;
                        i--;
                        j--;
                    } else if (dp[i - 1][j] > dp[i][j - 1]) {
                        ans += s1[i-1];
                        i--;
                    } else {
                        ans += s2[j-1];
                        j--;
                    }
                }
                
                //Adding Remaing Characters - Only one of the below two while loops will run 
                
                while(i>0){
                    ans += s1[i-1];
                    i--;
                }
                while(j>0){
                    ans += s2[j-1];
                    j--;
                }

                reverse(ans.begin(),ans.end());
                
                return ans;
            }
        // Space Optimization
    // Distinct Subsequences (String Matching)
        // Memoization
            // Function to count the number of distinct subsequences of s2 in s1
            int countUtil(string s1, string s2, int ind1, int ind2, vector<vector<int>>& dp) {
                // If s2 has been completely matched, return 1 (found a valid subsequence)
                if (ind2 < 0)
                    return 1;
                
                // If s1 has been completely traversed but s2 hasn't, return 0
                if (ind1 < 0)
                    return 0;

                // If the result for this state has already been calculated, return it
                if (dp[ind1][ind2] != -1)
                    return dp[ind1][ind2];

                int result = 0;

                // If the characters match, consider two options: either leave one character in s1 and s2
                // or leave one character in s1 and continue matching s2
                if (s1[ind1] == s2[ind2]) {
                    int leaveOne = countUtil(s1, s2, ind1 - 1, ind2 - 1, dp);
                    int stay = countUtil(s1, s2, ind1 - 1, ind2, dp);

                    result = (leaveOne + stay) % prime;
                } else {
                    // If characters don't match, just leave one character in s1 and continue matching s2
                    result = countUtil(s1, s2, ind1 - 1, ind2, dp);
                }

                // Store the result and return it
                dp[ind1][ind2] = result;
                return result;
            }
            // Function to count the number of distinct subsequences of s2 in s1
            int subsequenceCounting(string &s1, string &s2, int lt, int ls) {
                vector<vector<int>> dp(lt, vector<int>(ls, -1));
                return countUtil(s1, s2, lt - 1, ls - 1, dp);
            }
        // Tabulation
            const int prime = 1e9 + 7;
            // Function to count the number of distinct subsequences of s2 in s1
            int subsequenceCounting(string &s1, string &s2, int n, int m) {
                // Create a 2D DP array to store the count of distinct subsequences
                vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));

                // Initialize the first row: empty string s2 can be matched with any non-empty s1 in one way
                for (int i = 0; i <= n; i++) {
                    dp[i][0] = 1;
                }

                // Initialize the first column: s1 can't match any non-empty s2
                for (int i = 1; i <= m; i++) {
                    dp[0][i] = 0;
                }

                // Fill in the DP array
                for (int i = 1; i <= n; i++) {
                    for (int j = 1; j <= m; j++) {
                        if (s1[i - 1] == s2[j - 1]) {
                            // If the characters match, we have two options:
                            // 1. Match the current characters and move diagonally (dp[i-1][j-1])
                            // 2. Leave the current character in s1 and match s2 with the previous characters (dp[i-1][j])
                            dp[i][j] = (dp[i - 1][j - 1] + dp[i - 1][j]) % prime;
                        } else {
                            // If the characters don't match, we can only leave the current character in s1
                            dp[i][j] = dp[i - 1][j];
                        }
                    }
                }

                // The value at dp[n][m] contains the count of distinct subsequences
                return dp[n][m];
            }
        // Space Optimization
            const int prime = 1e9 + 7;
            // Function to count the number of distinct subsequences of s2 in s1
            int subsequenceCounting(string &s1, string &s2, int n, int m) {
                // Create an array to store the count of distinct subsequences for each character in s2
                vector<int> prev(m + 1, 0);

                // Initialize the count for an empty string (base case)
                prev[0] = 1;

                // Iterate through s1 and s2 to calculate the counts
                for (int i = 1; i <= n; i++) {
                    for (int j = m; j >= 1; j--) { // Iterate in reverse direction to avoid overwriting values prematurely
                        if (s1[i - 1] == s2[j - 1]) {
                            // If the characters match, we have two options:
                            // 1. Match the current characters and add to the previous count (prev[j-1])
                            // 2. Leave the current character in s1 and match s2 with the previous characters (prev[j])
                            prev[j] = (prev[j - 1] + prev[j]) % prime;
                        }
                        // No need for an else statement since we can simply leave the previous count as is
                    }
                }
                // The value at prev[m] contains the count of distinct subsequences
                return prev[m];
            }
    // Edit Distance
        // Memoization
            // Function to calculate the edit distance between two strings
            int editDistanceUtil(string& S1, string& S2, int i, int j, vector<vector<int>>& dp) {
                // Base cases
                if (i < 0)
                    return j + 1;
                if (j < 0)
                    return i + 1;

                // If the result for this state has already been calculated, return it
                if (dp[i][j] != -1)
                    return dp[i][j];

                // If the characters at the current positions match, no operation is needed
                if (S1[i] == S2[j])
                    return dp[i][j] = 0 + editDistanceUtil(S1, S2, i - 1, j - 1, dp);

                // Minimum of three choices:
                // 1. Replace the character at S1[i] with the character at S2[j]
                // 2. Delete the character at S1[i]
                // 3. Insert the character at S2[j] into S1
                else
                    return dp[i][j] = 1 + min(editDistanceUtil(S1, S2, i - 1, j - 1, dp),
                                            min(editDistanceUtil(S1, S2, i - 1, j, dp),
                                                editDistanceUtil(S1, S2, i, j - 1, dp)));
            }

            // Function to calculate the minimum number of operations required to transform S1 into S2
            int editDistance(string& S1, string& S2) {
                int n = S1.size();
                int m = S2.size();

                // Create a DP table to memoize results
                vector<vector<int>> dp(n, vector<int>(m, -1));

                // Call the utility function with the last indices of both strings
                return editDistanceUtil(S1, S2, n - 1, m - 1, dp);
            }
        // Tabulation
            // Function to calculate the edit distance between two strings
            int editDistance(string& S1, string& S2) {
                int n = S1.size();
                int m = S2.size();

                // Create a DP table to store edit distances
                vector<vector<int>> dp(n + 1, vector<int>(m + 1, 0));

                // Initialize the first row and column
                for (int i = 0; i <= n; i++) {
                    dp[i][0] = i;
                }
                for (int j = 0; j <= m; j++) {
                    dp[0][j] = j;
                }

                // Fill in the DP table
                for (int i = 1; i <= n; i++) {
                    for (int j = 1; j <= m; j++) {
                        if (S1[i - 1] == S2[j - 1]) {
                            // If the characters match, no additional cost
                            dp[i][j] = dp[i - 1][j - 1];
                        } else {
                            // Minimum of three choices:
                            // 1. Replace the character at S1[i-1] with S2[j-1]
                            // 2. Delete the character at S1[i-1]
                            // 3. Insert the character at S2[j-1] into S1
                            dp[i][j] = 1 + min(dp[i - 1][j - 1], min(dp[i - 1][j], dp[i][j - 1]));
                        }
                    }
                }

                // The value at dp[n][m] contains the edit distance
                return dp[n][m];
            }
        // Space Optimization
            // Function to calculate the edit distance between two strings
            int editDistance(string& S1, string& S2) {
                int n = S1.size();
                int m = S2.size();

                // Create two arrays to store previous and current row of edit distances
                vector<int> prev(m + 1, 0);
                vector<int> cur(m + 1, 0);

                // Initialize the first row
                for (int j = 0; j <= m; j++) {
                    prev[j] = j;
                }

                // Calculate edit distances row by row
                for (int i = 1; i <= n; i++) {
                    cur[0] = i; // Initialize the first column of the current row
                    for (int j = 1; j <= m; j++) {
                        if (S1[i - 1] == S2[j - 1]) {
                            // If the characters match, no additional cost
                            cur[j] = prev[j - 1];
                        } else {
                            // Minimum of three choices:
                            // 1. Replace the character at S1[i-1] with S2[j-1]
                            // 2. Delete the character at S1[i-1]
                            // 3. Insert the character at S2[j-1] into S1
                            cur[j] = 1 + min(prev[j - 1], min(prev[j], cur[j - 1]));
                        }
                    }
                    prev = cur; // Update the previous row with the current row
                }

                // The value at cur[m] contains the edit distance
                return cur[m];
            }
    // Wildcard Matching (? *)
        // Memoization
            // Function to check if a substring of S1 contains only '*'
            bool isAllStars(string &S1, int i) {
                for (int j = 0; j <= i; j++) {
                    if (S1[j] != '*')
                        return false;
                }
                return true;
            }
            // Function to check if S1 matches S2 using wildcard pattern matching
            bool wildcardMatchingUtil(string &S1, string &S2, int i, int j, vector<vector<bool>> &dp) {
                // Base Cases
                if (i < 0 && j < 0)
                    return true;
                if (i < 0 && j >= 0)
                    return false;
                if (j < 0 && i >= 0)
                    return isAllStars(S1, i);

                // If the result for this state has already been calculated, return it
                if (dp[i][j] != -1)
                    return dp[i][j];

                // If the characters at the current positions match or S1 has a '?'
                if (S1[i] == S2[j] || S1[i] == '?')
                    return dp[i][j] = wildcardMatchingUtil(S1, S2, i - 1, j - 1, dp);
                else {
                    if (S1[i] == '*')
                        // Two options: either '*' represents an empty string or it matches a character in S2
                        return dp[i][j] = wildcardMatchingUtil(S1, S2, i - 1, j, dp) || wildcardMatchingUtil(S1, S2, i, j - 1, dp);
                    else
                        return false;
                }
            }
            // Main function to check if S1 matches S2 using wildcard pattern matching
            bool wildcardMatching(string &S1, string &S2) {
                int n = S1.size();
                int m = S2.size();

                // Create a DP table to memoize results
                vector<vector<bool>> dp(n, vector<bool>(m, -1));
                return wildcardMatchingUtil(S1, S2, n - 1, m - 1, dp);
            }
        // Tabulation
            // Function to check if a substring of S1 contains only '*'
            bool isAllStars(string &S1, int i) {
                // S1 is taken in 1-based indexing
                for (int j = 1; j <= i; j++) {
                    if (S1[j - 1] != '*')
                        return false;
                }
                return true;
            }
            // Function to perform wildcard pattern matching between S1 and S2
            bool wildcardMatching(string &S1, string &S2) {
                int n = S1.size();
                int m = S2.size();

                // Create a DP table to memoize results
                vector<vector<bool>> dp(n + 1, vector<bool>(m, false));

                // Initialize the first row and column
                dp[0][0] = true;
                for (int j = 1; j <= m; j++) {
                    dp[0][j] = false;
                }
                for (int i = 1; i <= n; i++) {
                    dp[i][0] = isAllStars(S1, i);
                }

                // Fill in the DP table
                for (int i = 1; i <= n; i++) {
                    for (int j = 1; j <= m; j++) {
                        if (S1[i - 1] == S2[j - 1] || S1[i - 1] == '?') {
                            dp[i][j] = dp[i - 1][j - 1];
                        } else {
                            if (S1[i - 1] == '*') {
                                dp[i][j] = dp[i - 1][j] || dp[i][j - 1];
                            } else {
                                dp[i][j] = false;
                            }
                        }
                    }
                }

                // The value at dp[n][m] contains whether S1 matches S2
                return dp[n][m];
            }
        // Space Optimization
            // Function to check if a substring of S1 contains only '*'
            bool isAllStars(string &S1, int i) {
                // S1 is taken in 1-based indexing
                for (int j = 1; j <= i; j++) {
                    if (S1[j - 1] != '*')
                        return false;
                }
                return true;
            }
            // Function to perform wildcard pattern matching between S1 and S2
            bool wildcardMatching(string &S1, string &S2) {
                int n = S1.size();
                int m = S2.size();

                // Create two arrays to store previous and current rows of matching results
                vector<bool> prev(m + 1, false);
                vector<bool> cur(m + 1, false);

                prev[0] = true; // Initialize the first element of the previous row to true

                for (int i = 1; i <= n; i++) {
                    cur[0] = isAllStars(S1, i); // Initialize the first element of the current row
                    for (int j = 1; j <= m; j++) {
                        if (S1[i - 1] == S2[j - 1] || S1[i - 1] == '?') {
                            cur[j] = prev[j - 1]; // Characters match or S1 has '?'
                        } else {
                            if (S1[i - 1] == '*') {
                                cur[j] = prev[j] || cur[j - 1]; // '*' represents empty or a character
                            } else {
                                cur[j] = false; // Characters don't match and S1[i-1] is not '*'
                            }
                        }
                    }
                    prev = cur; // Update the previous row with the current row
                }

                // The value at prev[m] contains whether S1 matches S2
                return prev[m];
            }
    // Dp ON Stocks
    // Best Time to Buy and Sell Stock
        int maximumProfit(vector<int> &Arr){
            // Write your code here.
            int maxProfit = 0;
            int mini = Arr[0];
            
            for(int i=1;i<Arr.size();i++){
                int curProfit = Arr[i] - mini;
                maxProfit = max(maxProfit,curProfit);
                mini = min(mini,Arr[i]);
                }
            return maxProfit;
        }
    // Buy and Sell Stock II ## VVIP ##
        // Memoization
            long getAns(long *Arr, int ind, int buy, int n, vector<vector<long>> &dp) {
                // Base case: When we reach the end of the array, there are no more decisions to make.
                if (ind == n) {
                    return 0;
                }

                // If the result for this state has already been calculated, return it
                if (dp[ind][buy] != -1) {
                    return dp[ind][buy];
                }

                long profit = 0;

                if (buy == 0) { // We can buy the stock
                    profit = max(0 + getAns(Arr, ind + 1, 0, n, dp), -Arr[ind] + getAns(Arr, ind + 1, 1, n, dp));
                }

                if (buy == 1) { // We can sell the stock
                    profit = max(0 + getAns(Arr, ind + 1, 1, n, dp), Arr[ind] + getAns(Arr, ind + 1, 0, n, dp));
                }

                // Store the calculated profit in the DP table and return it
                return dp[ind][buy] = profit;
            }
            long getMaximumProfit(long *Arr, int n) {
                // Create a DP table to memoize results
                vector<vector<long>> dp(n, vector<long>(2, -1));

                if (n == 0) {
                    return 0;
                }

                long ans = getAns(Arr, 0, 0, n, dp);
                return ans;
            }
        // Tabulation
            long getMaximumProfit(long *Arr, int n) {
                // Create a DP table to memoize results
                vector<vector<long>> dp(n + 1, vector<long>(2, -1));

                // Base condition: When we have no stocks left, the profit is 0.
                dp[n][0] = dp[n][1] = 0;

                long profit;

                // Loop through the array in reverse order
                for (int ind = n - 1; ind >= 0; ind--) {
                    for (int buy = 0; buy <= 1; buy++) {
                        if (buy == 0) { // We can buy the stock
                            profit = max(0 + dp[ind + 1][0], -Arr[ind] + dp[ind + 1][1]);
                        }

                        if (buy == 1) { // We can sell the stock
                            profit = max(0 + dp[ind + 1][1], Arr[ind] + dp[ind + 1][0]);
                        }

                        dp[ind][buy] = profit;
                    }
                }

                // The maximum profit is stored in dp[0][0] after all calculations
                return dp[0][0];
            }
        // Space Optimization
            long getMaximumProfit(long *Arr, int n) {
                // Create two arrays to store the profits ahead of the current position (0 for not holding, 1 for holding)
                vector<long> ahead(2, 0);
                vector<long> cur(2, 0);

                // Base condition: When there are no stocks left, the profit is 0.
                ahead[0] = ahead[1] = 0;

                long profit;

                // Loop through the array in reverse order
                for (int ind = n - 1; ind >= 0; ind--) {
                    for (int buy = 0; buy <= 1; buy++) {
                        if (buy == 0) { // We can buy the stock
                            profit = max(0 + ahead[0], -Arr[ind] + ahead[1]);
                        }

                        if (buy == 1) { // We can sell the stock
                            profit = max(0 + ahead[1], Arr[ind] + ahead[0]);
                        }
                        cur[buy] = profit;
                    }

                    ahead = cur; // Update the "ahead" array with the current values
                }

                // The maximum profit is stored in cur[0] after all calculations
                return cur[0];
            }
    // Buy and Sell Stock III
        // Memoization
            int getAns(vector<int>& Arr, int n, int ind, int buy, int cap, vector<vector<vector<int>>>& dp) {
                // Base case: If we reach the end of the array or run out of allowed transactions, return 0.
                if (ind == n || cap == 0)
                    return 0;

                // If the result is already calculated, return it.
                if (dp[ind][buy][cap] != -1)
                    return dp[ind][buy][cap];

                int profit;

                if (buy == 0) { // We can buy the stock
                    profit = max(0 + getAns(Arr, n, ind + 1, 0, cap, dp),
                                -Arr[ind] + getAns(Arr, n, ind + 1, 1, cap, dp));
                }

                if (buy == 1) { // We can sell the stock
                    profit = max(0 + getAns(Arr, n, ind + 1, 1, cap, dp),
                                Arr[ind] + getAns(Arr, n, ind + 1, 0, cap - 1, dp));
                }

                // Store and return the calculated profit.
                return dp[ind][buy][cap] = profit;
            }
            int maxProfit(vector<int>& prices, int n) {
                // Creating a 3D DP array of size [n][2][3]
                vector<vector<vector<int>>> dp(n, vector<vector<int>>(2, vector<int>(3, -1)));

                // Call the recursive function to calculate maximum profit
                return getAns(prices, n, 0, 0, 2, dp);
            }
        // Tabulation
            int maxProfit(vector<int>& Arr, int n) {
                // Creating a 3D DP array of size [n+1][2][3] initialized to 0
                vector<vector<vector<int>>> dp(n + 1, vector<vector<int>>(2, vector<int>(3, 0)));

                // Base case: dp array is already initialized to 0, covering the base case.

                for (int ind = n - 1; ind >= 0; ind--) {
                    for (int buy = 0; buy <= 1; buy++) {
                        for (int cap = 1; cap <= 2; cap++) {
                            if (buy == 0) { // We can buy the stock
                                dp[ind][buy][cap] = max(0 + dp[ind + 1][0][cap],
                                                    -Arr[ind] + dp[ind + 1][1][cap]);
                            }

                            if (buy == 1) { // We can sell the stock
                                dp[ind][buy][cap] = max(0 + dp[ind + 1][1][cap],
                                                    Arr[ind] + dp[ind + 1][0][cap - 1]);
                            }
                        }
                    }
                }

                // The result is stored in dp[0][0][2] which represents maximum profit after the final transaction.
                return dp[0][0][2];
            }
        // Space Optimization
            int maxProfit(vector<int>& Arr, int n) {
                // Create two 2D arrays to store the profit information, one for the current state and one for the ahead state.
                vector<vector<int>> ahead(2, vector<int>(3, 0));
                vector<vector<int>> cur(2, vector<int>(3, 0));

                for (int ind = n - 1; ind >= 0; ind--) {
                    for (int buy = 0; buy <= 1; buy++) {
                        for (int cap = 1; cap <= 2; cap++) {
                            if (buy == 0) { // We can buy the stock
                                cur[buy][cap] = max(0 + ahead[0][cap], 
                                                    -Arr[ind] + ahead[1][cap]);
                            }

                            if (buy == 1) { // We can sell the stock
                                cur[buy][cap] = max(0 + ahead[1][cap],
                                                    Arr[ind] + ahead[0][cap - 1]);
                            }
                        }
                    }
                    // Update the ahead state with the current state for the next iteration.
                    ahead = cur;
                }

                return ahead[0][2];
            }
    // Buy and Sell Stock IV
        // Memoization
            int getAns(vector<int>& Arr, int n, int ind, int buy, int cap, vector<vector<vector<int>>>& dp) {
                // Base case
                if (ind == n || cap == 0) return 0;

                // Check if the result is already computed
                if (dp[ind][buy][cap] != -1)
                    return dp[ind][buy][cap];

                int profit;

                if (buy == 0) { // We can buy the stock
                    profit = max(0 + getAns(Arr, n, ind + 1, 0, cap, dp),
                                -Arr[ind] + getAns(Arr, n, ind + 1, 1, cap, dp));
                }

                if (buy == 1) { // We can sell the stock
                    profit = max(0 + getAns(Arr, n, ind + 1, 1, cap, dp),
                                Arr[ind] + getAns(Arr, n, ind + 1, 0, cap - 1, dp));
                }

                // Store the result in the DP array and return
                return dp[ind][buy][cap] = profit;
            }
            int maximumProfit(vector<int>& prices, int n, int k) {
                // Creating a 3D DP array of size [n][2][k+1]
                vector<vector<vector<int>>> dp(n,
                                                vector<vector<int>>(2, vector<int>(k + 1, -1)));

                return getAns(prices, n, 0, 0, k, dp);
            }
        // Tabulation
            int maximumProfit(vector<int>& Arr, int n, int k) {
                // Creating a 3D DP array of size [n+1][2][k+1] initialized to 0
                vector<vector<vector<int>>> dp(n + 1,
                                                vector<vector<int>>(2, vector<int>(k + 1, 0)));

                // Loop through the stock prices from the end to the beginning
                for (int ind = n - 1; ind >= 0; ind--) {
                    for (int buy = 0; buy <= 1; buy++) {
                        for (int cap = 1; cap <= k; cap++) {
                            if (buy == 0) { // We can buy the stock
                                dp[ind][buy][cap] = max(0 + dp[ind + 1][0][cap],
                                            -Arr[ind] + dp[ind + 1][1][cap]);
                            }

                            if (buy == 1) { // We can sell the stock
                                dp[ind][buy][cap] = max(0 + dp[ind + 1][1][cap],
                                            Arr[ind] + dp[ind + 1][0][cap - 1]);
                            }
                        }
                    }
                }

                return dp[0][0][k];
            }
        // Space Optimization
            int maxProfit(vector<int>& Arr, int n, int k) {
                // Create two arrays, 'ahead' and 'cur', to track the maximum profit at each step
                vector<vector<int>> ahead(2, vector<int>(k + 1, 0));
                vector<vector<int>> cur(2, vector<int>(k + 1, 0));

                for (int ind = n - 1; ind >= 0; ind--) {
                    for (int buy = 0; buy <= 1; buy++) {
                        for (int cap = 1; cap <= k; cap++) {
                            if (buy == 0) { // We can buy the stock
                                cur[buy][cap] = max(0 + ahead[0][cap],
                                                -Arr[ind] + ahead[1][cap]);
                            }

                            if (buy == 1) { // We can sell the stock
                                cur[buy][cap] = max(0 + ahead[1][cap],
                                                Arr[ind] + ahead[0][cap - 1]);
                            }
                        }
                    }
                    // Update the 'ahead' array with the current values
                    ahead = cur;
                }

                return ahead[0][k];
            }
    // Buy and Sell Stocks With Cooldown
        // Memoization
            int getAns(vector<int> Arr, int ind, int buy, int n, vector<vector<int>> &dp) {
                // Base case: If we've reached the end of the array, return 0 profit.
                if (ind >= n) return 0;
                
                // Check if the result is already computed
                if (dp[ind][buy] != -1)
                    return dp[ind][buy];
                    
                int profit;
                
                if (buy == 0) { // We can buy the stock
                    profit = max(0 + getAns(Arr, ind + 1, 0, n, dp), -Arr[ind] + getAns(Arr, ind + 1, 1, n, dp));
                }
                
                if (buy == 1) { // We can sell the stock
                    profit = max(0 + getAns(Arr, ind + 1, 1, n, dp), Arr[ind] + getAns(Arr, ind + 2, 0, n, dp));
                }
                
                // Store the result in the DP array and return
                return dp[ind][buy] = profit;
            }
            int stockProfit(vector<int> &Arr) {
                int n = Arr.size();
                vector<vector<int>> dp(n, vector<int>(2, -1));
                
                int ans = getAns(Arr, 0, 0, n, dp);
                return ans;
            }
        // Tabulation
            int stockProfit(vector<int> &Arr) {
                int n = Arr.size();
                // Create a 2D DP array with dimensions (n+2) x 2, initialized to 0
                vector<vector<int>> dp(n + 2, vector<int>(2, 0));
                
                // Loop through the stock prices from the end to the beginning
                for (int ind = n - 1; ind >= 0; ind--) {
                    for (int buy = 0; buy <= 1; buy++) {
                        int profit;

                        if (buy == 0) { // We can buy the stock
                            profit = max(0 + dp[ind + 1][0], -Arr[ind] + dp[ind + 1][1]);
                        }

                        if (buy == 1) { // We can sell the stock
                            profit = max(0 + dp[ind + 1][1], Arr[ind] + dp[ind + 2][0]);
                        }

                        // Store the computed profit in the DP array
                        dp[ind][buy] = profit;
                    }
                }

                return dp[0][0];
            }
        // Space Optimization
            int stockProfit(vector<int> &Arr) {
                int n = Arr.size();
                
                // Initialize three arrays to track the maximum profit for buying and selling
                vector<int> cur(2, 0);       // Current maximum profit
                vector<int> front1(2, 0);    // Maximum profit one step ahead
                vector<int> front2(2, 0);    // Maximum profit two steps ahead
                
                for (int ind = n - 1; ind >= 0; ind--) {
                    for (int buy = 0; buy <= 1; buy++) {
                        int profit;

                        if (buy == 0) { // We can buy the stock
                            profit = max(0 + front1[0], -Arr[ind] + front1[1]);
                        }

                        if (buy == 1) { // We can sell the stock
                            profit = max(0 + front1[1], Arr[ind] + front2[0]);
                        }
                        
                        cur[buy] = profit;
                    }
                    
                    // Update the 'front1' and 'front2' arrays with current values
                    front2 = front1;
                    front1 = cur;
                }
                
                return cur[0]; // Return the maximum profit for buying.
            }
    // Buy and Sell Stocks With Transaction Fee
        // Memoization
            int getAns(vector<int> &Arr, int ind, int buy, int n, int fee, vector<vector<int>> &dp) {
                // Base case: If we've reached the end of the array, return 0 profit.
                if (ind == n) return 0;
                
                // Check if the result is already computed
                if (dp[ind][buy] != -1)
                    return dp[ind][buy];
                    
                int profit;
                
                if (buy == 0) { // We can buy the stock
                    profit = max(0 + getAns(Arr, ind + 1, 0, n, fee, dp), -Arr[ind] + getAns(Arr, ind + 1, 1, n, fee, dp));
                }
                
                if (buy == 1) { // We can sell the stock
                    profit = max(0 + getAns(Arr, ind + 1, 1, n, fee, dp), Arr[ind] - fee + getAns(Arr, ind + 1, 0, n, fee, dp));
                }
                
                // Store the computed profit in the DP array
                return dp[ind][buy] = profit;
            }
            int maximumProfit(int n, int fee, vector<int> &Arr) {
                vector<vector<int>> dp(n, vector<int>(2, -1));
                
                if (n == 0) return 0; // Edge case: No stocks to trade.
                
                int ans = getAns(Arr, 0, 0, n, fee, dp);
                return ans;
            }
        // Tabulation
            int maximumProfit(int n, int fee, vector<int>& Arr) {
                if (n == 0) return 0; // Edge case: No stocks to trade.

                // Create a 2D DP array with dimensions (n+1) x 2, initialized to 0
                vector<vector<int>> dp(n + 1, vector<int>(2, 0));

                // Loop through the stock prices from the end to the beginning
                for (int ind = n - 1; ind >= 0; ind--) {
                    for (int buy = 0; buy <= 1; buy++) {
                        int profit;

                        if (buy == 0) { // We can buy the stock
                            profit = max(0 + dp[ind + 1][0], -Arr[ind] + dp[ind + 1][1]);
                        }

                        if (buy == 1) { // We can sell the stock
                            profit = max(0 + dp[ind + 1][1], Arr[ind] - fee + dp[ind + 1][0]);
                        }

                        dp[ind][buy] = profit;
                    }
                }

                return dp[0][0]; // Return the maximum profit for buying.
            }
        // Space Optimization
            int maximumProfit(int n, int fee, vector<int>& Arr) {
                if (n == 0) return 0; // Edge case: No stocks to trade.

                vector<long> ahead(2, 0); // To track maximum profit one step ahead
                vector<long> cur(2, 0);   // To track current maximum profit

                // Initialize both ahead[0] and ahead[1] to 0 as the base condition
                ahead[0] = ahead[1] = 0;

                long profit;

                for (int ind = n - 1; ind >= 0; ind--) {
                    for (int buy = 0; buy <= 1; buy++) {
                        if (buy == 0) { // We can buy the stock
                            profit = max(0 + ahead[0], -Arr[ind] + ahead[1]);
                        }

                        if (buy == 1) { // We can sell the stock
                            profit = max(0 + ahead[1], Arr[ind] - fee + ahead[0]);
                        }
                        cur[buy] = profit;
                    }

                    ahead = cur;
                }
                return cur[0]; // Return the maximum profit for buying.
            }

    // DP ON Longest Increasing Subsequence
    // Longest Increasing Subsequence
        // Memoization
            // Function to find the length of the longest increasing subsequence
            int getAns(int arr[], int n, int ind, int prev_index, vector<vector<int>>& dp) {
                // Base condition
                if (ind == n)
                    return 0;
                    
                if (dp[ind][prev_index + 1] != -1)
                    return dp[ind][prev_index + 1];
                
                int notTake = 0 + getAns(arr, n, ind + 1, prev_index, dp);
                
                int take = 0;
                
                if (prev_index == -1 || arr[ind] > arr[prev_index]) {
                    take = 1 + getAns(arr, n, ind + 1, ind, dp);
                }
                
                return dp[ind][prev_index + 1] = max(notTake, take);
            }

            int longestIncreasingSubsequence(int arr[], int n) {
                // Create a 2D DP array initialized to -1
                vector<vector<int>> dp(n, vector<int>(n + 1, -1));
                
                return getAns(arr, n, 0, -1, dp);
            }
    // Printing Longest Increasing Subsequence
        int longestIncreasingSubsequence(int arr[], int n){
    
            vector<int> dp(n,1);
            vector<int> hash(n,1);
            
            for(int i=0; i<=n-1; i++){
                
                hash[i] = i; // initializing with current index
                for(int prev_index = 0; prev_index <=i-1; prev_index ++){
                    
                    if(arr[prev_index]<arr[i] && 1 + dp[prev_index] > dp[i]){
                        dp[i] = 1 + dp[prev_index];
                        hash[i] = prev_index;
                    }
                }
            }
            
            int ans = -1;
            int lastIndex =-1;
            
            for(int i=0; i<=n-1; i++){
                if(dp[i]> ans){
                    ans = dp[i];
                    lastIndex = i;
                }
            }
            
            vector<int> temp;
            temp.push_back(arr[lastIndex]);
            
            while(hash[lastIndex] != lastIndex){ // till not reach the initialization value
                lastIndex = hash[lastIndex];
                temp.push_back(arr[lastIndex]);    
            }
            
            // reverse the array 
            reverse(temp.begin(),temp.end());
            
            cout<<"The subsequence elements are ";
            
            for(int i=0; i<temp.size(); i++){
                cout<<temp[i]<<" ";
            }
            cout<<endl;
            
            return ans;
        }
    // Longest Increasing Subsequence | Binary Search
        int longestIncreasingSubsequence(int arr[], int n) {
            // Create a temporary vector to store the increasing subsequence
            vector<int> temp;
            temp.push_back(arr[0]);

            int len = 1;

            for (int i = 1; i < n; i++) {
                if (arr[i] > temp.back()) {
                    // If arr[i] is greater than the last element of temp, extend the subsequence
                    temp.push_back(arr[i]);
                    len++;
                } else {
                    // If arr[i] is not greater, replace the element in temp with arr[i]
                    int ind = lower_bound(temp.begin(), temp.end(), arr[i]) - temp.begin();
                    temp[ind] = arr[i];
                }
            }

            return len;
        }
    // Largest Divisible Subset
        // Function to find the longest divisible subset
        vector<int> divisibleSet(vector<int>& arr) {
            int n = arr.size();

            // Sort the array in ascending order
            sort(arr.begin(), arr.end());

            vector<int> dp(n, 1);   // dp[i] stores the length of the divisible subset ending at arr[i]
            vector<int> hash(n, i); // hash[i] stores the previous index in the divisible subset ending at arr[i]

            for (int i = 0; i < n; i++) {
                hash[i] = i; // Initialize with the current index
                for (int prev_index = 0; prev_index < i; prev_index++) {
                    if (arr[i] % arr[prev_index] == 0 && 1 + dp[prev_index] > dp[i]) {
                        dp[i] = 1 + dp[prev_index];
                        hash[i] = prev_index;
                    }
                }
            }

            int ans = -1;
            int lastIndex = -1;

            for (int i = 0; i < n; i++) {
                if (dp[i] > ans) {
                    ans = dp[i];
                    lastIndex = i;
                }
            }

            vector<int> temp;
            temp.push_back(arr[lastIndex]);

            // Reconstruct the divisible subset using the hash table
            while (hash[lastIndex] != lastIndex) {
                lastIndex = hash[lastIndex];
                temp.push_back(arr[lastIndex]);
            }

            // Reverse the array to get the correct order
            reverse(temp.begin(), temp.end());

            return temp;
        }
    // Longest String Chain
        bool compare(string& s1, string& s2){
            if(s1.size() != s2.size() + 1) return false;
            
            int first = 0;
            int second = 0;
            
            while(first < s1.size()){
                if(second < s2.size() && s1[first] == s2[second]){
                    first ++;
                    second ++;
                }
                else first ++;
            }
            if(first == s1.size() && second == s2.size()) return true;
            else return false; 
        }
        bool comp(string& s1, string& s2){
            return s1.size() < s2.size();
        }
        int longestStrChain(vector<string>& arr){

            int n = arr.size();
            
            //sort the array
            
            sort(arr.begin(), arr.end(),comp);

            vector<int> dp(n,1);
            
            int maxi = 1;
            
            for(int i=0; i<=n-1; i++){
                
                for(int prev_index = 0; prev_index <=i-1; prev_index ++){
                    
                    if( compare(arr[i], arr[prev_index]) && 1 + dp[prev_index] > dp[i]){
                        dp[i] = 1 + dp[prev_index];
                    }
                }
                
                if(dp[i] > maxi)
                    maxi = dp[i];
            }
            return maxi;
        }
    // Longest Bitonic Subsequence
        // Function to find the length of the longest bitonic subsequence
        int longestBitonicSequence(vector<int>& arr, int n) {
            // Initialize two arrays to store the increasing and decreasing subsequences
            vector<int> dp1(n, 1); // dp1[i] stores the length of the longest increasing subsequence ending at arr[i]
            vector<int> dp2(n, 1); // dp2[i] stores the length of the longest decreasing subsequence ending at arr[i]

            // Calculate the longest increasing subsequence
            for (int i = 0; i < n; i++) {
                for (int prev_index = 0; prev_index < i; prev_index++) {
                    if (arr[prev_index] < arr[i]) {
                        dp1[i] = max(dp1[i], 1 + dp1[prev_index]);
                    }
                }
            }

            // Reverse the direction of nested loops to calculate the longest decreasing subsequence
            for (int i = n - 1; i >= 0; i--) {
                for (int prev_index = n - 1; prev_index > i; prev_index--) {
                    if (arr[prev_index] < arr[i]) {
                        dp2[i] = max(dp2[i], 1 + dp2[prev_index]);
                    }
                }
            }

            int maxi = -1;

            // Find the maximum length of the bitonic subsequence
            for (int i = 0; i < n; i++) {
                maxi = max(maxi, dp1[i] + dp2[i] - 1);
            }

            return maxi;
        }
    // Number of Longest Increasing Subsequences
        // Function to find the count of Longest Increasing Subsequences (LIS)
        int findNumberOfLIS(vector<int>& arr) {
            int n = arr.size();

            vector<int> dp(n, 1); // dp[i] stores the length of the LIS ending at arr[i]
            vector<int> ct(n, 1); // ct[i] stores the count of LIS ending at arr[i]

            int maxi = 1; // Initialize the maximum length as 1

            for (int i = 0; i < n; i++) {
                for (int prev_index = 0; prev_index < i; prev_index++) {
                    if (arr[prev_index] < arr[i] && dp[prev_index] + 1 > dp[i]) {
                        dp[i] = dp[prev_index] + 1;
                        // Inherit count
                        ct[i] = ct[prev_index];
                    } else if (arr[prev_index] < arr[i] && dp[prev_index] + 1 == dp[i]) {
                        // Increase the count
                        ct[i] = ct[i] + ct[prev_index];
                    }
                }
                maxi = max(maxi, dp[i]);
            }

            int numberOfLIS = 0;

            for (int i = 0; i < n; i++) {
                if (dp[i] == maxi) {
                    numberOfLIS += ct[i];
                }
            }

            return numberOfLIS;
        }

    // MCM (Matrix Chain Multiplication) | Partition DP
    // MCM (Matrix Chain Multiplication) | Partition DP
        1. Start with Entire Block
            Start point (i) and end point (j)
        2. Try all Partitions
            run a loop to try all Partitions
        3. Return the Best Possible of Two Partitions
    // Matrix Chain Multiplication | Recursive | Memoization
        // Recursive
            int f(vector<int>& arr, int i, int j){
                // base condition
                if(i == j)
                    return 0;
                    
                int mini = INT_MAX;
                
                // partioning loop
                for(int k = i; k<= j-1; k++){
                    
                    int ans = f(arr,i,k) + f(arr, k+1,j) + arr[i-1]*arr[k]*arr[j];
                    
                    mini = min(mini,ans);
                    
                }
                
                return mini;
            }
            int matrixMultiplication(vector<int>& arr, int N){
                
                int i =1;
                int j = N-1;
                
                
                return f(arr,i,j);
                
                
            }
        // Memoization
            int f(vector<int>& arr, int i, int j, vector<vector<int>>& dp){
                
                // base condition
                if(i == j)
                    return 0;
                    
                if(dp[i][j]!=-1)
                    return dp[i][j];
                
                int mini = INT_MAX;
                
                // partioning loop
                for(int k = i; k<= j-1; k++){
                    
                    int ans = f(arr,i,k,dp) + f(arr, k+1,j,dp) + arr[i-1]*arr[k]*arr[j];
                    
                    mini = min(mini,ans);
                    
                }
                
                return mini;
            }
            int matrixMultiplication(vector<int>& arr, int N){
                
                vector<vector<int>> dp(N,vector<int>(N,-1));
                
                int i =1;
                int j = N-1;
                
                
                return f(arr,i,j,dp);
                
                
            }
    // Matrix Chain Multiplication | Tabulation
        // Function to find the minimum number of operations for matrix multiplication
        int matrixMultiplication(vector<int>& arr, int N) {
            // Create a DP table to store the minimum number of operations
            vector<vector<int>> dp(N, vector<int>(N, -1));

            // Initialize the diagonal elements of the DP table to 0
            for (int i = 0; i < N; i++) {
                dp[i][i] = 0;
            }

            // Loop for the length of the chain
            for (int len = 2; len < N; len++) {
                for (int i = 1; i < N - len + 1; i++) {
                    int j = i + len - 1;
                    dp[i][j] = INT_MAX;

                    // Try different partition points to find the minimum
                    for (int k = i; k < j; k++) {
                        int cost = dp[i][k] + dp[k + 1][j] + arr[i - 1] * arr[k] * arr[j];
                        dp[i][j] = min(dp[i][j], cost);
                    }
                }
            }

            // The result is stored in dp[1][N-1]
            return dp[1][N - 1];
        }
    // Minimum Cost to Cut the Stick
        // Memoization
            int findMinimumCost(int i, int j, vector<int> &cuts, vector<vector<int>> &dp) {
                // Base case: If i is greater than j, there are no cuts to consider.
                if (i > j) {
                    return 0;
                }

                if (dp[i][j] != -1) {
                    return dp[i][j];
                }

                int mini = INT_MAX;

                for (int ind = i; ind <= j; ind++) {
                    // Calculate the cost for making a cut at position 'ind'.
                    int ans = cuts[j + 1] - cuts[i - 1] +
                            findMinimumCost(i, ind - 1, cuts, dp) +
                            findMinimumCost(ind + 1, j, cuts, dp);

                    mini = min(mini, ans);
                }

                return dp[i][j] = mini;
            }

            // Function to compute the minimum cost
            int minimumCost(int n, int c, vector<int> &cuts) {
                // Modify the cuts array by adding 0 at the beginning and 'n' at the end.
                cuts.push_back(n);
                cuts.insert(cuts.begin(), 0);
                sort(cuts.begin(), cuts.end());

                // Create a DP table to store calculated values.
                vector<vector<int>> dp(c + 1, vector<int>(c + 1, -1));

                // Call the recursive function to find the minimum cost.
                return findMinimumCost(1, c, cuts, dp);
            }
        // Tabulation
            // Function to compute the minimum cost incurred
            int minimumCost(int n, int c, vector<int> &cuts) {
                // Modify the cuts array by adding 0 at the beginning and 'n' at the end.
                cuts.push_back(n);
                cuts.insert(cuts.begin(), 0);
                sort(cuts.begin(), cuts.end());

                // Create a DP table to store calculated values.
                vector<vector<int>> dp(c + 2, vector<int>(c + 2, 0));

                for (int i = c; i >= 1; i--) {
                    for (int j = 1; j <= c; j++) {
                        if (i > j) continue;

                        int mini = INT_MAX;

                        for (int ind = i; ind <= j; ind++) {
                            // Calculate the cost for making a cut at position 'ind'.
                            int ans = cuts[j + 1] - cuts[i - 1] + dp[i][ind - 1] + dp[ind + 1][j];

                            mini = min(mini, ans);
                        }

                        dp[i][j] = mini;
                    }
                }

                return dp[1][c];
            }
// Graphs
## Graphs 1: Introduction, DFS & Cycle Detection ##
    // Adjacency Matrix
        vector<vector<int>> createAdjMatrix(int n, const vector<vector<int>>& edges) {
            // Create an NxN adjacency matrix initialized to 0
            vector<vector<int>> adjMatrix(n, vector<int>(n, 0));
            // Fill the matrix using the edges
            for (const auto& edge : edges) {
                int u = edge[0];
                int v = edge[1];
                // Set matrix[u][v] = 1
                adjMatrix[u][v] = 1;
                // For undirected graph, also set matrix[v][u] = 1
                adjMatrix[v][u] = 1;
            }
            return adjMatrix;
        }
    // Adjacency Lits
        vector<vector<int>> createAdjList(int n, const vector<vector<int>>& edges) {
            // Create an adjacency list with n empty lists
            vector<vector<int>> adjList(n);
            // Populate the adjacency list from the edges
            for (const auto& edge : edges) {
                int u = edge[0];
                int v = edge[1];
                // Add v to u's list
                adjList[u].push_back(v);
                // For undirected graphs, add u to v's list
                adjList[v].push_back(u);
            }

            return adjList;
        }
    // DFS Recursive
        void DFS(int node, const vector<vector<int>>& adjList, vector<bool>& visited, vector<int> &ls) {
            // Mark the current node as visited
            visited[node] = true;
            ls.push_back(node); // print node

            // Visit all the unvisited adjacent nodes
            for (int neighbor : adjList[node]) {
                if (!visited[neighbor]) {
                    DFS(neighbor, adjList, visited);  // Recurse for unvisited neighbor
                }
            }
        }
    // DFS Iterative (Using a Stack)
        void DFS_iterative(int start, const vector<vector<int>>& adjList) {
            int n = adjList.size();
            vector<int> ls;
            vector<bool> visited(n, false);
            stack<int> st;

            st.push(start);
            while (!st.empty()) {
                int node = st.top();
                st.pop();

                if (!visited[node]) {
                    visited[node] = true;
                    ls.push_back(node);  // Print the node (or perform some operation on it)

                    // Add all unvisited neighbors to the stack
                    for (int neighbor : adjList[node]) {
                        if (!visited[neighbor]) {
                            st.push(neighbor);
                        }
                    }
                }
            }
        }
    // Cycle Detection Using DFS
        bool dfs(int node, vector<vector<int>>& adjList, vector<int>& visited, vector<int>& path) {
            // Mark the current node as part of the current path (recursion stack)
            path[node] = 1;
            visited[node] = 1;

            // Traverse all adjacent nodes
            for (int neighbor : adjList[node]) {
                if (path[neighbor] == 1) {
                    // If the neighbor is already in the recursion stack, a cycle is detected
                    return true;
                }
                if (visited[neighbor] == 0 && dfs(neighbor, adjList, visited, path)) {
                    // If the neighbor is unvisited, continue DFS recursively
                    return true;
                }
            }

            // Mark the current node as fully processed and remove it from the current path
            path[node] = 0;
            return false;
        }
        bool hasCycle(int n, vector<vector<int>>& adjList) {
            vector<int> visited(n, 0);  // 0: unvisited, 1: visited (currently in DFS), 2: fully processed
            vector<int> path(n, 0);     // 0: not in the current path, 1: in the current path (recursion stack)

            // Perform DFS for each unvisited node
            for (int i = 0; i < n; i++) {
                if (visited[i] == 0) {
                    if (dfs(i, adjList, visited, path)) {
                        return true;  // Cycle found
                    }
                }
            }
            return false;  // No cycle found
        }
    // Q1. Path in Directed Graph
        /*
        Q.1 -> Given an directed graph having A nodes labelled from 1 to A containing M edges given by matrix B of size M x 2such that there is a edge directed from node
        B[i][0] to node B[i][1].
        Find whether a path exists from node 1 to node A.
        Return 1 if path exists else return 0.

        NOTE:
            There are no self-loops in the graph.
            There are no multiple edges between two nodes.
            The graph may or may not be connected.
            Nodes are numbered from 1 to A.
            Your solution will run on multiple test cases. If you are using global variables make sure to clear them.

        Problem Constraints
            2 <= A <= 105
            1 <= M <= min(200000,A*(A-1))
            1 <= B[i][0], B[i][1] <= A

        Input Format
            The first argument given is an integer A representing the number of nodes in the graph.
            The second argument given a matrix B of size M x 2 which represents the M edges such that there is a edge directed from node B[i][0] to node B[i][1].

        Output Format
            Return 1 if path exists between node 1 to node A else return 0.

        Input 1:
            A = 5
            B = [  [1, 2] 
                    [4, 1] 
                    [2, 4] 
                    [3, 4] 
                    [5, 2] 
                    [1, 3] ]

        Output 1:
            0

        Input 2:
            A = 5
            B = [  [1, 2]
                    [2, 3] 
                    [3, 4] 
                    [4, 5] ]


        Output 2:
            1

        */

        // CODE
        void dfs(int node, vector<vector<int>> &adjList, vector<bool> &visited) {
            // Mark the current node as visited
            visited[node] = true;
            
            // Explore all adjacent nodes
            for (int neighbor : adjList[node]) {
                if (!visited[neighbor]) {
                    dfs(neighbor, adjList, visited);
                }
            }
        }

        int Solution::solve(int A, vector<vector<int> > &B) {
            // Create adjacency list for the graph
            vector<vector<int>> adjList(A + 1);
            for (const auto &edge : B) {
                adjList[edge[0]].push_back(edge[1]);
            }

            // Visited array to track nodes
            vector<bool> visited(A + 1, false);

            // Perform DFS from node 1
            dfs(1, adjList, visited);

            // Check if node A is visited
            return visited[A] ? 1 : 0;
        }
    // Q2. Cycle in Directed Graph
        /*
        Q.2 -> Given an directed graph having A nodes. A matrix B of size M x 2 is given which represents the M edges such that there is a edge directed from node B[i][0] to node B[i][1].
        Find whether the graph contains a cycle or not, return 1 if cycle is present else return 0.

        NOTE:

            The cycle must contain atleast two nodes.
            There are no self-loops in the graph.
            There are no multiple edges between two nodes.
            The graph may or may not be connected.
            Nodes are numbered from 1 to A.
            Your solution will run on multiple test cases. If you are using global variables make sure to clear them.

        Problem Constraints
            2 <= A <= 105
            1 <= M <= min(200000,A*(A-1))
            1 <= B[i][0], B[i][1] <= A

        Input Format
            The first argument given is an integer A representing the number of nodes in the graph.
            The second argument given a matrix B of size M x 2 which represents the M edges such that there is a edge directed from node B[i][0] to node B[i][1].

        Output Format
            Return 1 if cycle is present else return 0.

        Input 1:
            A = 5
            B = [  [1, 2] 
                    [4, 1] 
                    [2, 4] 
                    [3, 4] 
                    [5, 2] 
                    [1, 3] ]

        Output 1:
            1

        Input 2:
            A = 5
            B = [  [1, 2]
                    [2, 3] 
                    [3, 4] 
                    [4, 5] ]

        Output 2:
            0

        */

        // CODE
        bool dfs(int node, vector<vector<int>> &adjList, vector<int> &visited) {
            // Mark the current node as visiting
            visited[node] = 1;

            // Traverse all adjacent nodes
            for (int neighbor : adjList[node]) {
                if (visited[neighbor] == 0) {
                    // If the neighbor is unvisited, perform DFS
                    if (dfs(neighbor, adjList, visited)) {
                        return true;
                    }
                } else if (visited[neighbor] == 1) {
                    // If the neighbor is in visiting state, we found a cycle
                    return true;
                }
            }

            // Mark the current node as fully processed
            visited[node] = 2;
            return false;
        }
        int Solution::solve(int A, vector<vector<int> > &B) {
            // Create an adjacency list for the graph
            vector<vector<int>> adjList(A + 1);
            for (const auto &edge : B) {
                adjList[edge[0]].push_back(edge[1]);
            }

            // Visited state array
            vector<int> visited(A + 1, 0);

            // Perform DFS from each node to detect cycles
            for (int i = 1; i <= A; ++i) {
                if (visited[i] == 0) {
                    if (dfs(i, adjList, visited)) {
                        return 1;  // Cycle found
                    }
                }
            }

            return 0;  // No cycle found
        }
    // Q1. First Depth First Search
        /*
        Q.1 -> You are given N towns (1 to N). All towns are connected via unique directed path as mentioned in the input.
        Given 2 towns find whether you can reach the first town from the second without repeating any edge.
        B C : query to find whether B is reachable from C.
        Input contains an integer array A of size N and 2 integers B and C ( 1 <= B, C <= N ).
        There exist a directed edge from A[i] to i+1 for every 1 <= i < N. Also, it's guaranteed that A[i] <= i for every 1 <= i < N.

        NOTE: Array A is 0-indexed. A[0] = 1 which you can ignore as it doesn't represent any edge.

        Problem Constraints
            1 <= N <= 100000

        Input Format
            First argument is vector A
            Second argument is integer B
            Third argument is integer C

        Output Format
            Return 1 if reachable, 0 otherwise.

        Input 1:
            A = [1, 1, 2]
            B = 1
            C = 2

        Output 1:
            0

        Input 2:
            A = [1, 1, 2]
            B = 2
            C = 1

        Output 2:
            1

        */

        // CODE

        int Solution::solve(vector<int> &A, const int B, const int C) {
            // Number of towns
            int N = A.size();
            // Graph represented as an adjacency list
            vector<vector<int>> graph(N + 1);
            
            // Building the graph based on given directed edges
            for (int i = 1; i < N; ++i) {
                graph[A[i]].push_back(i + 1);
            }
            
            // DFS to check if we can reach B from C
            vector<bool> visited(N + 1, false);

            function<bool(int)> dfs = [&](int node) {
                if (node == B) return true; // Found a path to B
                visited[node] = true;
                
                for (int neighbor : graph[node]) {
                    if (!visited[neighbor]) {
                        if (dfs(neighbor)) return true;
                    }
                }
                
                return false;
            };
            
            return dfs(C) ? 1 : 0; // Return 1 if reachable, else 0
        }
    // Q2. Maximum Depth
        /*
        Q.2 -> Given a Tree of A nodes having A-1 edges. Each node is numbered from 1 to A where 1 is the root of the tree.
        You are given Q queries. In each query, you will be given two integers L and X. Find the value of such node which lies at level L mod (MaxDepth + 1) and has value greater than or equal to X.
        Answer to the query is the smallest possible value or -1, if all the values at the required level are smaller than X.

        NOTE:
            Level and Depth of the root is considered as 0.
            It is guaranteed that each edge will be connecting exactly two different nodes of the tree.
            Please read the input format for more clarification.

        Problem Constraints
            2 <= A, Q(size of array E and F) <= 105
            1 <= B[i], C[i] <= A
            1 <= D[i], E[i], F[i] <= 106

        Input Format
            The first argument is an integer A denoting the number of nodes.
            The second and third arguments are the integer arrays B and C where for each i (0 <= i < A-1), B[i] and C[i] are the nodes connected by an edge.
            The fourth argument is an integer array D, where D[i] denotes the value of the (i+1)th node
            The fifth and sixth arguments are the integer arrays E and F where for each i (0 <= i < Q), E[i] denotes L and F[i] denotes X for ith query.

        Output Format
            Return an array of integers where the ith element denotes the answer to ith query.

        Input 1:
            A = 5
            B = [1, 4, 3, 1]
            C = [5, 2, 4, 4]
            D = [7, 38, 27, 37, 1]
            E = [1, 1, 2]
            F = [32, 18, 26]

        Output 1:
            [37, 37, 27]

        Input 2:
            A = 3
            B = [1, 2]
            C = [3, 1]
            D = [7, 15, 27]
            E = [1, 10, 1]
            F = [29, 6, 26]

        Output 2:
            [-1, 7, 27]

        */

        // CODE
        vector<int> Solution::solve(int A, vector<int> &B, vector<int> &C, vector<int> &D, vector<int> &E, vector<int> &F) {
            // Step 1: Build the adjacency list (edges) for the tree
            vector<vector<int>> edges(A + 1);  // adjacency list for the tree
            
            for (int i = 0; i < B.size(); i++) {
                edges[B[i]].push_back(C[i]);
                edges[C[i]].push_back(B[i]);
            }

            // Step 2: BFS to find tree levels
            vector<int> visited(A + 1, false);
            visited[1] = true;

            vector<vector<int>> tree_level;  
            tree_level.push_back({D[0]});  // Add root node value at level 0

            queue<int> que;
            que.push(1);

            while (!que.empty()) {
                int sz = que.size();
                vector<int> temp;  // Temporarily store the values at the current level

                while (sz--) {
                    int node = que.front();
                    que.pop();

                    // Traverse neighbors (children) of the current node
                    for (auto i : edges[node]) {
                        if (!visited[i]) {
                            temp.push_back(D[i - 1]);  // Add the value of the node at this level
                            que.push(i);
                            visited[i] = true;
                        }
                    }
                }
                
                // If temp is not empty, we have found values for a new level
                if (!temp.empty()) {
                    sort(temp.begin(), temp.end());  // Sort the values at this level
                    tree_level.push_back(temp);
                }
            }

            // Step 3: Answer queries
            vector<int> ans;
            int depth = tree_level.size();  // Depth of the tree (total number of levels)

            for (int i = 0; i < E.size(); i++) {
                int l = E[i] % depth;  // Effective level index after modulo
                int val = F[i];        // Query value

                // Binary search for the smallest element >= val at level l
                int start = 0, end = tree_level[l].size() - 1;
                int answer = -1;

                while (start <= end) {
                    int mid = (start + end) / 2;
                    if (tree_level[l][mid] == val) {
                        answer = val;
                        break;
                    } else if (tree_level[l][mid] < val) {
                        start = mid + 1;
                    } else {
                        answer = tree_level[l][mid];
                        end = mid - 1;
                    }
                }

                ans.push_back(answer);
            }

            return ans;
        }

## Graphs 2: BFS & Matrix Questions ##
    // BFS
        vector<int> bfs(int start, vector<vector<int>>& graph) {
            int n = graph.size();          // Number of nodes
            vector<bool> visited(n, false); // Visited array to track visited nodes
            queue<int> q;                   // Queue for BFS
            vector<int> bfsOrder;           // To store BFS traversal order

            q.push(start);                  // Start BFS from the given node
            visited[start] = true;          // Mark the start node as visited

            while (!q.empty()) {
                int node = q.front();
                q.pop();
                bfsOrder.push_back(node);   // Process the current node

                // Visit all neighbors of the current node
                for (int neighbor : graph[node]) {
                    if (!visited[neighbor]) {
                        visited[neighbor] = true; // Mark neighbor as visited
                        q.push(neighbor);         // Enqueue for future processing
                    }
                }
            }

            return bfsOrder; // Return the BFS traversal order
        }
    // Q1. Rotten Oranges
        /*
        Q.1 -> Given a matrix of integers A of size N x M consisting of 0, 1 or 2.
        Each cell can have three values:
        The value 0 representing an empty cell.
        The value 1 representing a fresh orange.
        The value 2 representing a rotten orange.
        Every minute, any fresh orange that is adjacent (Left, Right, Top, or Bottom) to a rotten orange becomes rotten. Return the minimum number of minutes that must elapse until no cell has a fresh orange. If this is impossible, return -1 instead.

        Note: Your solution will run on multiple test cases. If you are using global variables, make sure to clear them.

        Problem Constraints
            1 <= N, M <= 1000
            0 <= A[i][j] <= 2

        Input Format
            The first argument given is the integer matrix A.  

        Output Format
            Return the minimum number of minutes that must elapse until no cell has a fresh orange.
            If this is impossible, return -1 instead.

        Input 1:
            A = [   [2, 1, 1]
                [1, 1, 0]
                [0, 1, 1]   ]

        Output 1:
            4

        Input 2:
            A = [   [2, 1, 1]
                [0, 1, 1]
                [1, 0, 1]   ]

        Output 2:
            -1

        */

        // CODE
        int Solution::solve(vector<vector<int> > &A) {
            int n = A.size();
            if (n == 0) return -1;
            int m = A[0].size();
            
            std::queue<std::pair<int, int>> q;  // Queue to store coordinates of rotten oranges
            int freshCount = 0; // Count of fresh oranges
            int minutes = 0;
            
            // Directions for adjacent cells (top, right, bottom, left)
            int directions[4][2] = {{-1, 0}, {1, 0}, {0, 1}, {0, -1}};
            
            // Traverse the matrix to find rotten oranges and count fresh ones
            for (int i = 0; i < n; ++i) {
                for (int j = 0; j < m; ++j) {
                    if (A[i][j] == 2) {
                        q.push({i, j}); // Push all rotten oranges initially
                    } else if (A[i][j] == 1) {
                        freshCount++;
                    }
                }
            }
            
            // If no fresh oranges, return 0
            if (freshCount == 0) return 0;
            
            // BFS to spread the rot
            while (!q.empty()) {
                int size = q.size();
                bool rottenInThisMinute = false;
                
                for (int i = 0; i < size; ++i) {
                    auto [x, y] = q.front(); q.pop();
                    
                    // Check all 4 adjacent cells
                    for (auto &dir : directions) {
                        int newX = x + dir[0];
                        int newY = y + dir[1];
                        
                        // If adjacent cell is within bounds and contains a fresh orange
                        if (newX >= 0 && newY >= 0 && newX < n && newY < m && A[newX][newY] == 1) {
                            A[newX][newY] = 2; // Make it rotten
                            q.push({newX, newY});
                            freshCount--;
                            rottenInThisMinute = true;
                        }
                    }
                }
                
                // If any oranges became rotten this minute, increment the timer
                if (rottenInThisMinute) minutes++;
            }
            
            // If fresh oranges remain, return -1, otherwise return minutes
            return (freshCount == 0) ? minutes : -1;
        }
    // Q2. Number of islands
        /*
        Q.2 -> Given a matrix of integers A of size N x M consisting of 0 and 1. A group of connected 1's forms an island. From a cell (i, j) such that A[i][j] = 1 you can visit any cell that shares a corner with (i, j) and value in that cell is 1.
        More formally, from any cell (i, j) if A[i][j] = 1 you can visit:
        (i-1, j) if (i-1, j) is inside the matrix and A[i-1][j] = 1.
        (i, j-1) if (i, j-1) is inside the matrix and A[i][j-1] = 1.
        (i+1, j) if (i+1, j) is inside the matrix and A[i+1][j] = 1.
        (i, j+1) if (i, j+1) is inside the matrix and A[i][j+1] = 1.
        (i-1, j-1) if (i-1, j-1) is inside the matrix and A[i-1][j-1] = 1.
        (i+1, j+1) if (i+1, j+1) is inside the matrix and A[i+1][j+1] = 1.
        (i-1, j+1) if (i-1, j+1) is inside the matrix and A[i-1][j+1] = 1.
        (i+1, j-1) if (i+1, j-1) is inside the matrix and A[i+1][j-1] = 1.
        Return the number of islands.

        NOTE: Rows are numbered from top to bottom and columns are numbered from left to right.

        Problem Constraints
            1 <= N, M <= 100
            0 <= A[i] <= 1

        Input Format
            The only argument given is the integer matrix A.  

        Output Format
            Return the number of islands.

        Input 1:
            A = [ 
            [0, 1, 0]
            [0, 0, 1]
            [1, 0, 0]
            ]


        Output 1:
            2

        Input 2:
            A = [   
            [1, 1, 0, 0, 0]
            [0, 1, 0, 0, 0]
            [1, 0, 0, 1, 1]
            [0, 0, 0, 0, 0]
            [1, 0, 1, 0, 1]    
            ]

        Output 2:
            5

        */

        // CODE
        void dfs(vector<vector<int>> &A, int i, int j) {
            // Base case: If the cell is out of bounds or not part of an island, return
            if (i < 0 || i >= A.size() || j < 0 || j >= A[0].size() || A[i][j] == 0) {
                return;
            }
            
            // Mark the current cell as visited
            A[i][j] = 0;
            
            // Directions array for 8 possible moves (including diagonals)
            int directions[8][2] = {
                {-1, 0}, {1, 0}, {0, -1}, {0, 1},   // Up, Down, Left, Right
                {-1, -1}, {-1, 1}, {1, -1}, {1, 1}  // 4 Diagonal directions
            };
            
            // Visit all connected cells recursively
            for (int k = 0; k < 8; ++k) {
                int newX = i + directions[k][0];
                int newY = j + directions[k][1];
                dfs(A, newX, newY);
            }
        }


        int Solution::solve(vector<vector<int> > &A) {
            int numIslands = 0;
            int n = A.size();
            if (n == 0) return 0;
            int m = A[0].size();
            
            // Traverse the matrix
            for (int i = 0; i < n; ++i) {
                for (int j = 0; j < m; ++j) {
                    // If a 1 (unvisited cell part of an island) is found
                    if (A[i][j] == 1) {
                        numIslands++;
                        // Use DFS to mark all connected cells
                        dfs(A, i, j);
                    }
                }
            }
            
            return numIslands;
        }

    // Q3. Another BFS
        /*
        Q.3 -> Given a weighted undirected graph having A nodes, a source node C and destination node D.
        Find the shortest distance from C to D and if it is impossible to reach node D from C then return -1.
        You are expected to do it in Time Complexity of O(A + M).

        Note:
        There are no self-loops in the graph.
        No multiple edges between two pair of vertices.
        The graph may or may not be connected.
        Nodes are Numbered from 0 to A-1.
        Your solution will run on multiple testcases. If you are using global variables make sure to clear them.


        Problem Constraints
            1 <= A <= 105
            0 <= B[i][0], B[i][1] < A
            1 <= B[i][2] <= 2
            0 <= C < A
            0 <= D < A

        Input Format
            The first argument given is an integer A, representing the number of nodes.
            The second argument given is the matrix B, where B[i][0] and B[i][1] are connected through an edge of weight B[i][2].
            The third argument given is an integer C, representing the source node.
            The fourth argument is an integer D, representing the destination node.
            Note: B[i][2] will be either 1 or 2.

        Output Format
            Return the shortest distance from C to D. If it is impossible to reach node D from C then return -1.

        Input 1:
        A = 6
        B = [   [2, 5, 1]
                [1, 3, 1] 
                [0, 5, 2] 
                [0, 2, 2] 
                [1, 4, 1] 
                [0, 1, 1] ] 
        C = 3
        D = 2

        Output 1:
        4

        Input 2:
        A = 2
        B = [   [0, 1, 1]
            ] 
        C = 0
        D = 1

        Output 2:
        1

        */

        // CODE
        int Solution::solve(int A, vector<vector<int> > &B, int C, int D) {
            // Calculate maximum size needed for adjacency list based on nodes and extra temp nodes
            int N = B.size() > A ? B.size() : A;
            vector<vector<int>> g(2 * N); // Graph with possible additional nodes for splitting
            vector<int> dist(2 * N, -1);  // Distance vector initialized to -1 (unvisited)
            queue<int> q;

            // Build the adjacency list
            for (int i = 0; i < B.size(); i++) {
                if (B[i][2] == 2) {
                    // If the edge has weight 2, split it into two edges through a temporary node
                    g[B[i][0]].push_back(A + i); // Connect original node to temp node
                    g[A + i].push_back(B[i][1]); // Connect temp node to destination

                    g[B[i][1]].push_back(A + i); // Connect destination to temp node (bidirectional)
                    g[A + i].push_back(B[i][0]); // Connect temp node to original node (bidirectional)
                } else {
                    // Direct connection for edges with weight 1
                    g[B[i][0]].push_back(B[i][1]);
                    g[B[i][1]].push_back(B[i][0]);
                }
            }

            // Initialize BFS from the source node
            dist[C] = 0;
            q.push(C);

            while (!q.empty()) {
                int u = q.front();
                q.pop();

                // Traverse all adjacent nodes
                for (int v : g[u]) {
                    if (dist[v] == -1) { // If the node has not been visited
                        dist[v] = dist[u] + 1;
                        q.push(v);
                    }
                }
            }

            // Return the distance to the destination node
            return dist[D];
        }
    // Q4. Shortest Distance in a Maze
        /*
        Q.4 -> Given a matrix of integers A of size N x M describing a maze. The maze consists of empty locations and walls.
        1 represents a wall in a matrix and 0 represents an empty location in a wall.
        There is a ball trapped in a maze. The ball can go through empty spaces by rolling up, down, left or right, but it won't stop rolling until hitting a wall (maze boundary is also considered as a wall). When the ball stops, it could choose the next direction.
        Given two array of integers of size B and C of size 2 denoting the starting and destination position of the ball.
        Find the shortest distance for the ball to stop at the destination. The distance is defined by the number of empty spaces traveled by the ball from the starting position (excluded) to the destination (included). If the ball cannot stop at the destination, return -1.

        Note :
            

        Problem Constraints
            2 <= N, M <= 100
            0 <= A[i] <= 1
            0 <= B[i][0], C[i][0] < N
            0 <= B[i][1], C[i][1] < M

        Input Format
            The first argument given is the integer matrix A.
            The second argument given is an array of integer B.
            The third argument if an array of integer C.

        Output Format
            Return a single integer, the minimum distance required to reach destination

        Input 1:
        A = [ [0, 0], 
            [0, 0] ]
        B = [0, 0]
        C = [0, 1]

        Output 1:
            1

        Input 2:
        A = [ [0, 1], 
            [1, 0] ]
        B = [0, 0]
        C = [1, 1]

        Output 2:
            -1

        */

        // CODE
        class Quad {
        public:
            int i, j, dir, dist;
        };

        bool check(int x, int y, int dir, vector<vector<vector<int>>>& visited, vector<vector<int>>& A, int n, int m) {
            if (x < 0 || x >= n || y < 0 || y >= m || A[x][y] == 1 || visited[x][y][dir] == 1)
                return false;
            return true;
        }

        int Solution::solve(vector<vector<int> > &A, vector<int> &B, vector<int> &C) {
        int n = A.size();
            int m = A[0].size();
            
            // Visited array for checking visited state for each direction
            vector<vector<vector<int>>> visited(n, vector<vector<int>>(m, vector<int>(4, 0)));
            
            // BFS queue
            queue<Quad> q;
            
            // Directions for up, right, down, left
            vector<int> u = {-1, 0, 1, 0};  // row changes for directions
            vector<int> v = {0, 1, 0, -1};  // column changes for directions
            
            // Initially, the ball is at the starting position B[0], B[1]
            // We push the adjacent cells in all 4 directions if they are valid
            bool flag = false;
            
            for (int i = 0; i < 4; i++) {
                int x = B[0] + u[i];
                int y = B[1] + v[i];
                if (check(x, y, i, visited, A, n, m)) {
                    q.push({x, y, i, 1});
                } else {
                    flag = true;
                }
            }

            // If flag is true and the start is the destination, return 0
            if (flag && B[0] == C[0] && B[1] == C[1]) {
                return 0;
            }

            // BFS loop to explore the shortest path
            while (!q.empty()) {
                Quad root = q.front();
                q.pop();
                
                int v1 = root.i;
                int v2 = root.j;
                int dir = root.dir;
                int dist = root.dist;
                
                visited[v1][v2][dir] = 1;
                
                int dir_v1 = v1 + u[dir];
                int dir_v2 = v2 + v[dir];
                
                // Check if the ball has reached the destination
                if (v1 == C[0] && v2 == C[1] && (dir_v1 < 0 || dir_v1 >= n || dir_v2 < 0 || dir_v2 >= m || A[dir_v1][dir_v2] == 1)) {
                    return dist;
                }

                // If the ball is still valid, continue rolling in the current direction
                if (check(dir_v1, dir_v2, dir, visited, A, n, m)) {
                    q.push({dir_v1, dir_v2, dir, dist + 1});
                } else {
                    // Try all 4 directions
                    for (int i = 0; i < 4; i++) {
                        int x = v1 + u[i];
                        int y = v2 + v[i];
                        if (check(x, y, i, visited, A, n, m)) {
                            q.push({x, y, i, dist + 1});
                        }
                    }
                }
            }

            // If no valid path is found
            return -1;
        }
    // Q1. Valid Path
        /*
        Q.1 -> There is a rectangle with left bottom as (0, 0) and right up as (x, y).
        There are N circles such that their centers are inside the rectangle.
        Radius of each circle is R. Now we need to find out if it is possible that we can move from (0, 0) to (x, y) without touching any circle.
        Note : We can move from any cell to any of its 8 adjecent neighbours and we cannot move outside the boundary of the rectangle at any point of time.



        Note :
            

        Problem Constraints
            0 <= x , y, R <= 100
            1 <= N <= 1000
            Center of each circle would lie within the grid

        Input Format
            1st argument given is an Integer x , denoted by A in input.
            2nd argument given is an Integer y, denoted by B in input.
            3rd argument given is an Integer N, number of circles, denoted by C in input.
            4th argument given is an Integer R, radius of each circle, denoted by D in input.
            5th argument given is an Array A of size N, denoted by E in input, where A[i] = x cordinate of ith circle
            6th argument given is an Array B of size N, denoted by F in input, where B[i] = y cordinate of ith circle

        Output Format
            Return YES or NO depending on weather it is possible to reach cell (x,y) or not starting from (0,0).

        Input 1:
            x = 2
            y = 3
            N = 1
            R = 1
            A = [2]
            B = [3]

        Output 1:
            NO

        Input 2:
            x = 3
            y = 3
            N = 1
            R = 1
            A = [0]
            B = [3]

        Output 2:
            YES

        */

        // CODE
        bool isInsideCircle(int x, int y, int R, const vector<int> &E, const vector<int> &F) {
            for (int i = 0; i < E.size(); ++i) {
                int dx = x - E[i];
                int dy = y - F[i];
                if (dx * dx + dy * dy <= R * R) {
                    return true; // Point is inside or touching a circle
                }
            }
            return false;
        }

        string Solution::solve(int A, int B, int C, int D, vector<int> &E, vector<int> &F) {
            if (isInsideCircle(0, 0, D, E, F) || isInsideCircle(A, B, D, E, F)) {
                return "NO"; // Start or end point is inside a circle
            }

            vector<vector<bool>> visited(A + 1, vector<bool>(B + 1, false));
            queue<pair<int, int>> q;
            q.push({0, 0});
            visited[0][0] = true;

            int directions[8][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0},
                                    {1, 1}, {1, -1}, {-1, 1}, {-1, -1}};

            while (!q.empty()) {
                auto [x, y] = q.front();
                q.pop();

                if (x == A && y == B) {
                    return "YES"; // Successfully reached the destination
                }

                for (int i = 0; i < 8; ++i) {
                    int nx = x + directions[i][0];
                    int ny = y + directions[i][1];

                    if (nx >= 0 && ny >= 0 && nx <= A && ny <= B && !visited[nx][ny] && !isInsideCircle(nx, ny, D, E, F)) {
                        visited[nx][ny] = true;
                        q.push({nx, ny});
                    }
                }
            }

            return "NO"; // No path found
        }
    // Q2. Capture Regions on Board
        /*
        Q.2 -> Given a 2-D board A of size N x M containing 'X' and 'O', capture all regions surrounded by 'X'.
        A region is captured by flipping all 'O's into 'X's in that surrounded region.

        Note :
            

        Problem Constraints
            1 <= N, M <= 1000

        Input Format
            First and only argument is a N x M character matrix A.

        Output Format
            Return nothing. Make changes to the the input only as matrix is passed by reference.

        Input 1:
        A = [ 
            [X, X, X, X],
            [X, O, O, X],
            [X, X, O, X],
            [X, O, X, X] 
            ]

        Output 1:
        After running your function, the board should be:
        A = [
            [X, X, X, X],
            [X, X, X, X],
            [X, X, X, X],
            [X, O, X, X]
            ]

        Input 2:
        A = [
            [X, O, O],
            [X, O, X],
            [O, O, O]
            ]

        Output 2:
        After running your function, the board should be:
        A = [
            [X, O, O],
            [X, O, X],
            [O, O, O]
            ]


        */

        // CODE
        void markBoundaryDFS(vector<vector<char>> &A, int x, int y, int N, int M) {
            // Base condition to stop recursion
            if (x < 0 || y < 0 || x >= N || y >= M || A[x][y] != 'O') return;

            // Mark the cell as visited (temporarily change it to '#')
            A[x][y] = '#';

            // Explore 4 directions (up, down, left, right)
            markBoundaryDFS(A, x + 1, y, N, M);
            markBoundaryDFS(A, x - 1, y, N, M);
            markBoundaryDFS(A, x, y + 1, N, M);
            markBoundaryDFS(A, x, y - 1, N, M);
        }

        void Solution::solve(vector<vector<char> > &A) {
            // Do not write main() function.
            // Do not read input, instead use the arguments to the function.
            // Do not print the output, instead return values as specified
            // Still have a doubt. Checkout www.interviewbit.com/pages/sample_codes/ for more details

            int N = A.size();
            if (N == 0) return; // No rows
            int M = A[0].size();
            if (M == 0) return; // No columns

            // Step 1: Mark all 'O's on the boundary and connected to the boundary
            for (int i = 0; i < N; ++i) {
                // First and last column of each row
                if (A[i][0] == 'O') markBoundaryDFS(A, i, 0, N, M);
                if (A[i][M - 1] == 'O') markBoundaryDFS(A, i, M - 1, N, M);
            }
            for (int j = 0; j < M; ++j) {
                // First and last row of each column
                if (A[0][j] == 'O') markBoundaryDFS(A, 0, j, N, M);
                if (A[N - 1][j] == 'O') markBoundaryDFS(A, N - 1, j, N, M);
            }

            // Step 2: Flip the regions
            for (int i = 0; i < N; ++i) {
                for (int j = 0; j < M; ++j) {
                    if (A[i][j] == 'O') {
                        A[i][j] = 'X'; // Captured region
                    } else if (A[i][j] == '#') {
                        A[i][j] = 'O'; // Restore uncaptured region
                    }
                }
            }
        }
    // Q3. Black Shapes
        /*
        Q.3 -> Given character matrix A of dimensions NM consisting of O's and X's, where O = white, X = black.
        Return the number of black shapes. A black shape consists of one or more adjacent X's (diagonals not included)

        Note :
            

        Problem Constraints
            1 <= N, M <= 1000
            A[i][j] = 'X' or 'O'

        Input Format
            The First and only argument is character matrix A. 

        Output Format
            Return a single integer denoting number of black shapes.

        Input 1:
            A = [ [X, X, X], [X, X, X], [X, X, X] ]

        Output 1:
            1

        Input 2:
            A = [ [X, O], [O, X] ]

        Output 2:
            2

        */

        // CODE
        void dfs(vector<string> &A, int x, int y, int N, int M) {
            // Base condition: out of bounds or not a black cell
            if (x < 0 || y < 0 || x >= N || y >= M || A[x][y] != 'X') {
                return;
            }

            // Mark the current cell as visited
            A[x][y] = 'O';

            // Explore 4 possible directions (up, down, left, right)
            int directions[4][2] = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
            for (int i = 0; i < 4; ++i) {
                int nx = x + directions[i][0];
                int ny = y + directions[i][1];
                dfs(A, nx, ny, N, M);
            }
        }

        int Solution::black(vector<string> &A) {
            int N = A.size();
            if (N == 0) return 0;
            int M = A[0].size();
            int blackShapes = 0;

            // Traverse the matrix to find and count all black shapes
            for (int i = 0; i < N; ++i) {
                for (int j = 0; j < M; ++j) {
                    if (A[i][j] == 'X') {
                        // Found a new black shape, perform DFS
                        ++blackShapes;
                        dfs(A, i, j, N, M);
                    }
                }
            }

            return blackShapes;
        }
    // Q4. Knight On Chess Board
        /*
        Q.4 -> Given any source point, (C, D) and destination point, (E, F) on a chess board of size A x B, we need to find whether Knight can move to the destination or not.
        The above figure details the movements for a knight ( 8 possibilities ).
        If yes, then what would be the minimum number of steps for the knight to move to the said point. If knight can not move from the source point to the destination point, then return -1.

        NOTE: A knight cannot go out of the board.

        Problem Constraints
            1 <= A, B <= 500

        Input Format
            The first argument of input contains an integer A.
            The second argument of input contains an integer B.
            The third argument of input contains an integer C.
            The fourth argument of input contains an integer D.
            The fifth argument of input contains an integer E.
            The sixth argument of input contains an integer F.

        Output Format
            If it is possible to reach the destination point, return the minimum number of moves.
            Else return -1.

        Input 1:
            A = 8
            B = 8
            C = 1
            D = 1
            E = 8
            F = 8

        Output 1:
            6

        Input 2:
            A = 2
            B = 4
            C = 2
            D = 1
            E = 4
            F = 4

        Output 2:
            -1

        */

        // CODE
        struct Cell {
            int x, y, steps;
        };

        bool isValid(int x, int y, int A, int B, vector<vector<bool>> &visited) {
            return (x >= 1 && x <= A && y >= 1 && y <= B && !visited[x][y]);
        }


        int Solution::knight(int A, int B, int C, int D, int E, int F) {
            // Edge case: if the source is the same as the destination
            if (C == E && D == F) {
                return 0;
            }

            // Directions for the knight's possible moves
            vector<pair<int, int>> directions = {
                {2, 1}, {2, -1}, {-2, 1}, {-2, -1},
                {1, 2}, {1, -2}, {-1, 2}, {-1, -2}
            };

            // BFS initialization
            queue<Cell> q;
            vector<vector<bool>> visited(A + 1, vector<bool>(B + 1, false));
            q.push({C, D, 0});
            visited[C][D] = true;

            // BFS loop
            while (!q.empty()) {
                Cell current = q.front();
                q.pop();

                // Check all possible moves for the knight
                for (auto dir : directions) {
                    int nx = current.x + dir.first;
                    int ny = current.y + dir.second;

                    // If the destination is reached
                    if (nx == E && ny == F) {
                        return current.steps + 1;
                    }

                    // Check if the new position is valid
                    if (isValid(nx, ny, A, B, visited)) {
                        visited[nx][ny] = true;
                        q.push({nx, ny, current.steps + 1});
                    }
                }
            }

            // If we cannot reach the destination
            return -1;
        }

## Graphs 3: MST (Prims Algo.) & Dijkstra Algo ##
    // Prim's Algo
        int spanningTree(int V, vector<vector<int>> adj[])
        {
            priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int>>> pq;

            vector<int> vis(V, 0);
            // {wt, node}
            pq.push({0, 0});
            int sum = 0;
            while (!pq.empty()) {
                auto it = pq.top();
                pq.pop();
                int node = it.second;
                int wt = it.first;

                if (vis[node] == 1) continue;
                // add it to the mst
                vis[node] = 1;
                sum += wt;
                for (auto it : adj[node]) {
                    int adjNode = it[0];
                    int edW = it[1];
                    if (!vis[adjNode]) {
                        pq.push({edW, adjNode});
                    }
                }
            }
            return sum;
        }
    // MST Graph
        void primsUsingPQ(vector<pair<int, int>> adj[], int n) {
            vector<int> parent(n, -1);       // Stores the MST
            vector<int> weights(n, INT_MAX); // Min edge weights
            vector<bool> inMST(n, false);    // Track included vertices

            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;
            pq.push({0, 0}); // {weight, vertex}
            weights[0] = 0;

            while (!pq.empty()) {
                int u = pq.top().second;
                pq.pop();

                if (inMST[u]) continue;
                inMST[u] = true;

                for (auto& edge : adj[u]) {
                    int v = edge.first;
                    int weight = edge.second;

                    if (!inMST[v] && weight < weights[v]) {
                        weights[v] = weight;
                        parent[v] = u;
                        pq.push({weight, v});
                    }
                }
            }

            // Print the MST
            cout << "Edge   Weight\n";
            for (int i = 1; i < n; i++) {
                cout << parent[i] << " - " << i << "    " << weights[i] << endl;
            }
        }
    // Dijkstra's Algorithm - Using Priority Queue - C++ and Java - Part 1
        vector<int> dijkstra(int V, vector<vector<int>> adj[], int S)
        {

            // Create a priority queue for storing the nodes as a pair {dist,node}
            // where dist is the distance from source to the node. 
            // Min Heap
            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;

            // Initialising distTo list with a large number to
            // indicate the nodes are unvisited initially.
            // This list contains distance from source to the nodes.
            vector<int> distTo(V, INT_MAX);

            // Source initialised with dist=0.
            distTo[S] = 0;
            pq.push({0, S});

            // Now, pop the minimum distance node first from the min-heap
            // and traverse for all its adjacent nodes.
            while (!pq.empty())
            {
                int node = pq.top().second;
                int dis = pq.top().first;
                pq.pop();

                // Check for all adjacent nodes of the popped out
                // element whether the prev dist is larger than current or not.
                for (auto it : adj[node])
                {
                    int v = it[0];
                    int w = it[1];
                    if (dis + w < distTo[v])
                    {
                        distTo[v] = dis + w;
        
                        // If current distance is smaller,
                        // push it into the queue.
                        pq.push({dis + w, v});
                    }
                }
            }
            // Return the list containing shortest distances
            // from source to all the nodes.
            return distTo;
        }
    // Q1. Commutable Islands
        /*
        Q.1 -> There are A islands and there are M bridges connecting them. Each bridge has some cost attached to it.
        We need to find bridges with minimal cost such that all islands are connected.
        It is guaranteed that input data will contain at least one possible scenario in which all islands are connected with each other.


        Note :
            

        Problem Constraints
            1 <= A, M <= 6*104
            1 <= B[i][0], B[i][1] <= A
            1 <= B[i][2] <= 103

        Input Format
            The first argument contains an integer, A, representing the number of islands.
            The second argument contains an 2-d integer matrix, B, of size M x 3 where Island B[i][0] and B[i][1] are connected using a bridge of cost B[i][2].

        Output Format
            Return an integer representing the minimal cost required.

        Input 1:
        A = 4
        B = [  [1, 2, 1]
                [2, 3, 4]
                [1, 4, 3]
                [4, 3, 2]
                [1, 3, 10]  ]

        Output 1:
            6

        Input 2:
        A = 4
        B = [  [1, 2, 1]
                [2, 3, 2]
                [3, 4, 4]
                [1, 4, 3]   ]

        Output 2:
            6

        */

        // CODE
        // Helper function to find the root of a node with path compression
        int findParent(int node, vector<int>& parent) {
            if (parent[node] == node) {
                return node;
            }
            // Path compression
            return parent[node] = findParent(parent[node], parent);
        }

        // Helper function to union two sets
        void unionSets(int u, int v, vector<int>& parent, vector<int>& rank) {
            int rootU = findParent(u, parent);
            int rootV = findParent(v, parent);
            
            if (rootU != rootV) {
                if (rank[rootU] > rank[rootV]) {
                    parent[rootV] = rootU;
                } else if (rank[rootU] < rank[rootV]) {
                    parent[rootU] = rootV;
                } else {
                    parent[rootV] = rootU;
                    rank[rootU]++;
                }
            }
        }

        int Solution::solve(int A, vector<vector<int> > &B) {
            // Sort edges by their weight (cost)
            sort(B.begin(), B.end(), [](const vector<int>& a, const vector<int>& b) {
                return a[2] < b[2];
            });

            // Initialize union-find data structures
            vector<int> parent(A + 1);
            vector<int> rank(A + 1, 0);
            
            for (int i = 1; i <= A; ++i) {
                parent[i] = i; // Each node is its own parent initially
            }

            int totalCost = 0;
            for (const vector<int>& edge : B) {
                int u = edge[0];
                int v = edge[1];
                int cost = edge[2];

                // Check if u and v are in different components
                if (findParent(u, parent) != findParent(v, parent)) {
                    totalCost += cost; // Include this edge in the MST
                    unionSets(u, v, parent, rank); // Union the sets
                }
            }

            return totalCost;
        }
    // Q2. Dijkstra
        /*
        Q.2 -> Problem Description
        Given a weighted undirected graph having A nodes and M weighted edges, and a source node C.
        You have to find an integer array D of size A such that:
            D[i]: Shortest distance from the C node to node i.
            If node i is not reachable from C then -1.
        Note:
            There are no self-loops in the graph.
            There are no multiple edges between two pairs of vertices.
            The graph may or may not be connected.
            Nodes are numbered from 0 to A-1.
            Your solution will run on multiple test cases. If you are using global variables, make sure to clear them.

        Problem Constraints
            1 <= A <= 1e5
            0 <= B[i][0],B[i][1] < A
            0 <= B[i][2] <= 1e3
            0 <= C < A

        Input Format
            The first argument is an integer A, representing the number of nodes in the graph.
            The second argument is a matrix B of size M x 3, where each row represents an edge in the graph. The three columns of each row denote the source node B[i][0], the destination node B[i][1], and the weight of the edge B[i][2].
            The third argument is an integer C, representing the source node for which the shortest distance to all other nodes needs to be found.

        Output Format
            Return the integer array D.

        Input 1:
            A = 6
            B = [   [0, 4, 9]
                    [3, 4, 6] 
                    [1, 2, 1] 
                    [2, 5, 1] 
                    [2, 4, 5] 
                    [0, 3, 7] 
                    [0, 1, 1] 
                    [4, 5, 7] 
                    [0, 5, 1] ] 
            C = 4

        Output 1:
            D = [7, 6, 5, 6, 0, 6]

        Input 2:
        A = 5
        B = [   [0, 3, 4]
                [2, 3, 3] 
                [0, 1, 9] 
                [3, 4, 10] 
                [1, 3, 8]  ] 
        C = 4

        Output 2:
            D = [14, 18, 13, 10, 0]

        */

        // CODE
        vector<int> Solution::solve(int A, vector<vector<int> > &B, int C) {
            // Create adjacency list
            vector<vector<pair<int, int>>> adj(A);
            for (const auto& edge : B) {
                int u = edge[0];
                int v = edge[1];
                int weight = edge[2];
                adj[u].emplace_back(v, weight);
                adj[v].emplace_back(u, weight); // Since the graph is undirected
            }

            // Distance array, initialize with infinity
            vector<int> D(A, INT_MAX);
            D[C] = 0; // Distance to source is 0

            // Min-heap priority queue to store {distance, node}
            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<>> pq;
            pq.emplace(0, C);

            while (!pq.empty()) {
                int dist = pq.top().first;
                int node = pq.top().second;
                pq.pop();

                // If the distance in the queue is outdated, skip processing
                if (dist > D[node]) continue;

                // Relaxation step for neighbors
                for (const auto& neighbor : adj[node]) {
                    int nextNode = neighbor.first;
                    int edgeWeight = neighbor.second;
                    if (D[node] + edgeWeight < D[nextNode]) {
                        D[nextNode] = D[node] + edgeWeight;
                        pq.emplace(D[nextNode], nextNode);
                    }
                }
            }

            // Replace INT_MAX with -1 to indicate unreachable nodes
            for (int i = 0; i < A; ++i) {
                if (D[i] == INT_MAX) {
                    D[i] = -1;
                }
            }

            return D;
        }
    // Q3. Construction Cost
        /*
        Q.3 -> Flipkart has A local distribution centers located across a large metropolitan city. Each distribution center needs to be interconnected through roads to facilitate efficient movement of goods. The cost of constructing a road between any two distribution centers is represented by the weight of the edge connecting them.
        Given a graph with A nodes representing the distribution centers and C weighted edges representing the possible roads between them, your task is to find the minimum total cost of constructing roads such that every distribution center can be reached from the first distribution center.

        Cost Calculation:
        The cost of constructing the roads is the sum of the weights of the edges selected for the construction.

        NOTE: Return the answer modulo 10^9+7 as the answer can be large.

        Problem Constraints
            1 <= A <= 100000
            0 <= C <= 100000
            1 <= B[i][0], B[i][1] <= N
            1 <= B[i][2] <= 109

        Input Format
            First argument is an integer A.
            Second argument is a 2-D integer array B of size C3 denoting edges. B[i][0]and B[i][1]are the distribution centers connected by the ith edge with construction cost B[i][2].

        Output Format
            Return an integer denoting the minimum construction cost.

        Input 1:
        A = 3
        B = [   [1, 2, 14]
                [2, 3, 7]
                [3, 1, 2]   ]

        Output 1:
            9

        Input 2:
        A = 3
        B = [   [1, 2, 20]
                [2, 3, 17]  ]

        Output 2:
            37

        */

        // CODE
        const int MOD = 1e9 + 7;

        // Helper function to find the root of a node with path compression
        int findParent(int node, vector<int>& parent) {
            if (parent[node] == node) return node;
            return parent[node] = findParent(parent[node], parent);
        }

        // Helper function to union two sets
        void unionSets(int u, int v, vector<int>& parent, vector<int>& rank) {
            int rootU = findParent(u, parent);
            int rootV = findParent(v, parent);

            if (rootU != rootV) {
                if (rank[rootU] > rank[rootV]) {
                    parent[rootV] = rootU;
                } else if (rank[rootU] < rank[rootV]) {
                    parent[rootU] = rootV;
                } else {
                    parent[rootV] = rootU;
                    rank[rootU]++;
                }
            }
        }

        int Solution::solve(int A, vector<vector<int> > &B) {
            // Special case when there are no edges
            if (B.empty()) return 0;

            // Sort edges by weight
            sort(B.begin(), B.end(), [](const vector<int>& a, const vector<int>& b) {
                return a[2] < b[2];
            });

            // Initialize Union-Find data structures
            vector<int> parent(A + 1), rank(A + 1, 0);
            for (int i = 1; i <= A; ++i) {
                parent[i] = i;
            }

            long long totalCost = 0;
            int edgesUsed = 0;

            // Kruskal's algorithm
            for (const vector<int>& edge : B) {
                int u = edge[0], v = edge[1], weight = edge[2];
                if (findParent(u, parent) != findParent(v, parent)) {
                    unionSets(u, v, parent, rank);
                    totalCost = (totalCost + weight) % MOD;
                    edgesUsed++;
                    // Optimization: Stop early if we have connected all nodes
                    if (edgesUsed == A - 1) break;
                }
            }

            // Check if all nodes are connected (MST contains exactly A - 1 edges)
            return (edgesUsed == A - 1) ? totalCost : -1;
        }
    // Q1. Damaged Roads
        /*
        Q.1 -> You are the Prime Minister of a country and once you went for a world tour.
        After 5 years, when you returned to your country, you were shocked to see the condition of the roads between the cities. So, you plan to repair them, but you cannot afford to spend a lot of money.
        The country can be represented as a (N+1) x (M+1) grid, where Country(i, j) is a city.
        The cost of repairing a road between (i, j) and (i + 1, j) is A[i]. The cost of repairing a road between (i, j) and (i, j + 1) is B[j].
        Return the minimum cost of repairing the roads such that all cities can be visited from city indexed (0, 0).
        As the cost can be large, return the cost modulo 109+7.

        Note :
            

        Problem Constraints
            1 <= N, M <= 105
            1 <= A[i], B[i] <= 103

        Input Format
            The first argument will be an integer array, A, of size N.
            The second argument will be an integer array, B, of size M.  

        Output Format
            Return an integer representing the minimum possible cost.

        Input 1:
            A = [1, 1, 1]
            B = [1, 1, 2]

        Output 1:
            16

        Input 2:
            A = [1, 2, 3]
            B = [4, 5, 6]

        Output 2:
            39

        */

        // CODE
        int Solution::solve(vector<int> &A, vector<int> &B) {
        const int MOD = 1e9 + 7;
            int n = A.size();
            int m = B.size();
            
            // Maintain row, column movement costs
            vector<pair<int, int>> v;
            
            // Vertical movement cost indicated by 1
            for (int i = 0; i < n; i++) {
                v.emplace_back(A[i], 1);
            }
            
            // Horizontal movement cost indicated by 0
            for (int j = 0; j < m; j++) {
                v.emplace_back(B[j], 0);
            }
            
            // Sort the array in ascending order
            sort(v.begin(), v.end());
            
            // Increment n and m
            n++, m++;
            long long minCost = 0;
            
            // Loop through the sorted costs vector to calculate minimum cost
            for (auto x : v) {
                if (x.second == 0) {
                    minCost += (n * x.first);
                    // Decrement the number of columns
                    m--;
                } else if (x.second == 1) {
                    minCost += (m * x.first);
                    // Decrement the number of rows
                    n--;
                }
            }
            
            return (minCost %= MOD);
        }
    // Q2. Edge in MST
        /*
        Q.2 -> Given a undirected weighted graph with A nodes labelled from 1 to A with M edges given in a form of 2D-matrix B of size M * 3 where B[i][0] and B[i][1] denotes the two nodes connected by an edge of weight B[i][2].
        For each edge check whether it belongs to any of the possible minimum spanning tree or not , return 1 if it belongs else return 0.
        Return an one-dimensional binary array of size M denoting answer for each edge.

        NOTE:
            The graph may be disconnected in that case consider mst for each component.
            No self-loops and no multiple edges present.
            Answers in output array must be in order with the input array B output[i] must denote the answer of edge B[i][0] to B[i][1].


        Problem Constraints
            1 <= A, M <= 3*105
            1 <= B[i][0], B[i][1] <= A
            1 <= B[i][1] <= 103

        Input Format
            The first argument given is an integer A representing the number of nodes in the graph.
            The second argument given is an matrix B of size M x 3 which represents the M edges such that there is a edge between node B[i][0] and node B[i][1] with weight B[i][2]. 

        Output Format
            Return an one-dimensional binary array of size M denoting answer for each edge.

        Input 1:
        A = 3
        B = [ [1, 2, 2]
            [1, 3, 2]
            [2, 3, 3]
            ]

        Output 1:
            [1, 1, 0]



        */

        // CODE
        bool cmp(vector<int> &a, vector<int> &b) {
            return a[2] < b[2];
        }

        int find_root(int node, vector<int> &is_connection) {
            if (is_connection[node] == node) return node;
            is_connection[node] = find_root(is_connection[node], is_connection);
            return is_connection[node];
        }

        void connect_node(int parent, int child, vector<int> &is_connection) {
            int root_p = find_root(parent, is_connection);
            int root_c = find_root(child, is_connection);
            if (root_c != root_p) {
                is_connection[root_c] = root_p;
            }
        }

        vector<int> Solution::solve(int a, vector<vector<int>> &b) {
            // Create edge array with original indices
            vector<vector<int>> edge(b.size());
            for (int i = 0; i < b.size(); i++) {
                edge[i] = b[i];
                edge[i].push_back(i);  // Store original index
            }

            // Sort edges by weight in ascending order
            sort(edge.begin(), edge.end(), cmp);

            // Result vector to store if edge is part of an MST (1 if true, 0 if false)
            vector<int> is_mst(b.size(), 0);
            // DSU (Disjoint Set Union) initialization for tracking connectivity
            vector<int> is_connection(a + 1, 0);
            for (int i = 1; i <= a; i++) {
                is_connection[i] = i;
            }

            // Main loop to check MST conditions for edges
            for (int i = 0; i < b.size(); i++) {
                // Handle edges with the same weight using a secondary loop
                for (int k = i; k < b.size() && (edge[i][2] == edge[k][2]); k++) {
                    // Check if the nodes are connected
                    if (find_root(edge[k][0], is_connection) != find_root(edge[k][1], is_connection)) {
                        is_mst[edge[k][3]] = 1;
                    }
                }
                // Union operation for edges with the same weight
                for (int k = i; k < b.size() && (edge[i][2] == edge[k][2]); k++) {
                    if (find_root(edge[k][0], is_connection) != find_root(edge[k][1], is_connection)) {
                        connect_node(edge[k][0], edge[k][1], is_connection);
                    }
                }
            }

            return is_mst;
        }


## Topological Sort & Interview Problems ##
    // Course Schedule I and II | Pre-requisite Tasks | Topological Sort
        // Is Possible to Finish All Tasks
            bool isPossible(int V, vector<pair<int, int> >& prerequisites) {
                vector<int> adj[V];
                for (auto it : prerequisites) {
                    adj[it.first].push_back(it.second);
                }



                int indegree[V] = {0};
                for (int i = 0; i < V; i++) {
                    for (auto it : adj[i]) {
                        indegree[it]++;
                    }
                }

                queue<int> q;
                for (int i = 0; i < V; i++) {
                    if (indegree[i] == 0) {
                        q.push(i);
                    }
                }
                vector<int> topo;
                while (!q.empty()) {
                    int node = q.front();
                    q.pop();
                    topo.push_back(node);
                    // node is in your topo sort
                    // so please remove it from the indegree

                    for (auto it : adj[node]) {
                        indegree[it]--;
                        if (indegree[it] == 0) q.push(it);
                    }
                }

                if (topo.size() == V) return true;
                return false;


            }
        // Order the Courses | Schedule The Courses
            vector<int> findOrder(int V, int m, vector<vector<int>> prerequisites)
            {
                vector<int> adj[V];
                for (auto it : prerequisites) {
                    adj[it[1]].push_back(it[0]);
                }



                int indegree[V] = {0};
                for (int i = 0; i < V; i++) {
                    for (auto it : adj[i]) {
                        indegree[it]++;
                    }
                }

                queue<int> q;
                for (int i = 0; i < V; i++) {
                    if (indegree[i] == 0) {
                        q.push(i);
                    }
                }
                vector<int> topo;
                while (!q.empty()) {
                    int node = q.front();
                    q.pop();
                    topo.push_back(node);
                    // node is in your topo sort
                    // so please remove it from the indegree

                    for (auto it : adj[node]) {
                        indegree[it]--;
                        if (indegree[it] == 0) q.push(it);
                    }
                }

                if (topo.size() == V) return topo;
                return {};
            }
    // Topological Sort Algorithm
        void dfs(int node, int vis[], stack<int> &st,
                vector<int> adj[]) {
            vis[node] = 1;
            for (auto it : adj[node]) {
                if (!vis[it]) dfs(it, vis, st, adj);
            }
            st.push(node);
        }
        vector<int> topoSort(int V, vector<int> adj[])
        {
            int vis[V] = {0};
            stack<int> st;
            for (int i = 0; i < V; i++) {
                if (!vis[i]) {
                    dfs(i, vis, st, adj);
                }
            }

            vector<int> ans;
            while (!st.empty()) {
                ans.push_back(st.top());
                st.pop();
            }
            return ans;
        }
    // Kahn's Algorithm | Topological Sort Algorithm | BFS | Using indegree
        vector<int> topoSort(int V, vector<int> adj[])
        {
            int indegree[V] = {0};
            for (int i = 0; i < V; i++) {
                for (auto it : adj[i]) {
                    indegree[it]++;
                }
            }

            queue<int> q;
            for (int i = 0; i < V; i++) {
                if (indegree[i] == 0) {
                    q.push(i);
                }
            }
            vector<int> topo;
            while (!q.empty()) {
                int node = q.front();
                q.pop();
                topo.push_back(node);
                // node is in your topo sort
                // so please remove it from the indegree

                for (auto it : adj[node]) {
                    indegree[it]--;
                    if (indegree[it] == 0) q.push(it);
                }
            }

            return topo;
        }
    // Detect a Cycle in Directed Graph | Topological Sort | Kahn's Algorithm | BFS
        bool isCyclic(int V, vector<int> adj[]) {
            int indegree[V] = {0};
            for (int i = 0; i < V; i++) {
                for (auto it : adj[i]) {
                    indegree[it]++;
                }
            }

            queue<int> q;
            for (int i = 0; i < V; i++) {
                if (indegree[i] == 0) {
                    q.push(i);
                }
            }

            int cnt = 0;
            // o(v + e)
            while (!q.empty()) {
                int node = q.front();
                q.pop();
                cnt++;
                // node is in your topo sort
                // so please remove it from the indegree

                for (auto it : adj[node]) {
                    indegree[it]--;
                    if (indegree[it] == 0) q.push(it);
                }
            }

            if (cnt == V) return false;
            return true;
        }
    // Jump Game II (return min Jumps)
        int minJumps(std::vector<int>& nums) {
            // Step 1: Initialize jumps, L, and R
            int jumps = 0;
            int L = 0, R = 0;
            int n = nums.size();

            // Step 2: Traverse while R (right pointer) has not reached the end
            while (R < n - 1) {
                int farthest = 0;
                
                // Step 3: Find the farthest we can reach in the current range [L, R]
                for (int i = L; i <= R; i++) {
                    farthest = std::max(farthest, i + nums[i]);
                }

                // Move to the next range
                L = R + 1;
                R = farthest;
                jumps++;
                
                // If we cannot progress further, return -1 (edge case handling)
                if (L > R) {
                    return -1;
                }
            }

            // Step 4: Return the number of jumps
            return jumps;
        }
    // Buy and Sell Stock II ## VVIP ##
     long getAns(long *Arr, int ind, int buy, int n, vector<vector<long>> &dp) {
                // Base case: When we reach the end of the array, there are no more decisions to make.
                if (ind == n) {
                    return 0;
                }

                // If the result for this state has already been calculated, return it
                if (dp[ind][buy] != -1) {
                    return dp[ind][buy];
                }

                long profit = 0;

                if (buy == 0) { // We can buy the stock
                    profit = max(0 + getAns(Arr, ind + 1, 0, n, dp), -Arr[ind] + getAns(Arr, ind + 1, 1, n, dp));
                }

                if (buy == 1) { // We can sell the stock
                    profit = max(0 + getAns(Arr, ind + 1, 1, n, dp), Arr[ind] + getAns(Arr, ind + 1, 0, n, dp));
                }

                // Store the calculated profit in the DP table and return it
                return dp[ind][buy] = profit;
            }
            long getMaximumProfit(long *Arr, int n) {
                // Create a DP table to memoize results
                vector<vector<long>> dp(n, vector<long>(2, -1));

                if (n == 0) {
                    return 0;
                }

                long ans = getAns(Arr, 0, 0, n, dp);
                return ans;
            }
    // Q1. Possibility of Finishing
        /*
        Q.1 -> There are a total of A courses you have to take, labeled from 1 to A.
        Some courses may have prerequisites, for example to take course 2 you have to first take course 1, which is expressed as a pair: [1,2].
        So you are given two integer array B and C of same size where for each i (B[i], C[i]) denotes a pair.
        Given the total number of courses and a list of prerequisite pairs, is it possible for you to finish all courses?
        Return 1 if it is possible to finish all the courses, or 0 if it is not possible to finish all the courses.

        Note :
            

        Problem Constraints
            1 <= A <= 6*104
            1 <= length(B) = length(C) <= 105
            1 <= B[i], C[i] <= A

        Input Format
            The first argument of input contains an integer A, representing the number of courses.
            The second argument of input contains an integer array, B.
            The third argument of input contains an integer array, C.

        Output Format
            Return 1 if it is possible to finish all the courses, or 0 if it is not possible to finish all the courses.

        Input 1:
        A = 3
        B = [1, 2]
        C = [2, 3]

            
        Output 1:
            1

        Input 2:
        A = 2
        B = [1, 2]
        C = [2, 1]

        Output 2:
            0

        */

        // CODE
        int Solution::solve(int A, vector<int> &B, vector<int> &C) {
            // Graph representation using adjacency list
            vector<vector<int>> adj(A + 1);
            // In-degree array to keep track of incoming edges for each node
            vector<int> inDegree(A + 1, 0);
            
            // Build graph and fill in-degree counts
            for (int i = 0; i < B.size(); i++) {
                adj[B[i]].push_back(C[i]);
                inDegree[C[i]]++;
            }
            
            // Queue for nodes with in-degree 0 (no prerequisites)
            queue<int> q;
            for (int i = 1; i <= A; i++) {
                if (inDegree[i] == 0) {
                    q.push(i);
                }
            }
            
            int count = 0;  // Count of courses we can complete
            while (!q.empty()) {
                int node = q.front();
                q.pop();
                count++;
                
                // Reduce in-degree for adjacent nodes
                for (int neighbor : adj[node]) {
                    inDegree[neighbor]--;
                    // If in-degree becomes zero, add to queue
                    if (inDegree[neighbor] == 0) {
                        q.push(neighbor);
                    }
                }
            }
            
            // If count equals A, all courses can be completed; otherwise, it is not possible
            return count == A ? 1 : 0;

        }
    // Q2. Topological Sort
        /*
        Q.2 -> Given an directed acyclic graph having A nodes. A matrix B of size M x 2 is given which represents the M edges such that there is a edge directed from node B[i][0] to node B[i][1].
        Topological sorting for Directed Acyclic Graph (DAG) is a linear ordering of vertices such that for every directed edge uv, vertex u comes before v in the ordering. Topological Sorting for a graph is not possible if the graph is not a DAG.
        Return the topological ordering of the graph and if it doesn't exist then return an empty array.
        If there is a solution return the correct ordering. If there are multiple solutions print the lexographically smallest one.
        Ordering (a, b, c) is said to be lexographically smaller than ordering (e, f, g) if a < e or if(a==e) then b < f and so on.

        NOTE:
            There are no self-loops in the graph.
            The graph may or may not be connected.
            Nodes are numbered from 1 to A.
            Your solution will run on multiple test cases. If you are using global variables make sure to clear them

        Problem Constraints
            2 <= A <= 104
            1 <= M <= min(100000,A*(A-1))
            1 <= B[i][0], B[i][1] <= A
            
        Input Format
            The first argument given is an integer A representing the number of nodes in the graph.
            The second argument given a matrix B of size M x 2 which represents the M edges such that there is a edge directed from node B[i][0] to node B[i][1].
            Output Format

        Output Format
            Return a one-dimensional array denoting the topological ordering of the graph and it it doesn't exist then return empty array.

        Input 1:
            A = 6
            B = [  [6, 3] 
                    [6, 1] 
                    [5, 1] 
                    [5, 2] 
                    [3, 4] 
                    [4, 2] ]

        Output 1:
            [5, 6, 1, 3, 4, 2]

        Input 2:
        A = 3
        B = [  [1, 2]
                [2, 3] 
                [3, 1] ]

        Output 2:
            []

        */

        // CODE
        vector<int> Solution::solve(int A, vector<vector<int> > &B) {
            // Graph representation using adjacency list and in-degree array
            vector<vector<int>> adj(A + 1);
            vector<int> inDegree(A + 1, 0);
            
            // Building the graph and in-degree count
            for (int i = 0; i < B.size(); i++) {
                adj[B[i][0]].push_back(B[i][1]);
                inDegree[B[i][1]]++;
            }
            
            // Priority queue (min-heap) to ensure lexicographically smallest order
            priority_queue<int, vector<int>, greater<int>> pq;
            for (int i = 1; i <= A; i++) {
                if (inDegree[i] == 0) {
                    pq.push(i);
                }
            }
            
            vector<int> topoOrder;
            while (!pq.empty()) {
                int node = pq.top();
                pq.pop();
                topoOrder.push_back(node);
                
                // Reducing the in-degree of adjacent nodes
                for (int neighbor : adj[node]) {
                    inDegree[neighbor]--;
                    if (inDegree[neighbor] == 0) {
                        pq.push(neighbor);
                    }
                }
            }
            
            // If the size of topoOrder is less than A, a cycle exists, return empty array
            if (topoOrder.size() != A) {
                return {};
            }
            
            return topoOrder;
        }
    // Q3. Best Time to Buy and Sell Stocks II
        /*
        Q.3 -> Say you have an array, A, for which the ith element is the price of a given stock on day i.
        Design an algorithm to find the maximum profit.
        You may complete as many transactions as you like (i.e., buy one and sell one share of the stock multiple times).
        However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again

        Note :
            

        Problem Constraints
            0 <= len(A) <= 1e5
            1 <= A[i] <= 1e7

        Input Format
            The first and the only argument is an array of integer, A.

        Output Format
            Return an integer, representing the maximum possible profit.

        Input 1:
            A = [1, 2, 3]

        Output 1:
            2

        Input 2:
            A = [5, 2, 10]

        Output 2:
            8

        */

        // CODE
        int Solution::maxProfit(const vector<int> &A) {
            int n = A.size();
            // No transactions possible if there are less than 2 prices
            if (n <= 1) return 0;
            
            int maxProfit = 0;
            
            // Traverse through the array and accumulate profit whenever there's a price increase
            for (int i = 1; i < n; i++) {
                if (A[i] > A[i - 1]) {
                    maxProfit += A[i] - A[i - 1];
                }
            }
            
            return maxProfit;
        }
    // Q1. Perfect Numbers
        /*
        Q.1 -> Given an integer A, you have to find the Ath Perfect Number.
        A Perfect Number has the following properties:
            It comprises only 1 and 2.
            The number of digits in a Perfect number is even.
            It is a palindrome number.
        For example, 11, 22, 112211 are Perfect numbers, where 123, 121, 782, 1 are not.

        Problem Constraints
            1 <= A <= 100000

        Input Format
            The only argument given is an integer A.

        Output Format
            Return a string that denotes the Ath Perfect Number.

        Input 1:
            A = 2

        Output 1:
            22

        Input 2:
            A = 3

        Output 2:
            1111

        */

        // CODE
        string Solution::solve(int A) {
            queue<string> q;
            q.push("1");
            q.push("2");

            // Generate the half-string corresponding to the A-th perfect number
            string half;
            for (int i = 0; i < A; i++) {
                half = q.front();
                q.pop();
                q.push(half + "1");
                q.push(half + "2");
            }

            // Form the perfect number by mirroring the half-string
            string perfectNumber = half;
            reverse(half.begin(), half.end());
            perfectNumber += half;

            return perfectNumber;
        }
    // Q2. Ways to Decode
        /*
        Q.2 -> A message containing letters from A-Z is being encoded to numbers using the following mapping:

        'A' -> 1
        'B' -> 2
        ...
        'Z' -> 26
        Given an encoded message denoted by string A containing digits, determine the total number of ways to decode it modulo 109 + 7.

        Note :
            

        Problem Constraints
            1 <= length(A) <= 105

        Input Format
            The first and the only argument is a string A.

        Output Format
            Return an integer, representing the number of ways to decode the string modulo 109 + 7.

        Input 1:
            A = "12"

        Output 1:
            2

        Input 2:
            A = "8"

        Output 2:
            1

        */

        // CODE
        int Solution::numDecodings(string A) {
            const int MOD = 1e9 + 7;
            int n = A.size();
            if (n == 0 || A[0] == '0') {
                return 0;
            }

            // dp[i] represents the number of ways to decode the string of length i
            vector<int> dp(n + 1, 0);
            dp[0] = 1; // Base case: empty string has one way to decode (do nothing)
            dp[1] = 1; // Base case: one valid digit is one way to decode (already ensured A[0] != '0')

            for (int i = 2; i <= n; ++i) {
                // Single character decoding (A[i-1] must be non-zero)
                if (A[i - 1] > '0') {
                    dp[i] = dp[i - 1];
                }

                // Two-character decoding (check if the last two characters form a valid number)
                int twoDigit = (A[i - 2] - '0') * 10 + (A[i - 1] - '0');
                if (twoDigit >= 10 && twoDigit <= 26) {
                    dp[i] = (dp[i] + dp[i - 2]) % MOD;
                }
            }

            return dp[n];
        }
    // Q3. Largest Distance between nodes of a Tree
        /*

        Q.3 -> Find largest distance Given an arbitrary unweighted rooted tree which consists of N (2 <= N <= 40000) nodes.
        The goal of the problem is to find largest distance between two nodes in a tree. Distance between two nodes is a number of edges on a path between the nodes (there will be a unique path between any pair of nodes since it is a tree).
        The nodes will be numbered 0 through N - 1.
        The tree is given as an array A, there is an edge between nodes A[i] and i (0 <= i < N). Exactly one of the i's will have A[i] equal to -1, it will be root node.

        Note :
            

        Problem Constraints
            2 <= |A| <= 40000

        Input Format
            First and only argument is vector A 

        Output Format
            Return the length of the longest path

        Input 1:
            A = [-1, 0]

        Output 1:
            1

        Input 2:
            A = [-1, 0, 0]

        Output 2:
            2

        */

        // CODE
        int Solution::solve(vector<int> &A) {
            int N = A.size();
            vector<vector<int>> adj(N);
            int root = -1;

            // Build adjacency list and find the root
            for (int i = 0; i < N; ++i) {
                if (A[i] == -1) {
                    root = i;
                } else {
                    adj[i].push_back(A[i]);
                    adj[A[i]].push_back(i);
                }
            }

            // Helper function for BFS to find the farthest node and its distance
            auto bfs = [&](int start) {
                vector<int> dist(N, -1);
                queue<int> q;
                q.push(start);
                dist[start] = 0;
                int farthestNode = start, maxDistance = 0;

                while (!q.empty()) {
                    int node = q.front();
                    q.pop();
                    for (int neighbor : adj[node]) {
                        if (dist[neighbor] == -1) { // Not visited
                            dist[neighbor] = dist[node] + 1;
                            q.push(neighbor);
                            if (dist[neighbor] > maxDistance) {
                                maxDistance = dist[neighbor];
                                farthestNode = neighbor;
                            }
                        }
                    }
                }
                return make_pair(farthestNode, maxDistance);
            };

            // Step 1: Find the farthest node from the root
            pair<int, int> firstBFS = bfs(root);

            // Step 2: Find the farthest node from the node found in step 1
            pair<int, int> secondBFS = bfs(firstBFS.first);

            // The largest distance is the maximum distance found in the second BFS
            return secondBFS.second;
        }
    // Q4. Flip Array
        /*
        Q.4 -> Given an array A of positive elements, you have to flip the sign of some of its elements such that the resultant sum of the elements of array should be minimum non-negative(as close to zero as possible).
        Return the minimum number of elements whose sign needs to be flipped such that the resultant sum is minimum non-negative.

        Note :
            

        Problem Constraints
            1 <= length of(A) <= 100
            Sum of all the elements will not exceed 10,000.

        Input Format
            First and only argument is an integer array A.

        Output Format
            Return an integer denoting the minimum number of elements whose sign needs to be flipped.

        Input 1:
            A = [15, 10, 6]

        Output 1:
            1

        Input 2:
            A = [14, 10, 4]

        Output 2:
            1

        */

        // CODE
        int minVal(int n, int sum, const vector<int> &A, vector<vector<int>> &dp) {
            if (sum == 0) return 0;  // No elements needed to make a sum of 0
            if (n == 0) return A.size();  // Can't make a sum with no elements

            if (dp[n][sum] != -1) return dp[n][sum];  // Return already computed result

            // Case 1: Don't include the current element
            int ans = minVal(n - 1, sum, A, dp);

            // Case 2: Include the current element if it's possible
            if (sum >= A[n - 1]) {
                ans = min(ans, minVal(n - 1, sum - A[n - 1], A, dp) + 1);  // Add one element
            }

            dp[n][sum] = ans;
            return ans;
        }

        int Solution::solve(const vector<int> &A) {
            int n = A.size();
            int sum = 0;

            // Calculate the total sum of elements in the array
            for (int val : A) {
                sum += val;
            }

            // We're trying to minimize the sum difference, hence we aim for sum / 2
            int S = sum / 2;
            
            // Create a dp table with dimensions (n+1) x (S+1) and initialize to -1
            vector<vector<int>> dp(n + 1, vector<int>(S + 1, -1));

            // Iterate through possible sums from S down to 0
            for (int i = S; i >= 0; i--) {
                // Get the minimum number of elements to form the sum 'i'
                int ans = minVal(n, i, A, dp);
                if (ans < n) {
                    // If a valid subset is found, return the result
                    return ans;
                }
            }

            // If no valid partition is found, return the number of elements in the array
            return n;
        }


## Graphs Extra ##
    // Introduction to Graph
    // Introduction to Graph 
        Vertices or Nodes | Edges
        Undirected Graph | Directed Graph
        Acyclic Graph | Cyclic Graph
        Degree
            Undirected 
                total degree of graph  = 2 * No of Edges
            Directed    
                Indegree
                Outdegree
        Edge Weight
    
    // Graph Representation
        // Adjacency Matrix
            int main()
            {
                int n, m;
                cin >> n >> m;
                // adjacency matrix for undirected graph
                // time complexity: O(n)
                int adj[n+1][n+1];
                for(int i = 0; i < m; i++)
                {
                    int u, v;
                    cin >> u >> v;
                    adj[u][v] = 1;
                    adj[v][u] = 1  // this statement will be removed in case of directed graph
                }
                return 0;
            }
        // Adjacency Lists
            // undirected Graph
            int main()
            {
                int n, m;
                cin >> n >> m;
                // adjacency list for undirected graph
                // time complexity: O(2E)
                vector<int> adj[n+1];
                for(int i = 0; i < m; i++)
                {
                    int u, v;
                    cin >> u >> v;
                    adj[u].push_back(v);
                    adj[v].push_back(u);
                }
                return 0;
            }
            // Directed Graph
            int main()
            {
                int n, m;
                cin >> n >> m;
                // adjacency list for directed graph
                // time complexity: O(E)
                vector<int> adj[n+1];
                for(int i = 0; i < m; i++)
                {
                    int u, v;
                    // u > v
                    cin >> u >> v;
                    adj[u].push_back(v);
                }
                return 0;
            }
            // Weighted Graph Representation
            vector< pair <int,int> > adjList[n+1]; 
    // BFS
        class Solution {
        public:
            // Function to return Breadth First Traversal of given graph.
            vector<int> bfsOfGraph(int V, vector<int> adj[]) {
                int vis[V] = {0}; 
                vis[0] = 1; 
                queue<int> q;
                // push the initial starting node 
                q.push(0); 
                vector<int> bfs; 
                // iterate till the queue is empty 
                while(!q.empty()) {
                // get the topmost element in the queue 
                    int node = q.front(); 
                    q.pop(); 
                    bfs.push_back(node); 
                    // traverse for all its neighbours 
                    for(auto it : adj[node]) {
                        // if the neighbour has previously not been visited, 
                        // store in Q and mark as visited 
                        if(!vis[it]) {
                            vis[it] = 1; 
                            q.push(it); 
                        }
                    }
                }
                return bfs; 
            }
        };
        void addEdge(vector <int> adj[], int u, int v) {
            adj[u].push_back(v);
            adj[v].push_back(u);
        }
        void printAns(vector <int> &ans) {
            for (int i = 0; i < ans.size(); i++) {
                cout << ans[i] << " ";
            }
        }
        int main() 
        {
            vector <int> adj[6];
            
            addEdge(adj, 0, 1);
            addEdge(adj, 1, 2);
            addEdge(adj, 1, 3);
            addEdge(adj, 0, 4);

            Solution obj;
            vector <int> ans = obj.bfsOfGraph(5, adj);
            printAns(ans);

            return 0;
        }
    // DFS
         void dfs(int node, vector<int> adj[], int vis[], vector<int> &ls) {
            vis[node] = 1; 
            ls.push_back(node); 
            // traverse all its neighbours
            for(auto it : adj[node]) {
                // if the neighbour is not visited
                if(!vis[it]) {
                    dfs(it, adj, vis, ls); 
                }
            }
        }
         vector<int> dfsOfGraph(int V, vector<int> adj[]) {
            int vis[V] = {0}; 
            int start = 0;
            // create a list to store dfs
            vector<int> ls; 
            // call dfs for starting node
            dfs(start, adj, vis, ls); 
            return ls; 
        }
    // Problems on BFS and DFS
    // Number of Provinces
        void dfs(int node, vector<int> adjLs[], int vis[]) {
            // mark the more as visited
            vis[node] = 1; 
            for(auto it: adjLs[node]) {
                if(!vis[it]) {
                    dfs(it, adjLs, vis); 
                }
            }
        }
        int numProvinces(vector<vector<int>> adj, int V) {
            vector<int> adjLs[V]; 
            
            // to change adjacency matrix to list 
            for(int i = 0;i<V;i++) {
                for(int j = 0;j<V;j++) {
                    // self nodes are not considered
                    if(adj[i][j] == 1 && i != j) {
                        adjLs[i].push_back(j); 
                        adjLs[j].push_back(i); 
                    }
                }
            }
            int vis[V] = {0}; 
            int cnt = 0; 
            for(int i = 0;i<V;i++) {
                // if the node is not visited
                if(!vis[i]) {
                    // counter to count the number of provinces 
                    cnt++;
                dfs(i, adjLs, vis); 
                }
            }
            return cnt; 
            
        }
    // Number of Distinct Islands [dfs multisource]
        void bfs(int row, int col, vector<vector<int>> &vis, vector<vector<char>>&grid) {
            // mark it visited
            vis[row][col] = 1; 
            queue<pair<int,int>> q;
            // push the node in queue
            q.push({row, col}); 
            int n = grid.size(); 
            int m = grid[0].size(); 
            
            // until the queue becomes empty
            while(!q.empty()) {
                int row = q.front().first; 
                int col = q.front().second; 
                q.pop(); 
                
                // traverse in the neighbours and mark them if its a land 
                for(int delrow = -1; delrow<=1;delrow++) {
                    for(int delcol = -1; delcol <= 1; delcol++) {
                        int nrow = row + delrow; 
                        int ncol = col + delcol; 
                        // neighbour row and column is valid, and is an unvisited land
                        if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m 
                        && grid[nrow][ncol] == '1' && !vis[nrow][ncol]) {
                            vis[nrow][ncol] = 1; 
                            q.push({nrow, ncol}); 
                        }
                    }
                }
            }
        }
        int numIslands(vector<vector<char>>& grid) {
            int n = grid.size(); 
            int m = grid[0].size(); 
            // create visited array and initialise to 0
            vector<vector<int>> vis(n, vector<int>(m, 0)); 
            int cnt = 0; 
            for(int row = 0; row < n ; row++) {
                for(int col = 0; col < m ;col++) {
                    // if not visited and is a land
                    if(!vis[row][col] && grid[row][col] == '1') {
                        cnt++; 
                        bfs(row, col, vis, grid); 
                    }
                }
            }
            return cnt; 
        }
    // Flood Fill Algorithm
        void dfs(int row, int col, vector<vector<int>>&ans,
        vector<vector<int>>& image, int newColor, int delRow[], int delCol[],
        int iniColor) {
            // color with new color
            ans[row][col] = newColor; 
            int n = image.size();
            int m = image[0].size(); 
            // there are exactly 4 neighbours
            for(int i = 0;i<4;i++) {
                int nrow = row + delRow[i]; 
                int ncol = col + delCol[i]; 
                // check for valid coordinate 
                // then check for same initial color and unvisited pixel
                if(nrow>=0 && nrow<n && ncol>=0 && ncol < m && 
                image[nrow][ncol] == iniColor && ans[nrow][ncol] != newColor) {
                    dfs(nrow, ncol, ans, image, newColor, delRow, delCol, iniColor); 
                }
            }
        }

        vector<vector<int>> floodFill(vector<vector<int>>& image, 
        int sr, int sc, int newColor) {
            // get initial color
            int iniColor = image[sr][sc]; 
            vector<vector<int>> ans = image; 
            // delta row and delta column for neighbours
            int delRow[] = {-1, 0, +1, 0};
            int delCol[] = {0, +1, 0, -1}; 
            dfs(sr, sc, ans, image, newColor, delRow, delCol, iniColor); 
            return ans; 
        }
    // Rotten Oranges
        int orangesRotting(vector<vector<int>>& grid) {
            if(grid.empty()) return 0;
            int m = grid.size(), n = grid[0].size(), time = 0, tot = 0, cnt = 0;
            queue<pair<int, int>> rotten;
            for(int i = 0; i < m; ++i){
                for(int j = 0; j < n; ++j){
                    if(grid[i][j] != 0) tot++;
                    if(grid[i][j] == 2) rotten.push({i, j});
                }
            }
            
            int dx[4] = {0, 0, 1, -1};
            int dy[4] = {1, -1, 0, 0};
            
            while(!rotten.empty()){
                int k = rotten.size();
                cnt += k; 
                while(k--){
                    int x = rotten.front().first, y = rotten.front().second;
                    rotten.pop();
                    for(int i = 0; i < 4; ++i){
                        int nx = x + dx[i], ny = y + dy[i];
                        if(nx < 0 || ny < 0 || nx >= m || ny >= n || grid[nx][ny] != 1) continue;
                        grid[nx][ny] = 2;
                        rotten.push({nx, ny});
                    }
                }
                if(!rotten.empty()) time++;
            }
            
            return tot == cnt ? time : -1;
        }
    // Detect Cycle in an Undirected Graph (using BFS)
        bool detect(int src, vector<int> adj[], int vis[]) {
            vis[src] = 1; 
            // store <source node, parent node>
            queue<pair<int,int>> q; 
            q.push({src, -1}); 
            // traverse until queue is not empty
            while(!q.empty()) {
                int node = q.front().first; 
                int parent = q.front().second; 
                q.pop(); 
                
                // go to all adjacent nodes
                for(auto adjacentNode: adj[node]) {
                    // if adjacent node is unvisited
                    if(!vis[adjacentNode]) {
                        vis[adjacentNode] = 1; 
                        q.push({adjacentNode, node}); 
                    }
                    // if adjacent node is visited and is not it's own parent node
                    else if(parent != adjacentNode) {
                        // yes it is a cycle
                        return true; 
                    }
                }
            }
            // there's no cycle
            return false; 
        }
        bool isCycle(int V, vector<int> adj[]) {
            // initialise them as unvisited 
            int vis[V] = {0};
            for(int i = 0;i<V;i++) {
                if(!vis[i]) {
                    if(detect(i, adj, vis)) return true; 
                }
            }
            return false; 
        }
    // Detect Cycle in an Undirected Graph (using DFS)
        bool dfs(int node, int parent, int vis[], vector<int> adj[]) {
            vis[node] = 1; 
            // visit adjacent nodes
            for(auto adjacentNode: adj[node]) {
                // unvisited adjacent node
                if(!vis[adjacentNode]) {
                    if(dfs(adjacentNode, node, vis, adj) == true) 
                        return true; 
                }
                // visited node but not a parent node
                else if(adjacentNode != parent) return true; 
            }
            return false; 
        }

        bool isCycle(int V, vector<int> adj[]) {
            int vis[V] = {0}; 
            // for graph with connected components 
            for(int i = 0;i<V;i++) {
                if(!vis[i]) {
                    if(dfs(i, -1, vis, adj) == true) return true; 
                }
            }
            return false; 
        }
    // Distance of nearest cell having 1
        vector<vector<int>>nearest(vector<vector<int>>grid)
        {
            int n = grid.size(); 
            int m = grid[0].size(); 
            // visited and distance matrix
            vector<vector<int>> vis(n, vector<int>(m, 0)); 
            vector<vector<int>> dist(n, vector<int>(m, 0)); 
            // <coordinates, steps>
            queue<pair<pair<int,int>, int>> q; 
            // traverse the matrix
            for(int i = 0;i<n;i++) {
                for(int j = 0;j<m;j++) {
                    // start BFS if cell contains 1
                    if(grid[i][j] == 1) {
                        q.push({{i,j}, 0}); 
                        vis[i][j] = 1; 
                    }
                    else {
                        // mark unvisited 
                        vis[i][j] = 0; 
                    }
                }
            }
            
            int delrow[] = {-1, 0, +1, 0}; 
            int delcol[] = {0, +1, 0, -1}; 
            
            // traverse till queue becomes empty
            while(!q.empty()) {
                int row = q.front().first.first; 
                int col = q.front().first.second; 
                int steps = q.front().second; 
                q.pop(); 
                dist[row][col] = steps; 
                // for all 4 neighbours
                for(int i = 0;i<4;i++) {
                    int nrow = row + delrow[i]; 
                    int ncol = col + delcol[i]; 
                    // check for valid unvisited cell
                    if(nrow >= 0 && nrow < n && ncol >= 0 && ncol < m 
                    && vis[nrow][ncol] == 0) {
                        vis[nrow][ncol] = 1; 
                        q.push({{nrow, ncol}, steps+1});  
                    }
                }
            }
            // return distance matrix
            return dist; 
        }
    // Surrounded Regions
        void dfs(int row, int col, vector<vector<int>> &vis, vector<vector<char>> &mat, int delrow[], int delcol[]) {
            vis[row][col] = 1; 
            int n = mat.size();
            int m = mat[0].size();
            
            // check for top, right, bottom, left 
            for(int i = 0;i<4;i++) {
                int nrow = row + delrow[i];
                int ncol = col + delcol[i]; 
                // check for valid coordinates and unvisited Os
                if(nrow >=0 && nrow <n && ncol >= 0 && ncol < m 
                && !vis[nrow][ncol] && mat[nrow][ncol] == 'O') {
                    dfs(nrow, ncol, vis, mat, delrow, delcol); 
                }
            }
        }
        vector<vector<char>> fill(int n, int m, vector<vector<char>> mat)
        {
            int delrow[] = {-1, 0, +1, 0};
            int delcol[] = {0, 1, 0, -1}; 
            vector<vector<int>> vis(n, vector<int>(m,0)); 
            // traverse first row and last row 
            for(int j = 0 ; j<m;j++) {
                // check for unvisited Os in the boundary rows
                // first row 
                if(!vis[0][j] && mat[0][j] == 'O') {
                    dfs(0, j, vis, mat, delrow, delcol); 
                }
                
                // last row 
                if(!vis[n-1][j] && mat[n-1][j] == 'O') {
                    dfs(n-1,j,vis,mat, delrow, delcol); 
                }
            }
            
            for(int i = 0;i<n;i++) {
                // check for unvisited Os in the boundary columns
                // first column 
                if(!vis[i][0] && mat[i][0] == 'O') {
                    dfs(i, 0, vis, mat, delrow, delcol); 
                }
                
                // last column
                if(!vis[i][m-1] && mat[i][m-1] == 'O') {
                    dfs(i, m-1, vis, mat, delrow, delcol); 
                }
            }
            
            // if unvisited O then convert to X
            for(int i = 0;i<n;i++) {
                for(int j= 0 ;j<m;j++) {
                    if(!vis[i][j] && mat[i][j] == 'O') 
                        mat[i][j] = 'X'; 
                }
            }
            
            return mat; 
        }
    // Number of Enclaves
        int numberOfEnclaves(vector<vector<int>> &grid) {
            queue<pair<int,int>> q; 
            int n = grid.size(); 
            int m = grid[0].size(); 
            int vis[n][m] = {0}; 
            // traverse boundary elements
            for(int i = 0;i<n;i++) {
                for(int j = 0;j<m;j++) {
                    // first row, first col, last row, last col 
                    if(i == 0 || j == 0 || i == n-1 || j == m-1) {
                        // if it is a land then store it in queue
                        if(grid[i][j] == 1) {
                            q.push({i, j}); 
                            vis[i][j] = 1; 
                        }
                    }
                }
            }
            
            int delrow[] = {-1, 0, +1, 0};
            int delcol[] = {0, +1, +0, -1}; 
            
            while(!q.empty()) {
                int row = q.front().first; 
                int col = q.front().second; 
                q.pop(); 
                
                // traverses all 4 directions
                for(int i = 0;i<4;i++) {
                    int nrow = row + delrow[i];
                    int ncol = col + delcol[i]; 
                    // check for valid coordinates and for land cell
                    if(nrow >=0 && nrow <n && ncol >=0 && ncol < m 
                    && vis[nrow][ncol] == 0 && grid[nrow][ncol] == 1) {
                        q.push({nrow, ncol});
                        vis[nrow][ncol] = 1; 
                    }
                }
                
            }
            
            int cnt = 0;
            for(int i = 0;i<n;i++) {
                for(int j = 0;j<m;j++) {
                    // check for unvisited land cell
                    if(grid[i][j] == 1 & vis[i][j] == 0) 
                        cnt++; 
                }
            }
            return cnt; 
        }
    // Number of Distinct Islands | Constructive Thinking + DFS
        void dfs(vector<vector<int>>& grid, vector<vector<bool>>& visited, vector<pair<int, int>>& shape, int r, int c, int baseR, int baseC) {
            // Dimensions of the grid
            int rows = grid.size();
            int cols = grid[0].size();
            
            // Mark this cell as visited
            visited[r][c] = true;

            // Record the relative position of this cell
            shape.push_back({r - baseR, c - baseC});

            // Directions for moving: right, down, left, up
            vector<pair<int, int>> directions = {{0, 1}, {1, 0}, {0, -1}, {-1, 0}};
            
            for (auto [dr, dc] : directions) {
                int nr = r + dr, nc = c + dc;
                if (nr >= 0 && nr < rows && nc >= 0 && nc < cols && grid[nr][nc] == 1 && !visited[nr][nc]) {
                    dfs(grid, visited, shape, nr, nc, baseR, baseC);
                }
            }
        }
        int numDistinctIslands(vector<vector<int>>& grid) {
            int rows = grid.size();
            int cols = grid[0].size();
            vector<vector<bool>> visited(rows, vector<bool>(cols, false));
            set<vector<pair<int, int>>> uniqueIslands;

            for (int r = 0; r < rows; ++r) {
                for (int c = 0; c < cols; ++c) {
                    if (grid[r][c] == 1 && !visited[r][c]) {
                        vector<pair<int, int>> shape;
                        dfs(grid, visited, shape, r, c, r, c);
                        uniqueIslands.insert(shape);
                    }
                }
            }

            return uniqueIslands.size();
        }
    // Bipartite Graph BFS
        bool check(int start, int V, vector<int>adj[], int color[]) {
            queue<int> q;
            q.push(start); 
            color[start] = 0; 
            while(!q.empty()) {
                int node = q.front();
                q.pop(); 
                
                for(auto it : adj[node]) {
                    // if the adjacent node is yet not colored
                    // you will give the opposite color of the node 
                    if(color[it] == -1) {
                        
                        color[it] = !color[node]; 
                        q.push(it); 
                    }
                    // is the adjacent guy having the same color 
                    // someone did color it on some other path 
                    else if(color[it] == color[node]) {
                        return false; 
                    }
                }
            }
            return true; 
        }
        bool isBipartite(int V, vector<int>adj[]){
            int color[V]; 
            for(int i = 0;i<V;i++) color[i] = -1; 
            
            for(int i = 0;i<V;i++) {
                // if not coloured
                if(color[i] == -1) {
                    if(check(i, V, adj, color) == false) {
                        return false; 
                    }
                }
            }
            return true; 
        }
    // Bipartite Graph DFS
        bool dfs(int node, int col, int color[], vector<int> adj[]) {
            color[node] = col; 
            
            // traverse adjacent nodes
            for(auto it : adj[node]) {
                // if uncoloured
                if(color[it] == -1) {
                    if(dfs(it, !col, color, adj) == false) return false; 
                }
                // if previously coloured and have the same colour
                else if(color[it] == col) {
                    return false; 
                }
            }
            
            return true; 
        }

        bool isBipartite(int V, vector<int>adj[]){
            int color[V];
            for(int i = 0;i<V;i++) color[i] = -1; 
            
            // for connected components
            for(int i = 0;i<V;i++) {
                if(color[i] == -1) {
                    if(dfs(i, 0, color, adj) == false) 
                        return false; 
                }
            }
            return true; 
        }
    // Detect cycle in a directed graph using DFS
        bool dfsCheck(int node, vector<int> adj[], int vis[], int pathVis[]) {
            vis[node] = 1;
            pathVis[node] = 1;

            // traverse for adjacent nodes
            for (auto it : adj[node]) {
                // when the node is not visited
                if (!vis[it]) {
                    if (dfsCheck(it, adj, vis, pathVis) == true)
                        return true;
                }
                // if the node has been previously visited
                // but it has to be visited on the same path
                else if (pathVis[it]) {
                    return true;
                }
            }

            pathVis[node] = 0;
            return false;
        }

    	bool isCyclic(int V, vector<int> adj[]) {
            int vis[V] = {0};
            int pathVis[V] = {0};

            for (int i = 0; i < V; i++) {
                if (!vis[i]) {
                    if (dfsCheck(i, adj, vis, pathVis) == true) return true;
                }
            }
            return false;
        }    
    // Find Eventual Safe States | Find Safe Nodes
        bool dfsCheck(int node, vector<int> adj[], int vis[],int pathVis[], int check[]) {
            vis[node] = 1;
            pathVis[node] = 1;
            check[node] = 0;
            // traverse for adjacent nodes
            for (auto it : adj[node]) {
                // when the node is not visited
                if (!vis[it]) {
                if (dfsCheck(it, adj, vis, pathVis, check) == true) {
                        check[node] = 0;
                        return true;
                    }

                }
                // if the node has been previously visited
                // but it has to be visited on the same path
                else if (pathVis[it]) {
                    check[node] = 0;
                    return true;
                }
            }
            check[node] = 1;
            pathVis[node] = 0;
            return false;
        }

        vector<int> eventualSafeNodes(int V, vector<int> adj[]) {
            int vis[V] = {0};
            int pathVis[V] = {0};
            int check[V] = {0};
            vector<int> safeNodes;
            for (int i = 0; i < V; i++) {
                if (!vis[i]) {
                    dfsCheck(i, adj, vis, pathVis, check);
                }
            }
            for (int i = 0; i < V; i++) {
                if (check[i] == 1) safeNodes.push_back(i);
            }
            return safeNodes;
        }
    // Topological Sort & Problems
    // Topological Sort Algorithm
        void dfs(int node, int vis[], stack<int> &st,
                vector<int> adj[]) {
            vis[node] = 1;
            for (auto it : adj[node]) {
                if (!vis[it]) dfs(it, vis, st, adj);
            }
            st.push(node);
        }
        vector<int> topoSort(int V, vector<int> adj[])
        {
            int vis[V] = {0};
            stack<int> st;
            for (int i = 0; i < V; i++) {
                if (!vis[i]) {
                    dfs(i, vis, st, adj);
                }
            }

            vector<int> ans;
            while (!st.empty()) {
                ans.push_back(st.top());
                st.pop();
            }
            return ans;
        }
    // Kahn's Algorithm | Topological Sort Algorithm | BFS
        vector<int> topoSort(int V, vector<int> adj[])
        {
            int indegree[V] = {0};
            for (int i = 0; i < V; i++) {
                for (auto it : adj[i]) {
                    indegree[it]++;
                }
            }

            queue<int> q;
            for (int i = 0; i < V; i++) {
                if (indegree[i] == 0) {
                    q.push(i);
                }
            }
            vector<int> topo;
            while (!q.empty()) {
                int node = q.front();
                q.pop();
                topo.push_back(node);
                // node is in your topo sort
                // so please remove it from the indegree

                for (auto it : adj[node]) {
                    indegree[it]--;
                    if (indegree[it] == 0) q.push(it);
                }
            }

            return topo;
        }
    // Detect a Cycle in Directed Graph | Topological Sort | Kahn's Algorithm | BFS
        bool isCyclic(int V, vector<int> adj[]) {
            int indegree[V] = {0};
            for (int i = 0; i < V; i++) {
                for (auto it : adj[i]) {
                    indegree[it]++;
                }
            }

            queue<int> q;
            for (int i = 0; i < V; i++) {
                if (indegree[i] == 0) {
                    q.push(i);
                }
            }

            int cnt = 0;
            // o(v + e)
            while (!q.empty()) {
                int node = q.front();
                q.pop();
                cnt++;
                // node is in your topo sort
                // so please remove it from the indegree

                for (auto it : adj[node]) {
                    indegree[it]--;
                    if (indegree[it] == 0) q.push(it);
                }
            }

            if (cnt == V) return false;
            return true;
        }
    // Course Schedule I and II | Pre-requisite Tasks | Topological Sort
        // Is Possible to Finish All Tasks
            bool isPossible(int V, vector<pair<int, int> >& prerequisites) {
                vector<int> adj[V];
                for (auto it : prerequisites) {
                    adj[it.first].push_back(it.second);
                }



                int indegree[V] = {0};
                for (int i = 0; i < V; i++) {
                    for (auto it : adj[i]) {
                        indegree[it]++;
                    }
                }

                queue<int> q;
                for (int i = 0; i < V; i++) {
                    if (indegree[i] == 0) {
                        q.push(i);
                    }
                }
                vector<int> topo;
                while (!q.empty()) {
                    int node = q.front();
                    q.pop();
                    topo.push_back(node);
                    // node is in your topo sort
                    // so please remove it from the indegree

                    for (auto it : adj[node]) {
                        indegree[it]--;
                        if (indegree[it] == 0) q.push(it);
                    }
                }

                if (topo.size() == V) return true;
                return false;


            }
        // Order the Courses | Schedule The Courses
            vector<int> findOrder(int V, int m, vector<vector<int>> prerequisites)
            {
                vector<int> adj[V];
                for (auto it : prerequisites) {
                    adj[it[1]].push_back(it[0]);
                }



                int indegree[V] = {0};
                for (int i = 0; i < V; i++) {
                    for (auto it : adj[i]) {
                        indegree[it]++;
                    }
                }

                queue<int> q;
                for (int i = 0; i < V; i++) {
                    if (indegree[i] == 0) {
                        q.push(i);
                    }
                }
                vector<int> topo;
                while (!q.empty()) {
                    int node = q.front();
                    q.pop();
                    topo.push_back(node);
                    // node is in your topo sort
                    // so please remove it from the indegree

                    for (auto it : adj[node]) {
                        indegree[it]--;
                        if (indegree[it] == 0) q.push(it);
                    }
                }

                if (topo.size() == V) return topo;
                return {};
            }
    // Find Eventual Safe States - BFS - Topological Sort
        // Reverse the Edges of Graph mark the Indegree
        // push all all 0 indegree NODE into queue
        // BFS traverse the graph and store the in Safe node
        vector<int> eventualSafeNodes(int V, vector<int> adj[]) {
            vector<int> adjRev[V];
            int indegree[V] = {0};
            for (int i = 0; i < V; i++) {
                // i -> it
                // it -> i
                for (auto it : adj[i]) {
                    adjRev[it].push_back(i);
                    indegree[i]++;
                }
            }
            queue<int> q;
            vector<int> safeNodes;
            for (int i = 0; i < V; i++) {
                if (indegree[i] == 0) {
                    q.push(i);
                }
            }

            while (!q.empty()) {
                int node = q.front();
                q.pop();
                safeNodes.push_back(node);
                for (auto it : adjRev[node]) {
                    indegree[it]--;
                    if (indegree[it] == 0) q.push(it);
                }
            }

            sort(safeNodes.begin(), safeNodes.end());
            return safeNodes;
        }
    // Alien Dictionary - Topological Sort
        vector<int> topoSort(int V, vector<int> adj[])
        {
            int indegree[V] = {0};
            for (int i = 0; i < V; i++) {
                for (auto it : adj[i]) {
                    indegree[it]++;
                }
            }

            queue<int> q;
            for (int i = 0; i < V; i++) {
                if (indegree[i] == 0) {
                    q.push(i);
                }
            }
            vector<int> topo;
            while (!q.empty()) {
                int node = q.front();
                q.pop();
                topo.push_back(node);
                // node is in your topo sort
                // so please remove it from the indegree

                for (auto it : adj[node]) {
                    indegree[it]--;
                    if (indegree[it] == 0) q.push(it);
                }
            }

            return topo;
        }
        string findOrder(string dict[], int N, int K) {
            vector<int>adj[K];
            for (int i = 0; i < N - 1; i++) {
                string s1 = dict[i];
                string s2 = dict[i + 1];
                int len = min(s1.size(), s2.size());
                for (int ptr = 0; ptr < len; ptr++) {
                    if (s1[ptr] != s2[ptr]) {
                        adj[s1[ptr] - 'a'].push_back(s2[ptr] - 'a');
                        break;
                    }
                }
            }

            vector<int> topo = topoSort(K, adj);
            string ans = "";
            for (auto it : topo) {
                ans = ans + char(it + 'a');
            }
            return ans;
        }
    // Shortest Path Algorithms and Problems
    // Shortest Path in Directed Acyclic Graph - Topological Sort
        void topoSort(int node, vector < pair < int, int >> adj[],
            int vis[], stack < int > & st) {
            //This is the function to implement Topological sort. 
            vis[node] = 1;
            for (auto it: adj[node]) {
                int v = it.first;
                if (!vis[v]) {
                topoSort(v, adj, vis, st);
                }
            }
            st.push(node);
        }
        vector<int> shortestPath(int N, int M, vector < vector < int >> & edges) {
            //We create a graph first in the form of an adjacency list.
            vector < pair < int, int >> adj[N];
            for (int i = 0; i < M; i++) {
                int u = edges[i][0];
                int v = edges[i][1];
                int wt = edges[i][2];
                adj[u].push_back({v, wt}); 
            }
            // A visited array is created with initially 
            // all the nodes marked as unvisited (0).
            int vis[N] = {
                0
            };
            //Now, we perform topo sort using DFS technique 
            //and store the result in the stack st.
            stack < int > st;
            for (int i = 0; i < N; i++) {
                if (!vis[i]) {
                topoSort(i, adj, vis, st);
                }
            }
            //Further, we declare a vector dist in which we update the value of the nodes
            //distance from the source vertex after relaxation of a particular node.

            vector < int > dist(N);
            for (int i = 0; i < N; i++) {
                dist[i] = 1e9;
            }

            dist[0] = 0;
            while (!st.empty()) {
                int node = st.top();
                st.pop();

                for (auto it: adj[node]) {
                int v = it.first;
                int wt = it.second;

                if (dist[node] + wt < dist[v]) {
                    dist[v] = wt + dist[node];
                }
                }
            }

            for (int i = 0; i < N; i++) {
                if (dist[i] == 1e9) dist[i] = -1;
            }
            return dist;
        }
    // Shortest Path in Undirected Graph with Unit Weights
        vector<int> shortestPath(vector<vector<int>>& edges, int N,int M, int src){
            //Create an adjacency list of size N for storing the undirected graph.
            vector<int> adj[N]; 
            for(auto it : edges) {
                adj[it[0]].push_back(it[1]); 
                adj[it[1]].push_back(it[0]); 
            }

            //A dist array of size N initialised with a large number to 
            //indicate that initially all the nodes are untraversed.    
        
            int dist[N];
            for(int i = 0;i<N;i++) dist[i] = 1e9;
            // BFS Implementation.
            dist[src] = 0; 
            queue<int> q;
            q.push(src); 
            while(!q.empty()) {
                int node = q.front(); 
                q.pop(); 
                for(auto it : adj[node]) {
                    if(dist[node] + 1 < dist[it]) {
                        dist[it] = 1 + dist[node]; 
                        q.push(it); 
                    }
                }
            }
            // Updated shortest distances are stored in the resultant array ans.
            // Unreachable nodes are marked as -1. 
            vector<int> ans(N, -1);
            for(int i = 0;i<N;i++) {
                if(dist[i] != 1e9) {
                    ans[i] = dist[i]; 
                }
            }
            return ans; 
        }
    // Word Ladder - I | Shortest Paths
        int wordLadderLength(string startWord, string targetWord, vector<string> &wordList)
        {
            // Creating a queue ds of type {word,transitions to reach word}.
            queue<pair<string, int>> q;

            // BFS traversal with pushing values in queue 
            // when after a transformation, a word is found in wordList.
            q.push({startWord, 1});

            // Push all values of wordList into a set
            // to make deletion from it easier and in less time complexity.
            unordered_set<string> st(wordList.begin(), wordList.end());
            st.erase(startWord);
            while (!q.empty())
            {
                string word = q.front().first;
                int steps = q.front().second;
                q.pop();

                // we return the steps as soon as
                // the first occurence of targetWord is found.
                if (word == targetWord)
                    return steps;

                for (int i = 0; i < word.size(); i++)
                {
                    // Now, replace each character of word with char
                    // from a-z then check if word exists in wordList.
                    char original = word[i];
                    for (char ch = 'a'; ch <= 'z'; ch++)
                    {
                        word[i] = ch;
                        // check if it exists in the set and push it in the queue.
                        if (st.find(word) != st.end())
                        {
                            st.erase(word);
                            q.push({word, steps + 1});
                        }
                    }
                    word[i] = original;
                }
            }
            // If there is no transformation sequence possible
            return 0;
        }
    // Word Ladder - II | Shortest Paths
        vector<vector<string>> findSequences(string beginWord, string endWord, vector<string> &wordList)
        {
            // Push all values of wordList into a set
            // to make deletion from it easier and in less time complexity.
            unordered_set<string> st(wordList.begin(), wordList.end());
            
            // Creating a queue ds which stores the words in a sequence which is
            // required to reach the targetWord after successive transformations.
            queue<vector<string>> q;

            // BFS traversal with pushing the new formed sequence in queue 
            // when after a transformation, a word is found in wordList.

            q.push({beginWord});

            // A vector defined to store the words being currently used
            // on a level during BFS.
            vector<string> usedOnLevel;
            usedOnLevel.push_back(beginWord);
            int level = 0;
        
            // A vector to store the resultant transformation sequence.
            vector<vector<string>> ans;
            while (!q.empty())
            {
                vector<string> vec = q.front();
                q.pop();

                // Now, erase all words that have been
                // used in the previous levels to transform
                if (vec.size() > level)
                {
                    level++;
                    for (auto it : usedOnLevel)
                    {
                        st.erase(it);
                    }
                }

                string word = vec.back();

                // store the answers if the end word matches with targetWord.
                if (word == endWord)
                {
                    // the first sequence where we reached end
                    if (ans.size() == 0)
                    {
                        ans.push_back(vec);
                    }
                    else if (ans[0].size() == vec.size())
                    {
                        ans.push_back(vec);
                    }
                }
                for (int i = 0; i < word.size(); i++)
                {   
                    // Now, replace each character of word with char
                    // from a-z then check if word exists in wordList.
                    char original = word[i];
                    for (char c = 'a'; c <= 'z'; c++)
                    {
                        word[i] = c;
                        if (st.count(word) > 0)
                        { 
                            // Check if the word is present in the wordList and
                            // push the word along with the new sequence in the queue.
                            vec.push_back(word);
                            q.push(vec);
                            // mark as visited on the level
                            usedOnLevel.push_back(word);
                            vec.pop_back();
                        }
                    }
                    word[i] = original;
                }
            }
            return ans;
        }
    // Word Ladder - II | Optimized approach
        // Create a map of type word->level to get the idea 
        // on which level the word comes after the transformations.
        unordered_map<string, int> mpp;

        // A vector for storing the final answer.
        vector<vector<string>> ans;
        string b;

        void dfs(string word, vector<string> &seq)
        {
            // Function for implementing backtracking using the created map
            // in reverse order to find the transformation sequence in less time.

            // Base condition :
            // If word equals beginWord, weve found one of the sequences
            // simply reverse the sequence and return. 
            if (word == b)
            {
                reverse(seq.begin(), seq.end());
                ans.push_back(seq);
        
                // reverse again so that the dfs calls are not disturbed.
                reverse(seq.begin(), seq.end());
                return;
            }
            int sz = word.size();
            int steps = mpp[word];

            // Replace each character of the word with letters from a-z 
            // and check whether the transformed word is present in the map
            // and at the previous level or not.  
            for (int i = 0; i < sz; i++)
            {
                char original = word[i];
                for (char ch = 'a'; ch <= 'z'; ch++)
                {
                    word[i] = ch;
                    if (mpp.find(word) != mpp.end() && mpp[word] + 1 == steps)
                    {
                        seq.push_back(word);
                        dfs(word, seq);
                        // pop the current word from the back of the queue
                        // to traverse other possibilities.
                        seq.pop_back();
                    }
                }
                word[i] = original;
            }
        }

        vector<vector<string>> findLadders(string beginWord, string endWord, vector<string> &wordList)
        {
            // Push all values of wordList into a set
            // to make deletion from it easier and in less time complexity.
            unordered_set<string> st(wordList.begin(), wordList.end());

            // Perform BFS traversal and push the string in the queue
            // as soon as theyre found in the wordList.
            queue<string> q;
            b = beginWord;
            q.push({beginWord});

            // beginWord initialised with level 1.
            mpp[beginWord] = 1;
            int sz = beginWord.size();
            st.erase(beginWord);
            while (!q.empty())
            {

                string word = q.front();
                int steps = mpp[word];
                q.pop();
                
                // Break out if the word matches the endWord
                if (word == endWord)
                    break;

                // Replace each character of the word with letters from a-z 
                // and check whether the transformed word is present in the 
                // wordList or not, if yes then push to queue
                for (int i = 0; i < sz; i++)
                {
                    char original = word[i];

                    for (char ch = 'a'; ch <= 'z'; ch++)
                    {

                        word[i] = ch;
                        if (st.count(word))
                        {
                            q.push(word);
                            st.erase(word);
                        
                            // push the word along with its level
                            // in the map data structure.
                            mpp[word] = steps + 1;
                        }
                    }
                    word[i] = original;
                }
            }
        
            // If we reach the endWord, we stop and move to step-2
            // that is to perform reverse dfs traversal.
            if (mpp.find(endWord) != mpp.end())
            {
                vector<string> seq;
                seq.push_back(endWord);
                dfs(endWord, seq);
            }
            return ans;
        }
    // Dijkstra's Algorithm - Using Priority Queue - C++ and Java - Part 1
        vector<int> dijkstra(int V, vector<vector<int>> adj[], int S)
        {

            // Create a priority queue for storing the nodes as a pair {dist,node}
            // where dist is the distance from source to the node. 
            // Min Heap
            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int, int>>> pq;

            // Initialising distTo list with a large number to
            // indicate the nodes are unvisited initially.
            // This list contains distance from source to the nodes.
            vector<int> distTo(V, INT_MAX);

            // Source initialised with dist=0.
            distTo[S] = 0;
            pq.push({0, S});

            // Now, pop the minimum distance node first from the min-heap
            // and traverse for all its adjacent nodes.
            while (!pq.empty())
            {
                int node = pq.top().second;
                int dis = pq.top().first;
                pq.pop();

                // Check for all adjacent nodes of the popped out
                // element whether the prev dist is larger than current or not.
                for (auto it : adj[node])
                {
                    int v = it[0];
                    int w = it[1];
                    if (dis + w < distTo[v])
                    {
                        distTo[v] = dis + w;
        
                        // If current distance is smaller,
                        // push it into the queue.
                        pq.push({dis + w, v});
                    }
                }
            }
            // Return the list containing shortest distances
            // from source to all the nodes.
            return distTo;
        }
    // Dijkstra's Algorithm - Using Set - Part 2
        vector <int> dijkstra(int V, vector<vector<int>> adj[], int S)
        {
            // Create a set ds for storing the nodes as a pair {dist,node}
            // where dist is the distance from source to the node.
            // set stores the nodes in ascending order of the distances 
            set<pair<int,int>> st; 

            // Initialising dist list with a large number to
            // indicate the nodes are unvisited initially.
            // This list contains distance from source to the nodes.
            vector<int> dist(V, 1e9); 
            
            st.insert({0, S}); 

            // Source initialised with dist=0
            dist[S] = 0;
            
            // Now, erase the minimum distance node first from the set
            // and traverse for all its adjacent nodes.
            while(!st.empty()) {
                auto it = *(st.begin()); 
                int node = it.second; 
                int dis = it.first; 
                st.erase(it); 
                
                // Check for all adjacent nodes of the erased
                // element whether the prev dist is larger than current or not.
                for(auto it : adj[node]) {
                    int adjNode = it[0]; 
                    int edgW = it[1]; 
                    
                    if(dis + edgW < dist[adjNode]) {
                        // erase if it was visited previously at 
                        // a greater cost.
                        if(dist[adjNode] != 1e9) 
                            st.erase({dist[adjNode], adjNode}); 
                            
                        // If current distance is smaller,
                        // push it into the queue
                        dist[adjNode] = dis + edgW; 
                        st.insert({dist[adjNode], adjNode}); 
                    }
                }
            }
            // Return the list containing shortest distances
            // from source to all the nodes.
            return dist; 
        }
    // Dijkstra's Algorithm - Why PQ and not Q, Intuition, Time Complexity Derivation - Part 3
        Using Normal Queue Gives Unnessary Path like 
            {D, V} -> Queue push End
            {3, 3}
            {7, 3} -> Queue pop End

    // Print Shortest Path - Dijkstras Algorithm
        vector<int> shortestPath(int n, int m, vector<vector<int>> &edges)
        {
            // Create an adjacency list of pairs of the form node1 -> {node2, edge weight}
            // where the edge weight is the weight of the edge from node1 to node2.
            vector<pair<int, int>> adj[n + 1];
            for (auto it : edges)
            {
                adj[it[0]].push_back({it[1], it[2]});
                adj[it[1]].push_back({it[0], it[2]});
            }
            // Create a priority queue for storing the nodes along with distances 
            // in the form of a pair { dist, node }.
            priority_queue<pair<int, int>, vector<pair<int, int>>, greater<pair<int,int>>> pq;

            // Create a dist array for storing the updated distances and a parent array
            //for storing the nodes from where the current nodes represented by indices of
            // the parent array came from.
            vector<int> dist(n + 1, 1e9), parent(n + 1);
            for (int i = 1; i <= n; i++)
                parent[i] = i;

            dist[1] = 0;

            // Push the source node to the queue.
            pq.push({0, 1});
            while (!pq.empty())
            {
                // Topmost element of the priority queue is with minimum distance value.
                auto it = pq.top();
                pq.pop();
                int node = it.second;
                int dis = it.first;

                // Iterate through the adjacent nodes of the current popped node.
                for (auto it : adj[node])
                {
                    int adjNode = it.first;
                    int edW = it.second;

                    // Check if the previously stored distance value is 
                    // greater than the current computed value or not, 
                    // if yes then update the distance value.
                    if (dis + edW < dist[adjNode])
                    {
                        dist[adjNode] = dis + edW;
                        pq.push({dis + edW, adjNode});

                        // Update the parent of the adjNode to the recent 
                        // node where it came from.
                        parent[adjNode] = node;
                    }
                }
            }

            // If distance to a node could not be found, return an array containing -1.
            if (dist[n] == 1e9)
                return {-1};

            // Store the final path in the path array.
            vector<int> path;
            int node = n;

            // Iterate backwards from destination to source through the parent array.
            while (parent[node] != node)
            {
                path.push_back(node);
                node = parent[node];
            }
            path.push_back(1);

            // Since the path stored is in a reverse order, we reverse the array
            // to get the final answer and then return the array.
            reverse(path.begin(), path.end());
            return path;
        }
    // Shortest Distance in a Binary Maze
        int shortestPath(vector<vector<int>> &grid, pair<int, int> source, pair<int, int> destination)
        {
            // Edge Case: if the source is only the destination.
            if (source.first == destination.first &&
                source.second == destination.second)
                return 0;

            // Create a queue for storing cells with their distances from source
            // in the form {dist,{cell coordinates pair}}.
            queue<pair<int, pair<int, int>>> q;
            int n = grid.size();
            int m = grid[0].size();

            // Create a distance matrix with initially all the cells marked as
            // unvisited and the source cell as 0.
            vector<vector<int>> dist(n, vector<int>(m, 1e9));
            dist[source.first][source.second] = 0;
            q.push({0, {source.first, source.second}});

            // The following delta rows and delts columns array are created such that
            // each index represents each adjacent node that a cell may have 
            // in a direction.
            int dr[] = {-1, 0, 1, 0};
            int dc[] = {0, 1, 0, -1};

            // Iterate through the maze by popping the elements out of the queue
            // and pushing whenever a shorter distance to a cell is found.
            while (!q.empty())
            {
                auto it = q.front();
                q.pop();
                int dis = it.first;
                int r = it.second.first;
                int c = it.second.second;

                // Through this loop, we check the 4 direction adjacent nodes
                // for a shorter path to destination.
                for (int i = 0; i < 4; i++)
                {
                    int newr = r + dr[i];
                    int newc = c + dc[i];

                    // Checking the validity of the cell and updating if dist is shorter.
                    if (newr >= 0 && newr < n && newc >= 0 && newc < m && grid[newr][newc] 
                    == 1 && dis + 1 < dist[newr][newc])
                    {
                        dist[newr][newc] = 1 + dis;

                        // Return the distance until the point when
                        // we encounter the destination cell.
                        if (newr == destination.first &&
                            newc == destination.second)
                            return dis + 1;
                        q.push({1 + dis, {newr, newc}});
                    }
                }
            }
            // If no path is found from source to destination.
            return -1;
        }
    // Path With Minimum Effort
        int MinimumEffort(vector<vector<int>> &heights)
        {

            // Create a priority queue containing pairs of cells 
            // and their respective distance from the source cell in the 
            // form {diff, {row of cell, col of cell}}.
            priority_queue<pair<int, pair<int, int>>,
                        vector<pair<int, pair<int, int>>>,
                        greater<pair<int, pair<int, int>>>>
                pq;

            int n = heights.size();
            int m = heights[0].size();

            // Create a distance matrix with initially all the cells marked as
            // unvisited and the dist for source cell (0,0) as 0.
            vector<vector<int>> dist(n, vector<int>(m, 1e9));
            dist[0][0] = 0;
            pq.push({0, {0, 0}});

            // The following delta rows and delts columns array are created such that
            // each index represents each adjacent node that a cell may have 
            // in a direction.
            int dr[] = {-1, 0, 1, 0};
            int dc[] = {0, 1, 0, -1};

            // Iterate through the matrix by popping the elements out of the queue
            // and pushing whenever a shorter distance to a cell is found.
            while (!pq.empty())
            {
                auto it = pq.top();
                pq.pop();
                int diff = it.first;
                int row = it.second.first;
                int col = it.second.second;

                // Check if we have reached the destination cell,
                // return the current value of difference (which will be min).
                if (row == n - 1 && col == m - 1)
                    return diff;
            
                for (int i = 0; i < 4; i++)
                {
                    // row - 1, col
                    // row, col + 1
                    // row - 1, col
                    // row, col - 1
                    int newr = row + dr[i];
                    int newc = col + dc[i];

                    // Checking validity of the cell.
                    if (newr >= 0 && newc >= 0 && newr < n && newc < m)
                    {
                        // Effort can be calculated as the max value of differences 
                        // between the heights of the node and its adjacent nodes.
                        int newEffort = max(abs(heights[row][col] - heights[newr][newc]), diff);

                        // If the calculated effort is less than the prev value
                        // we update as we need the min effort.
                        if (newEffort < dist[newr][newc])
                        {
                            dist[newr][newc] = newEffort;
                            pq.push({newEffort, {newr, newc}});
                        }
                    }
                }
            }
            return 0; // if unreachable
        }
    // Cheapest Flights Within K Stops
        int CheapestFLight(int n, vector<vector<int>> &flights, int src, int dst, int K)
        {
            // Create the adjacency list to depict airports and flights in
            // the form of a graph.
            vector<pair<int, int>> adj[n];
            for (auto it : flights)
            {
                adj[it[0]].push_back({it[1], it[2]});
            }

            // Create a queue which stores the node and their distances from the
            // source in the form of {stops, {node, dist}} with stops indicating 
            // the no. of nodes between src and current node.
            queue<pair<int, pair<int, int>>> q;
            
            q.push({0, {src, 0}});

            // Distance array to store the updated distances from the source.
            vector<int> dist(n, 1e9);
            dist[src] = 0;

            // Iterate through the graph using a queue like in Dijkstra with 
            // popping out the element with min stops first.
            while (!q.empty())
            {
                auto it = q.front();
                q.pop();
                int stops = it.first;
                int node = it.second.first;
                int cost = it.second.second;

                // We stop the process as soon as the limit for the stops reaches.
                if (stops > K)
                    continue;
                for (auto iter : adj[node])
                {
                    int adjNode = iter.first;
                    int edW = iter.second;

                    // We only update the queue if the new calculated dist is
                    // less than the prev and the stops are also within limits.
                    if (cost + edW < dist[adjNode] && stops <= K)
                    {
                        dist[adjNode] = cost + edW;
                        q.push({stops + 1, {adjNode, cost + edW}});
                    }
                }
            }
            // If the destination node is unreachable return -1
            // else return the calculated dist from src to dst.
            if (dist[dst] == 1e9)
                return -1;
            return dist[dst];
        }
    // Minimum Multiplications to Reach End
        int minimumMultiplications(vector<int> &arr, int start, int end)
        {
            // Create a queue for storing the numbers as a result of multiplication
            // of the numbers in the array and the start number.
            queue<pair<int, int>> q;
            q.push({start, 0});

            // Create a dist array to store the no. of multiplications to reach
            // a particular number from the start number.
            vector<int> dist(100000, 1e9);
            dist[start] = 0;
            int mod = 100000;

            // Multiply the start no. with each of numbers in the arr
            // until we get the end no.
            while (!q.empty())
            {
                int node = q.front().first;
                int steps = q.front().second;
                q.pop();

                for (auto it : arr)
                {
                    int num = (it * node) % mod;

                    // If the no. of multiplications are less than before
                    // in order to reach a number, we update the dist array.
                    if (steps + 1 < dist[num])
                    {
                        dist[num] = steps + 1;

                        // Whenever we reach the end number
                        // return the calculated steps
                        if (num == end)
                            return steps + 1;
                        q.push({num, steps + 1});
                    }
                }
            }
            // If the end no. is unattainable.
            return -1;
        }
    // Number of Ways to Arrive at Destination
        int countPaths(int n, vector<vector<int>> &roads)
        {
            // Creating an adjacency list for the given graph.
            vector<pair<int, int>> adj[n];
            for (auto it : roads)
            {
                adj[it[0]].push_back({it[1], it[2]});
                adj[it[1]].push_back({it[0], it[2]});
            }

            // Defining a priority queue (min heap). 
            priority_queue<pair<int, int>,
                        vector<pair<int, int>>, greater<pair<int, int>>> pq;

            // Initializing the dist array and the ways array
            // along with their first indices.
            vector<int> dist(n, INT_MAX), ways(n, 0);
            dist[0] = 0;
            ways[0] = 1;
            pq.push({0, 0});

            // Define modulo value
            int mod = (int)(1e9 + 7);

            // Iterate through the graph with the help of priority queue
            // just as we do in Dijkstra's Algorithm.
            while (!pq.empty())
            {
                int dis = pq.top().first;
                int node = pq.top().second;
                pq.pop();

                for (auto it : adj[node])
                {
                    int adjNode = it.first;
                    int edW = it.second;

                    // This if condition signifies that this is the first
                    // time were coming with this short distance, so we push
                    // in PQ and keep the no. of ways the same.
                    if (dis + edW < dist[adjNode])
                    {
                        dist[adjNode] = dis + edW;
                        pq.push({dis + edW, adjNode});
                        ways[adjNode] = ways[node];
                    }

                    // If we again encounter a node with the same short distance
                    // as before, we simply increment the no. of ways.
                    else if (dis + edW == dist[adjNode])
                    {
                        ways[adjNode] = (ways[adjNode] + ways[node]) % mod;
                    }
                }
            }
            // Finally, we return the no. of ways to reach
            // (n-1)th node modulo 10^9+7.
            return ways[n - 1] % mod;
        }
    // Bellman Ford Algorithm
        vector<int> bellman_ford(int V, vector<vector<int>>& edges, int S) {
            vector<int> dist(V, 1e8);
            dist[S] = 0;
            for (int i = 0; i < V - 1; i++) {
                for (auto it : edges) {
                    int u = it[0];
                    int v = it[1];
                    int wt = it[2];
                    if (dist[u] != 1e8 && dist[u] + wt < dist[v]) {
                        dist[v] = dist[u] + wt;
                    }
                }
            }
            // Nth relaxation to check negative cycle
            for (auto it : edges) {
                int u = it[0];
                int v = it[1];
                int wt = it[2];
                if (dist[u] != 1e8 && dist[u] + wt < dist[v]) {
                    return { -1};
                }
            }


            return dist;
        }
    // Floyd Warshall Algorithm
        void shortest_distance(vector<vector<int>>&matrix) {
            int n = matrix.size();
            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (matrix[i][j] == -1) {
                        matrix[i][j] = 1e9;
                    }
                    if (i == j) matrix[i][j] = 0;
                }
            }

            for (int k = 0; k < n; k++) {
                for (int i = 0; i < n; i++) {
                    for (int j = 0; j < n; j++) {
                        matrix[i][j] = min(matrix[i][j],
                                        matrix[i][k] + matrix[k][j]);
                    }
                }
            }




            for (int i = 0; i < n; i++) {
                for (int j = 0; j < n; j++) {
                    if (matrix[i][j] == 1e9) {
                        matrix[i][j] = -1;
                    }
                }
            }
        }
    // Find the City With the Smallest Number of Neighbours at a Threshold Distance
        int findCity(int n, int m, vector<vector<int>>& edges,
                    int distanceThreshold) {
            vector<vector<int>> dist(n, vector<int> (n, INT_MAX));
            for (auto it : edges) {
                dist[it[0]][it[1]] = it[2];
                dist[it[1]][it[0]] = it[2];
            }
            for (int i = 0; i < n; i++) dist[i][i] = 0;
            for (int k = 0; k < n; k++) {
                for (int i = 0; i < n; i++) {
                    for (int j = 0; j < n; j++) {
                        if (dist[i][k] == INT_MAX || dist[k][j] == INT_MAX)
                            continue;
                        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
                    }
                }
            }

            int cntCity = n;
            int cityNo = -1;
            for (int city = 0; city < n; city++) {
                int cnt = 0;
                for (int adjCity = 0; adjCity < n; adjCity++) {
                    if (dist[city][adjCity] <= distanceThreshold)
                        cnt++;
                }

                if (cnt <= cntCity) {
                    cntCity = cnt;
                    cityNo = city;
                }
            }
            return cityNo;

        }
    // Minimum Spanning tree / Disjoint set and Problems
    // Minimum Spanning Tree - Theory

    // Prim's Algorithm - Minimum Spanning Tree
        int spanningTree(int V, vector<vector<int>> adj[])
        {
            priority_queue<pair<int, int>, vector<pair<int, int> >, greater<pair<int, int>>> pq;

            vector<int> vis(V, 0);
            // {wt, node}
            pq.push({0, 0});
            int sum = 0;
            while (!pq.empty()) {
                auto it = pq.top();
                pq.pop();
                int node = it.second;
                int wt = it.first;

                if (vis[node] == 1) continue;
                // add it to the mst
                vis[node] = 1;
                sum += wt;
                for (auto it : adj[node]) {
                    int adjNode = it[0];
                    int edW = it[1];
                    if (!vis[adjNode]) {
                        pq.push({edW, adjNode});
                    }
                }
            }
            return sum;
        }
    // Disjoint Set | Union by Rank | Union by Size | Path Compression
        class DisjointSet {
            vector<int> rank, parent;
        public:
            DisjointSet(int n) {
                rank.resize(n + 1, 0);
                parent.resize(n + 1);
                for (int i = 0; i <= n; i++) {
                    parent[i] = i;
                }
            }

            int findUPar(int node) {
                if (node == parent[node])
                    return node;
                return parent[node] = findUPar(parent[node]);
            }

            void unionByRank(int u, int v) {
                int ulp_u = findUPar(u);
                int ulp_v = findUPar(v);
                if (ulp_u == ulp_v) return;
                if (rank[ulp_u] < rank[ulp_v]) {
                    parent[ulp_u] = ulp_v;
                }
                else if (rank[ulp_v] < rank[ulp_u]) {
                    parent[ulp_v] = ulp_u;
                }
                else {
                    parent[ulp_v] = ulp_u;
                    rank[ulp_u]++;
                }
            }
        };
        int main() {
            DisjointSet ds(7);
            ds.unionByRank(1, 2);
            ds.unionByRank(2, 3);
            ds.unionByRank(4, 5);
            ds.unionByRank(6, 7);
            ds.unionByRank(5, 6);
            // if 3 and 7 same or not
            if (ds.findUPar(3) == ds.findUPar(7)) {
                cout << "Same\n";
            }
            else cout << "Not same\n";

            ds.unionByRank(3, 7);

            if (ds.findUPar(3) == ds.findUPar(7)) {
                cout << "Same\n";
            }
            else cout << "Not same\n";
            return 0;
        }
    // Kruskal's Algorithm - Minimum Spanning Tree
         //Function to find sum of weights of edges of the Minimum Spanning Tree.
        int spanningTree(int V, vector<vector<int>> adj[])
        {
            // 1 - 2 wt = 5
            /// 1 - > (2, 5)
            // 2 -> (1, 5)

            // 5, 1, 2
            // 5, 2, 1
            vector<pair<int, pair<int, int>>> edges;
            for (int i = 0; i < V; i++) {
                for (auto it : adj[i]) {
                    int adjNode = it[0];
                    int wt = it[1];
                    int node = i;

                    edges.push_back({wt, {node, adjNode}});
                }
            }
            DisjointSet ds(V);
            sort(edges.begin(), edges.end());
            int mstWt = 0;
            for (auto it : edges) {
                int wt = it.first;
                int u = it.second.first;
                int v = it.second.second;

                if (ds.findUPar(u) != ds.findUPar(v)) {
                    mstWt += wt;
                    ds.unionBySize(u, v);
                }
            }

            return mstWt;
        }
    // Number of Provinces - Disjoint Set
        int findProvinces(int n, vector<vector<int>>& isConnected) {
            vector<int> parent(n);
            vector<int> rank(n, 0);
            
            // Initialize each node as its own parent (each city is its own province initially)
            for (int i = 0; i < n; ++i) {
                parent[i] = i;
            }
            
            // Traverse the matrix and apply union for every connection (1 in isConnected[i][j])
            for (int i = 0; i < n; ++i) {
                for (int j = i + 1; j < n; ++j) {  // Only need to check upper triangular matrix
                    if (isConnected[i][j] == 1) {
                        unionSets(i, j, parent, rank);  // Union cities i and j
                    }
                }
            }
            
            // Count the number of unique provinces (root nodes)
            int provinces = 0;
            for (int i = 0; i < n; ++i) {
                if (parent[i] == i) {
                    provinces++;
                }
            }
            
            return provinces;
        }
    // Number of Operations to Make Network Connected
        int Solve(int n, vector<vector<int>>& edge) {
            DisjointSet ds(n);
            int cntExtras = 0;
            for (auto it : edge) {
                int u = it[0];
                int v = it[1];
                if (ds.findUPar(u) == ds.findUPar(v)) {
                    cntExtras++;
                }
                else {
                    ds.unionBySize(u, v);
                }
            }
            int cntC = 0;
            for (int i = 0; i < n; i++) {
                if (ds.parent[i] == i) cntC++;
            }
            int ans = cntC - 1;
            if (cntExtras >= ans) return ans;
            return -1;
        }
    // Accounts Merge - DSU
        vector<vector<string>> accountsMerge(vector<vector<string>> &details) {
            int n = details.size();
            DisjointSet ds(n);
            sort(details.begin(), details.end());
            unordered_map<string, int> mapMailNode;
            for (int i = 0; i < n; i++) {
                for (int j = 1; j < details[i].size(); j++) {
                    string mail = details[i][j];
                    if (mapMailNode.find(mail) == mapMailNode.end()) {
                        mapMailNode[mail] = i;
                    }
                    else {
                        ds.unionBySize(i, mapMailNode[mail]);
                    }
                }
            }

            vector<string> mergedMail[n];
            for (auto it : mapMailNode) {
                string mail = it.first;
                int node = ds.findUPar(it.second);
                mergedMail[node].push_back(mail);
            }

            vector<vector<string>> ans;

            for (int i = 0; i < n; i++) {
                if (mergedMail[i].size() == 0) continue;
                sort(mergedMail[i].begin(), mergedMail[i].end());
                vector<string> temp;
                temp.push_back(details[i][0]);
                for (auto it : mergedMail[i]) {
                    temp.push_back(it);
                }
                ans.push_back(temp);
            }
            sort(ans.begin(), ans.end());
            return ans;
        }
    // Number of Islands - II - Online Queries - DSU
        vector<int> numOfIslands(int n, int m, vector<vector<int>> &operators) {
            DisjointSet ds(n * m);
            int vis[n][m];
            memset(vis, 0, sizeof vis);
            int cnt = 0;
            vector<int> ans;
            for (auto it : operators) {
                int row = it[0];
                int col = it[1];
                if (vis[row][col] == 1) {
                    ans.push_back(cnt);
                    continue;
                }
                vis[row][col] = 1;
                cnt++;
                // row - 1, col
                // row , col + 1
                // row + 1, col
                // row, col - 1;
                int dr[] = { -1, 0, 1, 0};
                int dc[] = {0, 1, 0, -1};
                for (int ind = 0; ind < 4; ind++) {
                    int adjr = row + dr[ind];
                    int adjc = col + dc[ind];
                    if (isValid(adjr, adjc, n, m)) {
                        if (vis[adjr][adjc] == 1) {
                            int nodeNo = row * m + col;
                            int adjNodeNo = adjr * m + adjc;
                            if (ds.findUPar(nodeNo) != ds.findUPar(adjNodeNo)) {
                                cnt--;
                                ds.unionBySize(nodeNo, adjNodeNo);
                            }
                        }
                    }
                }
                ans.push_back(cnt);
            }
            return ans;
        }
    // Making a Large Island - DSU
        int MaxConnection(vector<vector<int>>& grid) {
            int n = grid.size();
            DisjointSet ds(n * n);
            // step - 1
            for (int row = 0; row < n ; row++) {
                for (int col = 0; col < n ; col++) {
                    if (grid[row][col] == 0) continue;
                    int dr[] = { -1, 0, 1, 0};
                    int dc[] = {0, -1, 0, 1};
                    for (int ind = 0; ind < 4; ind++) {
                        int newr = row + dr[ind];
                        int newc = col + dc[ind];
                        if (isValid(newr, newc, n) && grid[newr][newc] == 1) {
                            int nodeNo = row * n + col;
                            int adjNodeNo = newr * n + newc;
                            ds.unionBySize(nodeNo, adjNodeNo);
                        }
                    }
                }
            }
            // step 2
            int mx = 0;
            for (int row = 0; row < n; row++) {
                for (int col = 0; col < n; col++) {
                    if (grid[row][col] == 1) continue;
                    int dr[] = { -1, 0, 1, 0};
                    int dc[] = {0, -1, 0, 1};
                    set<int> components;
                    for (int ind = 0; ind < 4; ind++) {
                        int newr = row + dr[ind];
                        int newc = col + dc[ind];
                        if (isValid(newr, newc, n)) {
                            if (grid[newr][newc] == 1) {
                                components.insert(ds.findUPar(newr * n + newc));
                            }
                        }
                    }
                    int sizeTotal = 0;
                    for (auto it : components) {
                        sizeTotal += ds.size[it];
                    }
                    mx = max(mx, sizeTotal + 1);
                }
            }
            for (int cellNo = 0; cellNo < n * n; cellNo++) {
                mx = max(mx, ds.size[ds.findUPar(cellNo)]);
            }
            return mx;
        }
    // Most Stones Removed with Same Row or Column - DSU
        int maxRemove(vector<vector<int>>& stones, int n) {
            int maxRow = 0;
            int maxCol = 0;
            for (auto it : stones) {
                maxRow = max(maxRow, it[0]);
                maxCol = max(maxCol, it[1]);
            }
            DisjointSet ds(maxRow + maxCol + 1);
            unordered_map<int, int> stoneNodes;
            for (auto it : stones) {
                int nodeRow = it[0];
                int nodeCol = it[1] + maxRow + 1;
                ds.unionBySize(nodeRow, nodeCol);
                stoneNodes[nodeRow] = 1;
                stoneNodes[nodeCol] = 1;
            }

            int cnt = 0;
            for (auto it : stoneNodes) {
                if (ds.findUPar(it.first) == it.first) {
                    cnt++;
                }
            }
            return n - cnt;
        }
    // Strongly Connected Components - Kosaraju's Algorithm
        void dfs(int node, vector<int> &vis, vector<int> adj[],
            stack<int> &st) {
            vis[node] = 1;
            for (auto it : adj[node]) {
                if (!vis[it]) {
                    dfs(it, vis, adj, st);
                }
            }

            st.push(node);
        }

        void dfs3(int node, vector<int> &vis, vector<int> adjT[]) {
            vis[node] = 1;
            for (auto it : adjT[node]) {
                if (!vis[it]) {
                    dfs3(it, vis, adjT);
                }
            }
        }

        int kosaraju(int V, vector<int> adj[])
        {
            vector<int> vis(V, 0);
            stack<int> st;
            for (int i = 0; i < V; i++) {
                if (!vis[i]) {
                    dfs(i, vis, adj, st);
                }
            }

            vector<int> adjT[V];
            for (int i = 0; i < V; i++) {
                vis[i] = 0;
                for (auto it : adj[i]) {
                    // i -> it
                    // it -> i
                    adjT[it].push_back(i);
                }
            }
            int scc = 0;
            while (!st.empty()) {
                int node = st.top();
                st.pop();
                if (!vis[node]) {
                    scc++;
                    dfs3(node, vis, adjT);
                }
            }
            return scc;
        }
    // Bridges in Graph - Using Tarjan's Algorithm of time in and low time
        int timer = 1;
        void dfs(int node, int parent, vector<int> &vis,
                    vector<int> adj[], int tin[], int low[], vector<vector<int>> &bridges) {
            vis[node] = 1;
            tin[node] = low[node] = timer;
            timer++;
            for (auto it : adj[node]) {
                if (it == parent) continue;
                if (vis[it] == 0) {
                    dfs(it, node, vis, adj, tin, low, bridges);
                    low[node] = min(low[it], low[node]);
                    // node --- it
                    if (low[it] > tin[node]) {
                        bridges.push_back({it, node});
                    }
                }
                else {
                    low[node] = min(low[node], low[it]);
                }
            }
        }

        vector<vector<int>> criticalConnections(int n, vector<vector<int>>& connections) {
            vector<int> adj[n];
            for (auto it : connections) {
                int u = it[0], v = it[1];
                adj[u].push_back(v);
                adj[v].push_back(u);
            }
            vector<int> vis(n, 0);
            int tin[n];
            int low[n];
            vector<vector<int>> bridges;
            dfs(0, -1, vis, adj, tin, low, bridges);
            return bridges;
        }
    // Articulation Point in Graph
        int timer = 1;
        void dfs(int node, int parent, vector<int> &vis, int tin[], int low[],
                    vector<int> &mark, vector<int>adj[]) {
            vis[node] = 1;
            tin[node] = low[node] = timer;
            timer++;
            int child = 0;
            for (auto it : adj[node]) {
                if (it == parent) continue;
                if (!vis[it]) {
                    dfs(it, node, vis, tin, low, mark, adj);
                    low[node] = min(low[node], low[it]);
                    if (low[it] >= tin[node] && parent != -1) {
                        mark[node] = 1;
                    }
                    child++;
                }
                else {
                    low[node] = min(low[node], tin[it]);
                }
            }
            if (child > 1 && parent == -1) {
                mark[node] = 1;
            }
        }
        vector<int> articulationPoints(int n, vector<int>adj[]) {
            vector<int> vis(n, 0);
            int tin[n];
            int low[n];
            vector<int> mark(n, 0);
            for (int i = 0; i < n; i++) {
                if (!vis[i]) {
                    dfs(i, -1, vis, tin, low, mark, adj);
                }
            }
            vector<int> ans;
            for (int i = 0; i < n; i++) {
                if (mark[i] == 1) {
                    ans.push_back(i);
                }
            }
            if (ans.size() == 0) return { -1};
            return ans;
        }